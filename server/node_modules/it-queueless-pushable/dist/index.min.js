(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.ItQueuelessPushable = factory()}(typeof self !== 'undefined' ? self : this, function () {
"use strict";var ItQueuelessPushable=(()=>{var o=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var c=Object.getOwnPropertyNames;var x=Object.prototype.hasOwnProperty;var f=(r,e)=>{for(var t in e)o(r,t,{get:e[t],enumerable:!0})},w=(r,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of c(e))!x.call(r,s)&&s!==t&&o(r,s,{get:()=>e[s],enumerable:!(n=d(e,s))||n.enumerable});return r};var v=r=>w(o({},"__esModule",{value:!0}),r);var N={};f(N,{queuelessPushable:()=>m});function i(){let r={};return r.promise=new Promise((e,t)=>{r.resolve=e,r.reject=t}),r}var a=class extends Error{type;code;constructor(e,t,n){super(e??"The operation was aborted"),this.type="aborted",this.name=n??"AbortError",this.code=t??"ABORT_ERR"}};async function h(r,e,t){if(e==null)return r;if(e.aborted)return r.catch(()=>{}),Promise.reject(new a(t?.errorMessage,t?.errorCode,t?.errorName));let n,s=new a(t?.errorMessage,t?.errorCode,t?.errorName);try{return await Promise.race([r,new Promise((p,l)=>{n=()=>{l(s)},e.addEventListener("abort",n)})])}finally{n!=null&&e.removeEventListener("abort",n)}}var u=class{readNext;haveNext;ended;nextResult;constructor(){this.ended=!1,this.readNext=i(),this.haveNext=i()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");let e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=i(),e}async throw(e){return this.ended=!0,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){let e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=i(),await h(this.readNext.promise,t?.signal,t)}};function m(){return new u}return v(N);})();
return ItQueuelessPushable}));
