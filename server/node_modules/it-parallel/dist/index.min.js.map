{
  "version": 3,
  "sources": ["../src/index.ts", "../../../node_modules/p-defer/index.js"],
  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * Takes an (async) iterable that emits promise-returning functions, invokes them in parallel up to the concurrency limit and emits the results as they become available, optionally in the same order as the input\n *\n * @example\n *\n * ```javascript\n * import parallel from 'it-parallel'\n * import all from 'it-all'\n * import delay from 'delay'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const input = [\n *   async () => {\n *     console.info('start 1')\n *     await delay(500)\n *\n *     console.info('end 1')\n *     return 1\n *   },\n *   async () => {\n *     console.info('start 2')\n *     await delay(200)\n *\n *     console.info('end 2')\n *     return 2\n *   },\n *   async () => {\n *     console.info('start 3')\n *     await delay(100)\n *\n *     console.info('end 3')\n *     return 3\n *   }\n * ]\n *\n * const result = await all(parallel(input, {\n *   concurrency: 2\n * }))\n *\n * // output:\n * // start 1\n * // start 2\n * // end 2\n * // start 3\n * // end 3\n * // end 1\n *\n * console.info(result) // [2, 3, 1]\n * ```\n *\n * If order is important, pass `ordered: true` as an option:\n *\n * ```javascript\n * const result = await all(parallel(input, {\n *   concurrency: 2,\n *   ordered: true\n * }))\n *\n * // output:\n * // start 1\n * // start 2\n * // end 2\n * // start 3\n * // end 3\n * // end 1\n *\n * console.info(result) // [1, 2, 3]\n * ```\n */\n\nimport defer from 'p-defer'\n\ninterface Operation<T> {\n  done: boolean\n  ok: boolean\n  err: Error\n  value: T\n}\n\nconst CustomEvent = globalThis.CustomEvent ?? Event\n\nexport interface ParallelOptions {\n  /**\n   * How many jobs to execute in parallel (default: )\n   */\n  concurrency?: number\n  ordered?: boolean\n}\n\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n */\nexport default async function * parallel <T> (source: Iterable<() => Promise<T>> | AsyncIterable<() => Promise<T>>, options: ParallelOptions = {}): AsyncGenerator<T, void, undefined> {\n  let concurrency = options.concurrency ?? Infinity\n\n  if (concurrency < 1) {\n    concurrency = Infinity\n  }\n\n  const ordered = options.ordered ?? false\n  const emitter = new EventTarget()\n\n  const ops: Array<Operation<T>> = []\n  let slotAvailable = defer()\n  let resultAvailable = defer()\n  let sourceFinished = false\n  let sourceErr: Error | undefined\n  let opErred = false\n\n  emitter.addEventListener('task-complete', () => {\n    resultAvailable.resolve()\n  })\n\n  void Promise.resolve().then(async () => {\n    try {\n      for await (const task of source) {\n        if (ops.length === concurrency) {\n          slotAvailable = defer()\n          await slotAvailable.promise\n        }\n\n        if (opErred) {\n          break\n        }\n\n        const op: any = {\n          done: false\n        }\n        ops.push(op)\n\n        task()\n          .then(result => {\n            op.done = true\n            op.ok = true\n            op.value = result\n            emitter.dispatchEvent(new CustomEvent('task-complete'))\n          }, err => {\n            op.done = true\n            op.err = err\n            emitter.dispatchEvent(new CustomEvent('task-complete'))\n          })\n      }\n\n      sourceFinished = true\n      emitter.dispatchEvent(new CustomEvent('task-complete'))\n    } catch (err: any) {\n      sourceErr = err\n      emitter.dispatchEvent(new CustomEvent('task-complete'))\n    }\n  })\n\n  function valuesAvailable (): boolean {\n    if (ordered) {\n      return ops[0]?.done\n    }\n\n    return Boolean(ops.find(op => op.done))\n  }\n\n  function * yieldOrderedValues (): Generator<T, void, unknown> {\n    while ((ops.length > 0) && ops[0].done) {\n      const op = ops[0]\n      ops.shift()\n\n      if (op.ok) {\n        yield op.value\n      } else {\n        // allow the source to exit\n        opErred = true\n        slotAvailable.resolve()\n\n        throw op.err\n      }\n\n      slotAvailable.resolve()\n    }\n  }\n\n  function * yieldUnOrderedValues (): Generator<T, void, unknown> {\n    // more values can become available while we wait for `yield`\n    // to return control to this function\n    while (valuesAvailable()) {\n      for (let i = 0; i < ops.length; i++) {\n        if (ops[i].done) {\n          const op = ops[i]\n          ops.splice(i, 1)\n          i--\n\n          if (op.ok) {\n            yield op.value\n          } else {\n            opErred = true\n            slotAvailable.resolve()\n\n            throw op.err\n          }\n\n          slotAvailable.resolve()\n        }\n      }\n    }\n  }\n\n  while (true) {\n    if (!valuesAvailable()) {\n      resultAvailable = defer()\n      await resultAvailable.promise\n    }\n\n    if (sourceErr != null) {\n      // the source threw an error, propagate it\n      throw sourceErr\n    }\n\n    if (ordered) {\n      yield * yieldOrderedValues()\n    } else {\n      yield * yieldUnOrderedValues()\n    }\n\n    if (sourceErr != null) {\n      // if the source yields an array that is `yield *`, it can throw while the\n      // onward consumer is processing the array contents - make sure we\n      // propagate the error\n      // eslint-disable-next-line @typescript-eslint/only-throw-error\n      throw sourceErr\n    }\n\n    if (sourceFinished && ops.length === 0) {\n      // not waiting for any results and no more tasks so we are done\n      break\n    }\n  }\n}\n", "export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n"],
  "mappings": ";8bAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,ICAe,SAARC,GAA0B,CAChC,IAAMC,EAAW,CAAC,EAElB,OAAAA,EAAS,QAAU,IAAI,QAAQ,CAACC,EAASC,IAAW,CACnDF,EAAS,QAAUC,EACnBD,EAAS,OAASE,CACnB,CAAC,EAEMF,CACR,CDwEA,IAAMG,EAAc,WAAW,aAAe,MAe9C,eAAOC,EAAuCC,EAAsEC,EAA2B,CAAA,EAAE,CAC/I,IAAIC,EAAcD,EAAQ,aAAe,IAErCC,EAAc,IAChBA,EAAc,KAGhB,IAAMC,EAAUF,EAAQ,SAAW,GAC7BG,EAAU,IAAI,YAEdC,EAA2B,CAAA,EAC7BC,EAAgBC,EAAK,EACrBC,EAAkBD,EAAK,EACvBE,EAAiB,GACjBC,EACAC,EAAU,GAEdP,EAAQ,iBAAiB,gBAAiB,IAAK,CAC7CI,EAAgB,QAAO,CACzB,CAAC,EAEI,QAAQ,QAAO,EAAG,KAAK,SAAW,CACrC,GAAI,CACF,cAAiBI,KAAQZ,EAAQ,CAM/B,GALIK,EAAI,SAAWH,IACjBI,EAAgBC,EAAK,EACrB,MAAMD,EAAc,SAGlBK,EACF,MAGF,IAAME,EAAU,CACd,KAAM,IAERR,EAAI,KAAKQ,CAAE,EAEXD,EAAI,EACD,KAAKE,GAAS,CACbD,EAAG,KAAO,GACVA,EAAG,GAAK,GACRA,EAAG,MAAQC,EACXV,EAAQ,cAAc,IAAIN,EAAY,eAAe,CAAC,CACxD,EAAGiB,GAAM,CACPF,EAAG,KAAO,GACVA,EAAG,IAAME,EACTX,EAAQ,cAAc,IAAIN,EAAY,eAAe,CAAC,CACxD,CAAC,CACL,CAEAW,EAAiB,GACjBL,EAAQ,cAAc,IAAIN,EAAY,eAAe,CAAC,CACxD,OAASiB,EAAU,CACjBL,EAAYK,EACZX,EAAQ,cAAc,IAAIN,EAAY,eAAe,CAAC,CACxD,CACF,CAAC,EAED,SAASkB,GAAe,CACtB,OAAIb,EACKE,EAAI,CAAC,GAAG,KAGV,EAAQA,EAAI,KAAKQ,GAAMA,EAAG,IAAI,CACvC,CAEA,SAAWI,GAAkB,CAC3B,KAAQZ,EAAI,OAAS,GAAMA,EAAI,CAAC,EAAE,MAAM,CACtC,IAAMQ,EAAKR,EAAI,CAAC,EAGhB,GAFAA,EAAI,MAAK,EAELQ,EAAG,GACL,MAAMA,EAAG,UAGT,OAAAF,EAAU,GACVL,EAAc,QAAO,EAEfO,EAAG,IAGXP,EAAc,QAAO,CACvB,CACF,CAEA,SAAWY,GAAoB,CAG7B,KAAOF,EAAe,GACpB,QAASG,EAAI,EAAGA,EAAId,EAAI,OAAQc,IAC9B,GAAId,EAAIc,CAAC,EAAE,KAAM,CACf,IAAMN,EAAKR,EAAIc,CAAC,EAIhB,GAHAd,EAAI,OAAOc,EAAG,CAAC,EACfA,IAEIN,EAAG,GACL,MAAMA,EAAG,UAET,OAAAF,EAAU,GACVL,EAAc,QAAO,EAEfO,EAAG,IAGXP,EAAc,QAAO,CACvB,CAGN,CAEA,OAAa,CAiBX,GAhBKU,EAAe,IAClBR,EAAkBD,EAAK,EACvB,MAAMC,EAAgB,SAGpBE,GAAa,OAKbP,EACF,MAAQc,EAAkB,EAE1B,MAAQC,EAAoB,EAG1BR,GAAa,MAKf,MAAMA,EAGR,GAAID,GAAkBJ,EAAI,SAAW,EAEnC,KAEJ,CACF",
  "names": ["index_exports", "__export", "parallel", "pDefer", "deferred", "resolve", "reject", "CustomEvent", "parallel", "source", "options", "concurrency", "ordered", "emitter", "ops", "slotAvailable", "pDefer", "resultAvailable", "sourceFinished", "sourceErr", "opErred", "task", "op", "result", "err", "valuesAvailable", "yieldOrderedValues", "yieldUnOrderedValues", "i"]
}
