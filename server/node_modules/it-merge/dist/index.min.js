(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.ItMerge = factory()}(typeof self !== 'undefined' ? self : this, function () {
"use strict";var ItMerge=(()=>{var i=Object.defineProperty;var c=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var x=Object.prototype.hasOwnProperty;var w=(r,e)=>{for(var t in e)i(r,t,{get:e[t],enumerable:!0})},m=(r,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of f(e))!x.call(r,s)&&s!==t&&i(r,s,{get:()=>e[s],enumerable:!(n=c(e,s))||n.enumerable});return r};var y=r=>m(i({},"__esModule",{value:!0}),r);var P={};w(P,{default:()=>S});function o(){let r={};return r.promise=new Promise((e,t)=>{r.resolve=e,r.reject=t}),r}var a=class extends Error{type;code;constructor(e,t,n){super(e??"The operation was aborted"),this.type="aborted",this.name=n??"AbortError",this.code=t??"ABORT_ERR"}};async function l(r,e,t){if(e==null)return r;if(e.aborted)return r.catch(()=>{}),Promise.reject(new a(t?.errorMessage,t?.errorCode,t?.errorName));let n,s=new a(t?.errorMessage,t?.errorCode,t?.errorName);try{return await Promise.race([r,new Promise((E,d)=>{n=()=>{d(s)},e.addEventListener("abort",n)})])}finally{n!=null&&e.removeEventListener("abort",n)}}var u=class{readNext;haveNext;ended;nextResult;error;constructor(){this.ended=!1,this.readNext=o(),this.haveNext=o()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");let e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=o(),e}async throw(e){return this.ended=!0,this.error=e,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){let e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=o(),await l(this.readNext.promise,t?.signal,t)}};function h(){return new u}function v(r){return r[Symbol.asyncIterator]!=null}async function p(r,e,t){try{await Promise.all(r.map(async n=>{for await(let s of n)await e.push(s,{signal:t}),t.throwIfAborted()})),await e.end(void 0,{signal:t})}catch(n){await e.end(n,{signal:t}).catch(()=>{})}}async function*N(r){let e=new AbortController,t=h();p(r,t,e.signal).catch(()=>{});try{yield*t}finally{e.abort()}}function*b(r){for(let e of r)yield*e}function R(...r){let e=[];for(let t of r)v(t)||e.push(t);return e.length===r.length?b(e):N(r)}var S=R;return y(P);})();
return ItMerge}));
//# sourceMappingURL=index.min.js.map
