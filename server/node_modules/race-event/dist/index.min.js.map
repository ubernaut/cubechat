{
  "version": 3,
  "sources": ["../src/index.ts", "../node_modules/abort-error/src/index.ts"],
  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * Race an event against an AbortSignal, taking care to remove any event\n * listeners that were added.\n *\n * @example Getting started\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   controller.abort()\n * }, 500)\n *\n * setTimeout(() => {\n *   // too late\n *   emitter.dispatchEvent(new CustomEvent('event'))\n * }, 1000)\n *\n * // throws an AbortError\n * const resolve = await raceEvent(emitter, 'event', controller.signal)\n * ```\n *\n * @example Aborting the promise with an error event\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   emitter.dispatchEvent(new CustomEvent('failure', {\n *     detail: new Error('Oh no!')\n *   }))\n * }, 1000)\n *\n * // throws 'Oh no!' error\n * const resolve = await raceEvent(emitter, 'success', AbortSignal.timeout(5000), {\n *   errorEvent: 'failure'\n * })\n * ```\n *\n * @example Customising the thrown AbortError\n *\n * The error message and `.code` property of the thrown `AbortError` can be\n * specified by passing options:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   controller.abort()\n * }, 500)\n *\n * // throws a Error: Oh no!\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   errorMessage: 'Oh no!',\n *   errorCode: 'ERR_OH_NO'\n * })\n * ```\n *\n * @example Only resolving on specific events\n *\n * Where multiple events with the same type are emitted, a `filter` function can\n * be passed to only resolve on one of them:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * // throws a Error: Oh no!\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   filter: (evt: Event) => {\n *     return evt.detail.foo === 'bar'\n *   }\n * })\n * ```\n *\n * @example Terminating early by throwing from the filter\n *\n * You can cause listening for the event to cease and all event listeners to be\n * removed by throwing from the filter:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * // throws Error: Cannot continue\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   filter: (evt) => {\n *     if (...reasons) {\n *       throw new Error('Cannot continue')\n *     }\n *\n *     return true\n *   }\n * })\n * ```\n */\n\nimport { AbortError } from 'abort-error'\nimport type { EventEmitter } from 'node:events'\n\nexport interface RaceEventOptions<T> {\n  /**\n   * The message for the error thrown if the signal aborts\n   */\n  errorMessage?: string\n\n  /**\n   * The code for the error thrown if the signal aborts\n   */\n  errorCode?: string\n\n  /**\n   * The name of an event emitted on the emitter that should cause the returned\n   * promise to reject. The rejection reason will be the `.detail` field of the\n   * event.\n   *\n   * @default \"error\"\n   */\n  errorEvent?: string\n\n  /**\n   * If the 'errorEvent' option has been passed, and the emitted event has no\n   * `.detail` field, reject the promise with this error instead.\n   */\n  error?: Error\n\n  /**\n   * When multiple events with the same name may be emitted, pass a filter\n   * function here to allow ignoring ones that should not cause the returned\n   * promise to resolve.\n   */\n  filter?(evt: T): boolean\n}\n\n/**\n * Race a promise against an abort signal\n */\nexport async function raceEvent <T> (emitter: EventTarget | EventEmitter, eventName: string, signal?: AbortSignal, opts?: RaceEventOptions<T>): Promise<T> {\n  // create the error here so we have more context in the stack trace\n  const error = new AbortError(opts?.errorMessage)\n\n  if (opts?.errorCode != null) {\n    // @ts-expect-error not a field of AbortError\n    error.code = opts.errorCode\n  }\n\n  const errorEvent = opts?.errorEvent ?? 'error'\n\n  if (signal?.aborted === true) {\n    return Promise.reject(error)\n  }\n\n  return new Promise((resolve, reject) => {\n    function removeListeners (): void {\n      removeListener(signal, 'abort', abortListener)\n      removeListener(emitter, eventName, eventListener)\n      removeListener(emitter, errorEvent, errorEventListener)\n    }\n\n    const eventListener = (evt: any): void => {\n      try {\n        if (opts?.filter?.(evt) === false) {\n          return\n        }\n      } catch (err: any) {\n        removeListeners()\n        reject(err)\n        return\n      }\n\n      removeListeners()\n      resolve(evt)\n    }\n\n    const errorEventListener = (evt: any): void => {\n      removeListeners()\n\n      if (evt instanceof Error) {\n        reject(evt)\n        return\n      }\n\n      reject(evt.detail ?? opts?.error ?? new Error(`The \"${opts?.errorEvent}\" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`))\n    }\n\n    const abortListener = (): void => {\n      removeListeners()\n      reject(error)\n    }\n\n    addListener(signal, 'abort', abortListener)\n    addListener(emitter, eventName, eventListener)\n    addListener(emitter, errorEvent, errorEventListener)\n  })\n}\n\nfunction addListener (emitter: EventEmitter | EventTarget | undefined, event: string, listener: any): void {\n  if (emitter == null) {\n    return\n  }\n\n  if (isEventTarget(emitter)) {\n    emitter.addEventListener(event, listener)\n  } else {\n    emitter.addListener(event, listener)\n  }\n}\n\nfunction removeListener (emitter: EventEmitter | EventTarget | undefined, event: string, listener: any): void {\n  if (emitter == null) {\n    return\n  }\n\n  if (isEventTarget(emitter)) {\n    emitter.removeEventListener(event, listener)\n  } else {\n    emitter.removeListener(event, listener)\n  }\n}\n\nfunction isEventTarget (emitter: any): emitter is EventTarget {\n  return typeof emitter.addEventListener === 'function' && typeof emitter.removeEventListener === 'function'\n}\n", "/**\n * @packageDocumentation\n *\n * A simple error class and options interface that seems to get copied from\n * project to project.\n *\n * @example Using `AbortError`\n *\n * ```JavaScript\n * import { AbortError } from 'abort-error'\n *\n * // a promise that will be settled later\n * const deferred = Promise.withResolvers()\n *\n * const signal = AbortSignal.timeout(1000)\n * signal.addEventListener('abort', () => {\n *   deferred.reject(new AbortError())\n * })\n * ```\n *\n * @example Using `AbortOptions`\n *\n * ```TypeScript\n * import type { AbortOptions } from 'abort-error'\n *\n * async function myFunction (options?: AbortOptions) {\n *   return fetch('https://example.com', {\n *     signal: options?.signal\n *   })\n * }\n * ```\n */\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\nexport class AbortError extends Error {\n  static name = 'AbortError'\n  name = 'AbortError'\n\n  constructor (message: string = 'The operation was aborted', ...rest: any[]) {\n    super(message, ...rest)\n  }\n}\n"],
  "mappings": ";6bAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,eAAAE,ICqCM,IAAOC,EAAP,cAA0B,KAAK,CACnC,OAAO,KAAO,aACd,KAAO,aAEP,YAAaC,EAAkB,+BAAgCC,EAAW,CACxE,MAAMD,EAAS,GAAGC,CAAI,CACxB,GD4GF,eAAsBC,EAAeC,EAAqCC,EAAmBC,EAAsBC,EAA0B,CAE3I,IAAMC,EAAQ,IAAIC,EAAWF,GAAM,YAAY,EAE3CA,GAAM,WAAa,OAErBC,EAAM,KAAOD,EAAK,WAGpB,IAAMG,EAAaH,GAAM,YAAc,QAEvC,OAAID,GAAQ,UAAY,GACf,QAAQ,OAAOE,CAAK,EAGtB,IAAI,QAAQ,CAACG,EAASC,IAAU,CACrC,SAASC,GAAe,CACtBC,EAAeR,EAAQ,QAASS,CAAa,EAC7CD,EAAeV,EAASC,EAAWW,CAAa,EAChDF,EAAeV,EAASM,EAAYO,CAAkB,CACxD,CAEA,IAAMD,EAAiBE,GAAkB,CACvC,GAAI,CACF,GAAIX,GAAM,SAASW,CAAG,IAAM,GAC1B,MAEJ,OAASC,EAAU,CACjBN,EAAe,EACfD,EAAOO,CAAG,EACV,MACF,CAEAN,EAAe,EACfF,EAAQO,CAAG,CACb,EAEMD,EAAsBC,GAAkB,CAG5C,GAFAL,EAAe,EAEXK,aAAe,MAAO,CACxBN,EAAOM,CAAG,EACV,MACF,CAEAN,EAAOM,EAAI,QAAUX,GAAM,OAAS,IAAI,MAAM,QAAQA,GAAM,UAAU,wHAAwH,CAAC,CACjM,EAEMQ,EAAgB,IAAW,CAC/BF,EAAe,EACfD,EAAOJ,CAAK,CACd,EAEAY,EAAYd,EAAQ,QAASS,CAAa,EAC1CK,EAAYhB,EAASC,EAAWW,CAAa,EAC7CI,EAAYhB,EAASM,EAAYO,CAAkB,CACrD,CAAC,CACH,CAEA,SAASG,EAAahB,EAAiDiB,EAAeC,EAAa,CAC7FlB,GAAW,OAIXmB,EAAcnB,CAAO,EACvBA,EAAQ,iBAAiBiB,EAAOC,CAAQ,EAExClB,EAAQ,YAAYiB,EAAOC,CAAQ,EAEvC,CAEA,SAASR,EAAgBV,EAAiDiB,EAAeC,EAAa,CAChGlB,GAAW,OAIXmB,EAAcnB,CAAO,EACvBA,EAAQ,oBAAoBiB,EAAOC,CAAQ,EAE3ClB,EAAQ,eAAeiB,EAAOC,CAAQ,EAE1C,CAEA,SAASC,EAAenB,EAAY,CAClC,OAAO,OAAOA,EAAQ,kBAAqB,YAAc,OAAOA,EAAQ,qBAAwB,UAClG",
  "names": ["index_exports", "__export", "raceEvent", "AbortError", "message", "rest", "raceEvent", "emitter", "eventName", "signal", "opts", "error", "AbortError", "errorEvent", "resolve", "reject", "removeListeners", "removeListener", "abortListener", "eventListener", "errorEventListener", "evt", "err", "addListener", "event", "listener", "isEventTarget"]
}
