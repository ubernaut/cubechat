/**
 * @packageDocumentation
 *
 * This module makes it easy to send and receive bytes over streams.
 *
 * @example
 *
 * ```typescript
 * import { byteStream } from 'it-byte-stream'
 *
 * const stream = byteStream(duplex)
 *
 * // read the next chunk
 * const bytes = await stream.read()
 *
 * // read the next five bytes
 * const fiveBytes = await stream.read(5)
 *
 * // write bytes into the stream
 * await stream.write(Uint8Array.from([0, 1, 2, 3, 4]))
 * ```
 */
import { Uint8ArrayList } from 'uint8arraylist';
import type { AbortOptions } from 'abort-error';
import type { Duplex } from 'it-stream-types';
export interface ReadOptions extends AbortOptions {
    bytes: number;
}
export interface ByteStream<Stream = unknown> {
    /**
     * Read bytes from the stream.
     *
     * If a required number of bytes is passed as an option, this will wait for
     * the underlying stream to supply that number of bytes, throwing an
     * `UnexpectedEOFError` if the stream closes before this happens.
     *
     * If no required number of bytes is passed, this will return `null` if the
     * underlying stream closes before supplying any bytes.
     */
    read(options: ReadOptions): Promise<Uint8ArrayList>;
    read(options?: AbortOptions): Promise<Uint8ArrayList | null>;
    /**
     * Write the passed bytes to the stream
     */
    write(input: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<void>;
    /**
     * Returns the underlying stream
     */
    unwrap(): Stream;
}
export interface ByteStreamOpts {
    /**
     * After the stream is unwrapped, any bytes that have been read from the
     * incoming stream will be yielded in-order as `Uint8Array`(s).
     *
     * To yield a single `Uint8ArrayList` with all unread bytes instead, pass
     * `false` here.
     */
    yieldBytes?: boolean;
}
export declare function byteStream<Stream extends Duplex<any, any, any>>(duplex: Stream, opts?: ByteStreamOpts): ByteStream<Stream>;
//# sourceMappingURL=index.d.ts.map