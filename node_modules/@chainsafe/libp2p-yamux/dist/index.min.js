(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.ChainsafeLibp2PYamux = factory()}(typeof self !== 'undefined' ? self : this, function () {
"use strict";var ChainsafeLibp2PYamux=(()=>{var le=Object.defineProperty;var Oe=Object.getOwnPropertyDescriptor;var Fe=Object.getOwnPropertyNames;var ke=Object.prototype.hasOwnProperty;var _e=(s,e)=>{for(var t in e)le(s,t,{get:e[t],enumerable:!0})},ze=(s,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of Fe(e))!ke.call(s,n)&&n!==t&&le(s,n,{get:()=>e[n],enumerable:!(r=Oe(e,n))||r.enumerable});return s};var Ve=s=>ze(le({},"__esModule",{value:!0}),s);var Qe={};_e(Qe,{GoAwayCode:()=>g,yamux:()=>He});var y=class extends Error{static name="InvalidParametersError";constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}};var v=class extends Error{static name="MuxerClosedError";constructor(e="The muxer is closed"){super(e),this.name="MuxerClosedError"}},q=class extends Error{static name="StreamResetError";constructor(e="The stream has been reset"){super(e),this.name="StreamResetError"}};var A=class extends Error{static name="StreamStateError";constructor(e="The stream is in an invalid state"){super(e),this.name="StreamStateError"}},O=class extends Error{static name="StreamBufferError";constructor(e="The stream buffer was full"){super(e),this.name="StreamBufferError"}};var G=class extends Error{static name="TooManyOutboundProtocolStreamsError";constructor(e="Too many outbound protocol streams"){super(e),this.name="TooManyOutboundProtocolStreamsError"}};var Y=class extends Event{data;constructor(e,t){super("message",t),this.data=e}},P=class extends Event{error;local;constructor(e,t,r){super("close",r),this.error=t,this.local=e}},$=class extends P{constructor(e,t){super(!0,e,t)}},j=class extends P{constructor(e,t){super(!1,e,t)}};var W=class extends EventTarget{#e=new Map;constructor(){super()}listenerCount(e){let t=this.#e.get(e);return t==null?0:t.length}addEventListener(e,t,r){super.addEventListener(e,t,r);let n=this.#e.get(e);n==null&&(n=[],this.#e.set(e,n)),n.push({callback:t,once:(r!==!0&&r!==!1&&r?.once)??!1})}removeEventListener(e,t,r){super.removeEventListener(e.toString(),t??null,r);let n=this.#e.get(e);n!=null&&(n=n.filter(({callback:i})=>i!==t),this.#e.set(e,n))}dispatchEvent(e){let t=super.dispatchEvent(e),r=this.#e.get(e.type);return r==null||(r=r.filter(({once:n})=>!n),this.#e.set(e.type,r)),t}safeDispatchEvent(e,t={}){return this.dispatchEvent(new CustomEvent(e,t))}};var be=Symbol.for("@libp2p/service-capabilities"),rt=Symbol.for("@libp2p/service-dependencies");function ye(s,e){if(s===e)return!0;if(s.byteLength!==e.byteLength)return!1;for(let t=0;t<s.byteLength;t++)if(s[t]!==e[t])return!1;return!0}function L(s=0){return new Uint8Array(s)}function F(s=0){return new Uint8Array(s)}function he(s,e){e==null&&(e=s.reduce((n,i)=>n+i.length,0));let t=F(e),r=0;for(let n of s)t.set(n,r),r+=n.length;return t}var Ee=Symbol.for("@achingbrain/uint8arraylist");function xe(s,e){if(e==null||e<0)throw new RangeError("index is out of bounds");let t=0;for(let r of s){let n=t+r.byteLength;if(e<n)return{buf:r,index:e-t};t=n}throw new RangeError("index is out of bounds")}function K(s){return!!s?.[Ee]}var E=class s{bufs;length;[Ee]=!0;constructor(...e){this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(let r of e)if(r instanceof Uint8Array)t+=r.byteLength,this.bufs.push(r);else if(K(r))t+=r.byteLength,this.bufs.push(...r.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(let r of e.reverse())if(r instanceof Uint8Array)t+=r.byteLength,this.bufs.unshift(r);else if(K(r))t+=r.byteLength,this.bufs.unshift(...r.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}get(e){let t=xe(this.bufs,e);return t.buf[t.index]}set(e,t){let r=xe(this.bufs,e);r.buf[r.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let r=0;r<e.length;r++)this.set(t+r,e[r]);else if(K(e))for(let r=0;r<e.length;r++)this.set(t+r,e.get(r));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(e>=this.bufs[0].byteLength)e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}}}slice(e,t){let{bufs:r,length:n}=this._subList(e,t);return he(r,n)}subarray(e,t){let{bufs:r,length:n}=this._subList(e,t);return r.length===1?r[0]:he(r,n)}sublist(e,t){let{bufs:r,length:n}=this._subList(e,t),i=new s;return i.length=n,i.bufs=[...r],i}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(e===0&&t===this.length)return{bufs:this.bufs,length:this.length};let r=[],n=0;for(let i=0;i<this.bufs.length;i++){let a=this.bufs[i],o=n,d=o+a.byteLength;if(n=d,e>=d)continue;let m=e>=o&&e<d,p=t>o&&t<=d;if(m&&p){if(e===o&&t===d){r.push(a);break}let l=e-o;r.push(a.subarray(l,l+(t-e)));break}if(m){if(e===0){r.push(a);continue}r.push(a.subarray(e-o));continue}if(p){if(t===d){r.push(a);break}r.push(a.subarray(0,t-o));break}r.push(a)}return{bufs:r,length:t-e}}indexOf(e,t=0){if(!K(e)&&!(e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');let r=e instanceof Uint8Array?e:e.subarray();if(t=Number(t??0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),e.length===0)return t>this.length?this.length:t;let n=r.byteLength;if(n===0)throw new TypeError("search must be at least 1 byte long");let i=256,a=new Int32Array(i);for(let l=0;l<i;l++)a[l]=-1;for(let l=0;l<n;l++)a[r[l]]=l;let o=a,d=this.byteLength-r.byteLength,m=r.byteLength-1,p;for(let l=t;l<=d;l+=p){p=0;for(let w=m;w>=0;w--){let h=this.get(l+w);if(r[w]!==h){p=Math.max(1,w-o[h]);break}}if(p===0)return l}return-1}getInt8(e){let t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,t){let r=F(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setInt8(0,t),this.write(r,e)}getInt16(e,t){let r=this.subarray(e,e+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt16(0,t)}setInt16(e,t,r){let n=L(2);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt16(0,t,r),this.write(n,e)}getInt32(e,t){let r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt32(0,t)}setInt32(e,t,r){let n=L(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt32(0,t,r),this.write(n,e)}getBigInt64(e,t){let r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigInt64(0,t)}setBigInt64(e,t,r){let n=L(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setBigInt64(0,t,r),this.write(n,e)}getUint8(e){let t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,t){let r=F(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setUint8(0,t),this.write(r,e)}getUint16(e,t){let r=this.subarray(e,e+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint16(0,t)}setUint16(e,t,r){let n=L(2);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint16(0,t,r),this.write(n,e)}getUint32(e,t){let r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint32(0,t)}setUint32(e,t,r){let n=L(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint32(0,t,r),this.write(n,e)}getBigUint64(e,t){let r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigUint64(0,t)}setBigUint64(e,t,r){let n=L(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setBigUint64(0,t,r),this.write(n,e)}getFloat32(e,t){let r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat32(0,t)}setFloat32(e,t,r){let n=L(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setFloat32(0,t,r),this.write(n,e)}getFloat64(e,t){let r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat64(0,t)}setFloat64(e,t,r){let n=L(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setFloat64(0,t,r),this.write(n,e)}equals(e){if(e==null||!(e instanceof s)||e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!ye(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){let r=new s;return r.bufs=e,t==null&&(t=e.reduce((n,i)=>n+i.byteLength,0)),r.length=t,r}};function H(){let s={};return s.promise=new Promise((e,t)=>{s.resolve=e,s.reject=t}),s}var Q=class{buffer;mask;top;btm;next;constructor(e){if(!(e>0)||(e-1&e)!==0)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){let e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}},C=class{size;hwm;head;tail;constructor(e={}){this.hwm=e.splitLimit??16,this.head=new Q(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return e?.byteLength!=null?e.byteLength:1}push(e){if(e?.value!=null&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){let t=this.head;this.head=t.next=new Q(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next!=null){let t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return e?.value!=null&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}};var ce=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}};function Se(s={}){return qe(t=>{let r=t.shift();if(r==null)return{done:!0};if(r.error!=null)throw r.error;return{done:r.done===!0,value:r.value}},s)}function qe(s,e){e=e??{};let t=e.onEnd,r=new C,n,i,a,o=H(),d=async()=>{try{return r.isEmpty()?a?{done:!0}:await new Promise((c,T)=>{i=V=>{i=null,r.push(V);try{c(s(r))}catch(R){T(R)}return n}}):s(r)}finally{r.isEmpty()&&queueMicrotask(()=>{o.resolve(),o=H()})}},m=c=>i!=null?i(c):(r.push(c),n),p=c=>(r=new C,i!=null?i({error:c}):(r.push({error:c}),n)),l=c=>{if(a)return n;if(e?.objectMode!==!0&&c?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return m({done:!1,value:c})},w=c=>a?n:(a=!0,c!=null?p(c):m({done:!0})),h=()=>(r=new C,w(),{done:!0}),z=c=>(w(c),{done:!0});if(n={[Symbol.asyncIterator](){return this},next:d,return:h,throw:z,push:l,end:w,get readableLength(){return r.size},onEmpty:async c=>{let T=c?.signal;if(T?.throwIfAborted(),r.isEmpty())return;let V,R;T!=null&&(V=new Promise((Xe,Ue)=>{R=()=>{Ue(new ce)},T.addEventListener("abort",R)}));try{await Promise.race([o.promise,V])}finally{R!=null&&T!=null&&T?.removeEventListener("abort",R)}}},t==null)return n;let D=n;return n={[Symbol.asyncIterator](){return this},next(){return D.next()},throw(c){return D.throw(c),t!=null&&(t(c),t=void 0),{done:!0}},return(){return D.return(),t!=null&&(t(),t=void 0),{done:!0}},push:l,end(c){return D.end(c),t!=null&&(t(c),t=void 0),n},get readableLength(){return D.readableLength},onEmpty:c=>D.onEmpty(c)},n}var de=class extends Error{constructor(e){super(e),this.name="TimeoutError"}},fe=class extends Error{constructor(e){super(),this.name="AbortError",this.message=e}},ve=s=>globalThis.DOMException===void 0?new fe(s):new DOMException(s),Le=s=>{let e=s.reason===void 0?ve("This operation was aborted."):s.reason;return e instanceof Error?e:ve(e)};function me(s,e){let{milliseconds:t,fallback:r,message:n,customTimers:i={setTimeout,clearTimeout}}=e,a,o,m=new Promise((p,l)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(e.signal){let{signal:h}=e;h.aborted&&l(Le(h)),o=()=>{l(Le(h))},h.addEventListener("abort",o,{once:!0})}if(t===Number.POSITIVE_INFINITY){s.then(p,l);return}let w=new de;a=i.setTimeout.call(void 0,()=>{if(r){try{p(r())}catch(h){l(h)}return}typeof s.cancel=="function"&&s.cancel(),n===!1?p():n instanceof Error?l(n):(w.message=n??`Promise timed out after ${t} milliseconds`,l(w))},t),(async()=>{try{p(await s)}catch(h){l(h)}})()}).finally(()=>{m.clear(),o&&e.signal&&e.signal.removeEventListener("abort",o)});return m.clear=()=>{i.clearTimeout.call(void 0,a),a=void 0},m}var Ge=s=>{let e=s.addEventListener||s.on||s.addListener,t=s.removeEventListener||s.off||s.removeListener;if(!e||!t)throw new TypeError("Emitter is not compatible");return{addListener:e.bind(s),removeListener:t.bind(s)}};function Ye(s,e,t){let r,n=new Promise((i,a)=>{if(t={rejectionEvents:["error"],multiArgs:!1,rejectionMultiArgs:!1,resolveImmediately:!1,...t},!(t.count>=0&&(t.count===Number.POSITIVE_INFINITY||Number.isInteger(t.count))))throw new TypeError("The `count` option should be at least 0 or more");t.signal?.throwIfAborted();let o=[e].flat(),d=[],{addListener:m,removeListener:p}=Ge(s),l=async(...h)=>{let z=t.multiArgs?h:h[0];if(t.filter)try{if(!await t.filter(z))return}catch(D){r(),a(D);return}d.push(z),t.count===d.length&&(r(),i(d))},w=(...h)=>{r(),a(t.rejectionMultiArgs?h:h[0])};r=()=>{for(let h of o)p(h,l);for(let h of t.rejectionEvents)o.includes(h)||p(h,w)};for(let h of o)m(h,l);for(let h of t.rejectionEvents)o.includes(h)||m(h,w);t.signal&&t.signal.addEventListener("abort",()=>{w(t.signal.reason)},{once:!0}),t.resolveImmediately&&i(d)});if(n.cancel=r,typeof t.timeout=="number"){let i=me(n,{milliseconds:t.timeout});return i.cancel=()=>{r(),i.clear()},i}return n}function pe(s,e,t){typeof t=="function"&&(t={filter:t}),t={...t,count:1,resolveImmediately:!1};let r=Ye(s,e,t),n=r.then(i=>i[0]);return n.cancel=r.cancel,n}function Ie(s,e){let t,r=function(){let n=function(){t=void 0,s()};clearTimeout(t),t=setTimeout(n,e)};return r.start=()=>{},r.stop=()=>{clearTimeout(t)},r}var X=class extends Error{static name="MaxEarlyStreamsError";name="MaxEarlyStreamsError"},J=class extends Error{static name="StreamClosedError";name="StreamClosedError"};function $e(s){return s.reason}async function B(s,e,t){if(e==null)return s;let r=t?.translateError??$e;if(e.aborted)return s.catch(()=>{}),Promise.reject(r(e));let n;try{return await Promise.race([s,new Promise((i,a)=>{n=()=>{a(r(e))},e.addEventListener("abort",n)})])}finally{n!=null&&e.removeEventListener("abort",n)}}var je=Math.pow(2,20)*4,Z=class extends W{status;timeline;inactivityTimeout;maxReadBufferLength;maxWriteBufferLength;log;direction;maxMessageSize;readStatus;writeStatus;remoteReadStatus;remoteWriteStatus;writableNeedsDrain;readBuffer;writeBuffer;sendingData;onDrainPromise;constructor(e){super(),this.status="open",this.log=e.log,this.direction=e.direction??"outbound",this.inactivityTimeout=e.inactivityTimeout??12e4,this.maxReadBufferLength=e.maxReadBufferLength??je,this.maxWriteBufferLength=e.maxWriteBufferLength,this.maxMessageSize=e.maxMessageSize,this.readBuffer=new E,this.writeBuffer=new E,this.readStatus="readable",this.remoteReadStatus="readable",this.writeStatus="writable",this.remoteWriteStatus="writable",this.sendingData=!1,this.writableNeedsDrain=!1,this.timeline={open:Date.now()},this.processSendQueue=this.processSendQueue.bind(this);let t=()=>{this.writableNeedsDrain&&(this.log.trace("drain event received, continue sending data"),this.writableNeedsDrain=!1,this.processSendQueue()),this.onDrainPromise?.resolve()};this.addEventListener("drain",t);let r=n=>{this.onDrainPromise?.reject(n.error??new J)};this.addEventListener("close",r)}get readBufferLength(){return this.readBuffer.byteLength}get writeBufferLength(){return this.writeBuffer.byteLength}async onDrain(e){return this.writableNeedsDrain!==!0?Promise.resolve():(this.onDrainPromise==null&&(this.onDrainPromise=Promise.withResolvers()),B(this.onDrainPromise.promise,e?.signal))}async*[Symbol.asyncIterator](){if(this.readStatus!=="readable"&&this.readStatus!=="paused")return;let e=Se(),t=i=>{e.push(i.data)};this.addEventListener("message",t);let r=i=>{e.end(i.error)};this.addEventListener("close",r);let n=()=>{e.end()};this.addEventListener("remoteCloseWrite",n);try{yield*e}finally{this.removeEventListener("message",t),this.removeEventListener("close",r),this.removeEventListener("remoteCloseWrite",n)}}isReadable(){return this.status==="open"}send(e){if(this.writeStatus==="closed"||this.writeStatus==="closing")throw new A(`Cannot write to a stream that is ${this.writeStatus}`);return this.log.trace("append %d bytes to write buffer",e.byteLength),this.writeBuffer.append(e),this.processSendQueue()}abort(e){if(!(this.status==="aborted"||this.status==="reset"||this.status==="closed")){this.log.error("abort with error - %e",e),this.status="aborted",this.readBuffer.byteLength>0&&this.readBuffer.consume(this.readBuffer.byteLength),this.writeBuffer.byteLength>0&&(this.writeBuffer.consume(this.writeBuffer.byteLength),this.safeDispatchEvent("idle")),this.writeStatus="closed",this.remoteWriteStatus="closed",this.readStatus="closed",this.remoteReadStatus="closed",this.timeline.close=Date.now();try{this.sendReset(e)}catch(t){this.log("failed to send reset to remote - %e",t)}this.dispatchEvent(new $(e))}}pause(){if(this.readStatus==="closed"||this.readStatus==="closing")throw new A("Cannot pause a stream that is closing/closed");this.readStatus!=="paused"&&(this.readStatus="paused",this.sendPause())}resume(){if(this.readStatus==="closed"||this.readStatus==="closing")throw new A("Cannot resume a stream that is closing/closed");this.readStatus!=="readable"&&(this.readStatus="readable",this.dispatchReadBuffer(),this.sendResume())}push(e){if(this.readStatus==="closed"||this.readStatus==="closing")throw new A(`Cannot push data onto a stream that is ${this.readStatus}`);if(e.byteLength!==0){if(this.readBuffer.append(e),this.readStatus==="paused"||this.listenerCount("message")===0){this.checkReadBufferLength();return}setTimeout(()=>{this.dispatchReadBuffer()},0)}}unshift(e){if(this.readStatus==="closed"||this.readStatus==="closing")throw new A(`Cannot push data onto a stream that is ${this.readStatus}`);if(e.byteLength!==0){if(this.readBuffer.prepend(e),this.readStatus==="paused"||this.listenerCount("message")===0){this.checkReadBufferLength();return}setTimeout(()=>{this.dispatchReadBuffer()},0)}}onData(e){if(e.byteLength!==0){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("ignoring data - read status %s",this.readStatus);return}this.readBuffer.append(e),this.dispatchReadBuffer()}}addEventListener(...e){super.addEventListener.apply(this,e),e[0]==="message"&&this.readBuffer.byteLength>0&&queueMicrotask(()=>{this.dispatchReadBuffer()})}onRemoteReset(){this.log("remote reset"),this.status="reset",this.writeStatus="closed",this.remoteWriteStatus="closed",this.remoteReadStatus="closed",this.timeline.close=Date.now(),this.readBuffer.byteLength===0&&(this.readStatus="closed");let e=new q;this.dispatchEvent(new j(e))}onTransportClosed(e){this.log("transport closed"),this.readStatus==="readable"&&this.readBuffer.byteLength===0&&(this.log("close readable end after transport closed and read buffer is empty"),this.readStatus="closed"),this.remoteReadStatus!=="closed"&&(this.remoteReadStatus="closed"),this.remoteWriteStatus!=="closed"&&(this.remoteWriteStatus="closed"),this.writeStatus!=="closed"&&(this.writeStatus="closed"),e!=null?this.abort(e):(this.status==="open"||this.status==="closing")&&(this.timeline.close=Date.now(),this.status="closed",this.writeStatus="closed",this.remoteWriteStatus="closed",this.remoteReadStatus="closed",this.dispatchEvent(new P))}onRemoteCloseWrite(){this.remoteWriteStatus!=="closed"&&(this.log.trace("on remote close write"),this.remoteWriteStatus="closed",this.safeDispatchEvent("remoteCloseWrite"),this.writeStatus==="closed"&&this.onTransportClosed())}onRemoteCloseRead(){this.log.trace("on remote close read"),this.remoteReadStatus="closed",this.writeBuffer.byteLength>0&&(this.writeBuffer.consume(this.writeBuffer.byteLength),this.safeDispatchEvent("idle"))}processSendQueue(){if(this.writableNeedsDrain)return this.log.trace("not processing send queue as drain is required"),this.checkWriteBufferLength(),!1;if(this.writeBuffer.byteLength===0)return this.log.trace("not processing send queue as no bytes to send"),!0;if(this.sendingData)return this.log.trace("not processing send queue as already sending data"),!0;this.sendingData=!0,this.log.trace("processing send queue with %d queued bytes",this.writeBuffer.byteLength);try{let e=!0,t=this.writeBuffer.byteLength,r=0;for(;this.writeBuffer.byteLength>0;){let n=Math.min(this.maxMessageSize??this.writeBuffer.byteLength,this.writeBuffer.byteLength);if(n===0){e=!1;break}let i=this.writeBuffer.sublist(0,n),a=new E(i);this.writeBuffer.consume(i.byteLength);let o=this.sendData(i);if(e=o.canSendMore,r+=o.sentBytes,o.sentBytes!==a.byteLength&&(a.consume(o.sentBytes),this.writeBuffer.prepend(a)),!e)break}return e||(this.log.trace("sent %d/%d bytes, pausing sending because underlying stream is full, %d bytes left in the write buffer",r,t,this.writeBuffer.byteLength),this.writableNeedsDrain=!0,this.checkWriteBufferLength()),this.writeBuffer.byteLength===0&&this.safeDispatchEvent("idle"),e}finally{this.sendingData=!1}}dispatchReadBuffer(){try{if(this.listenerCount("message")===0){this.log.trace("not dispatching pause buffer as there are no listeners for the message event");return}if(this.readBuffer.byteLength===0){this.log.trace("not dispatching pause buffer as there is no data to dispatch");return}if(this.readStatus==="paused"){this.log.trace("not dispatching pause buffer we are paused");return}if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("dropping %d bytes because the readable end is %s",this.readBuffer.byteLength,this.readStatus),this.readBuffer.consume(this.readBuffer.byteLength);return}let e=this.readBuffer.sublist();this.readBuffer.consume(e.byteLength),this.dispatchEvent(new Y(e))}finally{this.readBuffer.byteLength===0&&this.remoteWriteStatus==="closed"&&(this.log("close readable end after dispatching read buffer and remote writable end is closed"),this.readStatus="closed"),this.checkReadBufferLength()}}checkReadBufferLength(){this.readBuffer.byteLength>this.maxReadBufferLength&&this.abort(new O(`Read buffer length of ${this.readBuffer.byteLength} exceeded limit of ${this.maxReadBufferLength}, read status is ${this.readStatus}`))}checkWriteBufferLength(){this.maxWriteBufferLength!=null&&this.writeBuffer.byteLength>this.maxWriteBufferLength&&this.abort(new O(`Write buffer length of ${this.writeBuffer.byteLength} exceeded limit of ${this.maxWriteBufferLength}, write status is ${this.writeStatus}`))}onMuxerNeedsDrain(){this.writableNeedsDrain=!0}onMuxerDrain(){this.safeDispatchEvent("drain")}};function De(s){return s==null?!1:typeof s.then=="function"&&typeof s.catch=="function"&&typeof s.finally=="function"}var ee=class extends W{streams;protocol;status;log;maConn;streamOptions;earlyStreams;maxEarlyStreams;metrics;constructor(e,t){super(),this.maConn=e,this.protocol=t.protocol,this.streams=[],this.earlyStreams=[],this.status="open",this.log=e.log.newScope(t.name),this.streamOptions=t.streamOptions,this.maxEarlyStreams=t.maxEarlyStreams??10,this.metrics=t.metrics;let r=a=>{try{this.onData(a.data)}catch(o){this.abort(o),this.maConn.abort(o)}};this.maConn.addEventListener("message",r);let n=()=>{this.log("underlying stream drained, signal %d streams to continue writing",this.streams.length),this.streams.forEach(a=>{a.onMuxerDrain()})};this.maConn.addEventListener("drain",n);let i=()=>{this.log("underlying stream closed with status %s and %d streams",this.status,this.streams.length),this.onTransportClosed()};this.maConn.addEventListener("close",i)}send(e){let t=this.maConn.send(e);return t===!1&&(this.log("underlying stream saturated, signal %d streams to pause writing",this.streams.length),this.streams.forEach(r=>{r.onMuxerNeedsDrain()})),t}async close(e){this.status==="closed"||this.status==="closing"||(this.status="closing",await B(Promise.all([...this.streams].map(async t=>{await t.close(e)})),e?.signal),this.status="closed")}abort(e){this.status!=="closed"&&(this.status="closing",[...this.streams].forEach(t=>{t.abort(e)}),this.status="closed")}onTransportClosed(e){this.status="closing";try{[...this.streams].forEach(t=>{t.onTransportClosed(e)})}catch(t){this.abort(t)}this.status="closed"}async createStream(e){if(this.status!=="open")throw new v;let t=this.onCreateStream({...this.streamOptions,...e});return De(t)&&(t=await t),this.streams.push(t),this.cleanUpStream(t),t}onRemoteStream(e){if(this.streams.push(e),this.cleanUpStream(e),this.listenerCount("stream")===0){this.earlyStreams.push(e),this.earlyStreams.length>this.maxEarlyStreams&&this.abort(new X(`Too many early streams were opened - ${this.earlyStreams.length}/${this.maxEarlyStreams}`));return}this.safeDispatchEvent("stream",{detail:e})}cleanUpStream(e){let t=r=>{let n=this.streams.findIndex(i=>i===e);n!==-1&&this.streams.splice(n,1),r.error!=null?r.local?this.metrics?.increment({[`${e.direction}_stream_reset`]:!0}):this.metrics?.increment({[`${e.direction}_stream_abort`]:!0}):this.metrics?.increment({[`${e.direction}_stream_end`]:!0})};e.addEventListener("close",t),this.metrics?.increment({[`${e.direction}_stream`]:!0})}addEventListener(...e){super.addEventListener.apply(this,e),e[0]==="stream"&&this.earlyStreams.length>0&&queueMicrotask(()=>{this.earlyStreams.forEach(t=>{this.safeDispatchEvent("stream",{detail:t})}),this.earlyStreams=[]})}};var te=class extends Z{id;protocol;constructor(e){super(e),this.id=e.id,this.protocol=e.protocol??""}async close(e){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.writeStatus="closing",(this.sendingData||this.writeBuffer.byteLength>0)&&(this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await pe(this,"idle",{...e,rejectionEvents:["close"]})),this.writableNeedsDrain&&(this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes, sending %s",this.writeBuffer.byteLength,this.sendingData),await pe(this,"drain",{...e,rejectionEvents:["close"]}),this.log("write queue drained, closing writable end of stream, %d unsent bytes, sending %s",this.writeBuffer.byteLength,this.sendingData)),await this.sendCloseWrite(e),this.writeStatus="closed",this.log("closed writable end gracefully"),this.remoteWriteStatus==="closed"&&this.onTransportClosed())}async closeRead(e){this.readStatus==="closing"||this.readStatus==="closed"||(this.readBuffer.byteLength>0&&this.readBuffer.consume(this.readBuffer.byteLength),this.readStatus="closing",await this.sendCloseRead(e),this.readStatus="closed",this.log("closed readable end gracefully"))}};function Ae(s){let e=new globalThis.AbortController;function t(){e.abort();for(let i of s)i?.removeEventListener!=null&&i.removeEventListener("abort",t)}for(let i of s){if(i?.aborted===!0){t();break}i?.addEventListener!=null&&i.addEventListener("abort",t)}function r(){for(let i of s)i?.removeEventListener!=null&&i.removeEventListener("abort",t)}let n=e.signal;return n.clear=r,n}function Te(s,e,t){let r,n,i=!1;function a(){let m={signal:n.signal};if(t?.timeout!=null){let p=Ae([n.signal,AbortSignal.timeout(t.timeout)]);m.signal=p}i=!0,Promise.resolve().then(async()=>{await s(m)}).catch(()=>{}).finally(()=>{i=!1,!n.signal.aborted&&(r=setTimeout(a,e))})}let o=Ie(a,t?.debounce??100),d=!1;return{setInterval:m=>{e!==m&&(e=m,r!=null&&(clearTimeout(r),r=setTimeout(a,e)))},setTimeout:m=>{t??={},t.timeout=m},run:()=>{i||(clearTimeout(r),o())},start:()=>{d||(d=!0,n=new AbortController,n.signal,t?.runImmediately===!0?queueMicrotask(()=>{a()}):r=setTimeout(a,e))},stop:()=>{clearTimeout(r),n?.abort(),d=!1}}}var f;(function(s){s[s.Data=0]="Data",s[s.WindowUpdate=1]="WindowUpdate",s[s.Ping=2]="Ping",s[s.GoAway=3]="GoAway"})(f||(f={}));var u;(function(s){s[s.SYN=1]="SYN",s[s.ACK=2]="ACK",s[s.FIN=4]="FIN",s[s.RST=8]="RST"})(u||(u={}));var pr=Object.values(u).filter(s=>typeof s!="string"),Be=0,g;(function(s){s[s.NormalTermination=0]="NormalTermination",s[s.ProtocolError=1]="ProtocolError",s[s.InternalError=2]="InternalError"})(g||(g={}));var S=12;var I=class extends Error{static name="ProtocolError";reason;constructor(e,t){super(e),this.name="ProtocolError",this.reason=t}};function Re(s){return s?.reason!==null}var x=class extends I{static name="InvalidFrameError";constructor(e="The frame was invalid"){super(e,g.ProtocolError),this.name="InvalidFrameError"}},N=class extends I{static name="UnRequestedPingError";constructor(e="Un-requested ping error"){super(e,g.ProtocolError),this.name="UnRequestedPingError"}},M=class extends I{static name="NotMatchingPingError";constructor(e="Not matching ping error"){super(e,g.ProtocolError),this.name="NotMatchingPingError"}};var re=class extends I{static name="StreamAlreadyExistsError";constructor(e="Stream already exists"){super(e,g.ProtocolError),this.name="StreamAlreadyExistsError"}},se=class extends I{static name="DecodeInvalidVersionError";constructor(e="Decode invalid version"){super(e,g.ProtocolError),this.name="DecodeInvalidVersionError"}},ne=class extends I{static name="BothClientsError";constructor(e="Both clients"){super(e,g.ProtocolError),this.name="BothClientsError"}},U=class extends I{static name="ReceiveWindowExceededError";constructor(e="Receive window exceeded"){super(e,g.ProtocolError),this.name="ReceiveWindowExceededError"}};var xr=new Set([x.name,N.name,M.name,re.name,se.name,ne.name,U.name]),k=256*1024,ie=16*1024*1024;var _={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3,maxMessageSize:64*1024,maxEarlyStreams:10,streamOptions:{initialStreamWindowSize:k,maxStreamWindowSize:ie,inactivityTimeout:12e4,maxReadBufferLength:4194304,maxWriteBufferLength:1/0}};function Pe(s){if(s.keepAliveInterval!=null&&s.keepAliveInterval<=0)throw new y("keep-alive interval must be positive");if(s.maxInboundStreams!=null&&s.maxInboundStreams<0)throw new y("max inbound streams must be larger or equal 0");if(s.maxOutboundStreams!=null&&s.maxOutboundStreams<0)throw new y("max outbound streams must be larger or equal 0");if(s.maxMessageSize!=null&&s.maxMessageSize<1024)throw new y("MaxMessageSize must be greater than a kilobyte");if(s.streamOptions?.initialStreamWindowSize!=null&&s.streamOptions?.initialStreamWindowSize<k)throw new y("InitialStreamWindowSize must be larger or equal 256 kB");if(s.streamOptions?.maxStreamWindowSize!=null&&s.streamOptions?.initialStreamWindowSize!=null&&s.streamOptions?.maxStreamWindowSize<s.streamOptions?.initialStreamWindowSize)throw new y("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");if(s.streamOptions?.maxStreamWindowSize!=null&&s.streamOptions?.maxStreamWindowSize>2**32-1)throw new y("MaxStreamWindowSize must be less than equal MAX_UINT32")}function Ce(s){return s.header.type===f.Data&&s.data!==null}var We=2**24;function Ke(s){if(s[0]!==Be)throw new x("Invalid frame version");return{type:s[1],flag:(s[2]<<8)+s[3],streamID:s[4]*We+(s[5]<<16)+(s[6]<<8)+s[7],length:s[8]*We+(s[9]<<16)+(s[10]<<8)+s[11]}}var ae=class{buffer;constructor(){this.buffer=new E}*emitFrames(e){for(this.buffer.append(e);;){let t=this.readFrame();if(t===void 0)break;yield t}}readFrame(){let e=S;if(this.buffer.byteLength<S)return;let t=Ke(this.buffer.subarray(0,S));if(t.type===f.Data){if(e+=t.length,this.buffer.byteLength<e)return;let r=this.buffer.sublist(S,e);return this.buffer.consume(e),{header:t,data:r}}return this.buffer.consume(e),{header:t}}};function ge(s){let e=new Uint8Array(S);return e[1]=s.type,e[2]=s.flag>>>8,e[3]=s.flag,e[4]=s.streamID>>>24,e[5]=s.streamID>>>16,e[6]=s.streamID>>>8,e[7]=s.streamID,e[8]=s.length>>>24,e[9]=s.length>>>16,e[10]=s.length>>>8,e[11]=s.length,e}var b;(function(s){s[s.Init=0]="Init",s[s.SYNSent=1]="SYNSent",s[s.SYNReceived=2]="SYNReceived",s[s.Established=3]="Established",s[s.Finished=4]="Finished",s[s.Paused=5]="Paused"})(b||(b={}));var oe=class extends te{streamId;state;sendWindowCapacity;recvWindow;recvWindowCapacity;maxStreamWindowSize;epochStart;getRTT;sendFrame;constructor(e){let t=e.initialStreamWindowSize??k;super({...e,maxMessageSize:t-S}),this.streamId=e.streamId,this.state=e.state,this.sendWindowCapacity=t,this.recvWindow=t,this.recvWindowCapacity=this.recvWindow,this.maxStreamWindowSize=e.maxStreamWindowSize??ie,this.epochStart=Date.now(),this.getRTT=e.getRTT,this.sendFrame=e.sendFrame;let r=()=>{this.state=b.Finished};this.addEventListener("close",r)}sendData(e){let t=e.byteLength,r=0,n=!0;for(this.log?.trace("send window capacity is %d bytes",this.sendWindowCapacity);e.byteLength>0;){if(this.sendWindowCapacity===0){n=!1,this.log?.trace("sent %d/%d bytes, exhausted send window, waiting for window update",r,t);break}let i=Math.min(this.sendWindowCapacity,e.byteLength),a=this.getSendFlags(),o=e.sublist(0,i);e.consume(i);let d=this.sendFrame({type:f.Data,flag:a,streamID:this.streamId,length:i},o);if(this.sendWindowCapacity-=i,r+=i,!d){n=d,this.log.trace("sent %d/%d bytes, wait for muxer to have more send capacity",r,t);break}}return{sentBytes:r,canSendMore:n}}sendReset(){this.sendFrame({type:f.WindowUpdate,flag:u.RST,streamID:this.streamId,length:0})}async sendCloseWrite(){let e=this.getSendFlags()|u.FIN;this.sendFrame({type:f.WindowUpdate,flag:e,streamID:this.streamId,length:0})}async sendCloseRead(e){e?.signal?.throwIfAborted()}sendPause(){this.state=b.Paused}sendResume(){this.state=b.Established,this.sendWindowUpdate()}handleWindowUpdate(e){this.processFlags(e.header.flag),this.sendWindowCapacity+=e.header.length,this.maxMessageSize=this.sendWindowCapacity-S,this.maxMessageSize<0&&(this.maxMessageSize=0),this.maxMessageSize!==0&&this.writeBuffer.byteLength>0&&(this.log?.trace("window update of %d bytes allows more data to be sent, have %d bytes queued, sending data %s",e.header.length,this.writeBuffer.byteLength,this.sendingData),this.safeDispatchEvent("drain"))}handleData(e){if(!Ce(e))throw new x("Frame was not data frame");if(this.processFlags(e.header.flag),this.recvWindowCapacity<e.header.length)throw new U("Receive window exceeded");this.recvWindowCapacity-=e.header.length,this.onData(e.data),this.sendWindowUpdate()}processFlags(e){(e&u.ACK)===u.ACK&&this.state===b.SYNSent&&(this.state=b.Established),(e&u.FIN)===u.FIN&&this.onRemoteCloseWrite(),(e&u.RST)===u.RST&&this.onRemoteReset()}getSendFlags(){switch(this.state){case b.Init:return this.state=b.SYNSent,u.SYN;case b.SYNReceived:return this.state=b.Established,u.ACK;default:return 0}}sendWindowUpdate(){if(this.state===b.Paused){this.epochStart=Date.now();return}let e=this.getSendFlags(),t=Date.now(),r=this.getRTT();if(e===0&&r>-1&&t-this.epochStart<=r*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&e===0)return;let n=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=t,this.sendFrame({type:f.WindowUpdate,flag:e,streamID:this.streamId,length:n})}};function Ne(s){return{type:f[s.type],flags:[(s.flag&u.SYN)===u.SYN?"SYN":void 0,(s.flag&u.ACK)===u.ACK?"ACK":void 0,(s.flag&u.FIN)===u.FIN?"FIN":void 0,(s.flag&u.RST)===u.RST?"RST":void 0].filter(Boolean),streamID:s.streamID,length:s.length}}var Me="/yamux/1.0.0",ue=class{protocol=Me;_init;constructor(e={}){this._init=e}[Symbol.toStringTag]="@chainsafe/libp2p-yamux";[be]=["@libp2p/stream-multiplexing"];createStreamMuxer(e){return new we(e,{...this._init})}},we=class extends ee{nextStreamID;nextPingID;activePing;rtt;client;localGoAway;remoteGoAway;numInboundStreams;numOutboundStreams;decoder;keepAlive;enableKeepAlive;keepAliveInterval;maxInboundStreams;maxOutboundStreams;constructor(e,t={}){super(e,{...t,protocol:Me,name:"yamux"}),this.client=e.direction==="outbound",Pe(t),this.enableKeepAlive=t.enableKeepAlive??_.enableKeepAlive,this.keepAliveInterval=t.keepAliveInterval??_.keepAliveInterval,this.maxInboundStreams=t.maxInboundStreams??_.maxInboundStreams,this.maxOutboundStreams=t.maxOutboundStreams??_.maxOutboundStreams,this.decoder=new ae,this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log.trace("muxer created"),this.enableKeepAlive&&(this.log.trace("muxer keepalive enabled interval=%s",this.keepAliveInterval),this.keepAlive=Te(async r=>{try{await this.ping(r)}catch(n){this.log.error("ping error: %s",n)}},this.keepAliveInterval,{runImmediately:!0}),this.keepAlive.start())}onData(e){for(let t of this.decoder.emitFrames(e))this.handleFrame(t)}onCreateStream(){if(this.remoteGoAway!==void 0)throw new v("Muxer closed remotely");if(this.localGoAway!==void 0)throw new v("Muxer closed locally");let e=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.maxOutboundStreams)throw new G("max outbound streams exceeded");this.log.trace("new outgoing stream id=%s",e);let t=this._newStream(e,b.Init,"outbound");return this.numOutboundStreams++,queueMicrotask(()=>{t.sendWindowUpdate()}),t}async ping(e){if(this.remoteGoAway!==void 0)throw new v("Muxer closed remotely");if(this.localGoAway!==void 0)throw new v("Muxer closed locally");if(this.activePing!=null)return B(this.activePing.promise,e?.signal);this.activePing=Object.assign(Promise.withResolvers(),{id:this.nextPingID++,start:Date.now()}),this.sendPing(this.activePing.id);try{this.rtt=await B(this.activePing.promise,e?.signal)}finally{this.activePing=void 0}return this.rtt}getRTT(){return this.rtt}async close(e={}){if(this.status==="open")try{let t=e?.reason??g.NormalTermination;this.log.trace("muxer close reason=%s",g[t]),await super.close(e),this.sendGoAway(t)}finally{this.keepAlive?.stop()}}abort(e){if(this.status==="open")try{super.abort(e);let t=g.InternalError;Re(e)&&(t=e.reason),this.log.error("muxer abort reason=%s error=%s",t,e),this.sendGoAway(t)}finally{this.keepAlive?.stop()}}onTransportClosed(){try{super.onTransportClosed()}finally{this.keepAlive?.stop()}}_newStream(e,t,r){if(this.streams.find(i=>i.streamId===e)!=null)throw new y("Stream already exists with that id");let n=new oe({...this.streamOptions,id:`${e}`,streamId:e,state:t,direction:r,sendFrame:this.sendFrame.bind(this),log:this.log.newScope(`${r}:${e}`),getRTT:this.getRTT.bind(this)});return n.addEventListener("close",()=>{this.closeStream(e)},{once:!0}),n}closeStream(e){this.client===(e%2===0)?this.numInboundStreams--:this.numOutboundStreams--}handleFrame(e){let{streamID:t,type:r,length:n}=e.header;if(this.log.trace("received frame %o",Ne(e.header)),t===0)switch(r){case f.Ping:{this.handlePing(e.header);return}case f.GoAway:{this.handleGoAway(n);return}default:throw new x("Invalid frame type")}else switch(e.header.type){case f.Data:case f.WindowUpdate:{this.handleStreamMessage(e);return}default:throw new x("Invalid frame type")}}handlePing(e){if(e.flag===u.SYN)this.log.trace("received ping request pingId=%s",e.length),this.sendPing(e.length,u.ACK);else if(e.flag===u.ACK)this.log.trace("received ping response pingId=%s",e.length),this.handlePingResponse(e.length);else throw new x("Invalid frame flag")}handlePingResponse(e){if(this.activePing===void 0)throw new N("ping not requested");if(this.activePing.id!==e)throw new M("ping doesn't match our id");this.activePing.resolve(Date.now()-this.activePing.start)}handleGoAway(e){this.log.trace("received GoAway reason=%s",g[e]??"unknown"),this.remoteGoAway=e,e===g.NormalTermination?this.onTransportClosed():this.abort(new Error("Remote sent GoAway"))}handleStreamMessage(e){let{streamID:t,flag:r,type:n}=e.header;(r&u.SYN)===u.SYN&&this.incomingStream(t);let i=this.streams.find(a=>a.streamId===t);if(i===void 0){this.log.trace("frame for missing stream id=%s",t);return}switch(n){case f.WindowUpdate:{i.handleWindowUpdate(e);return}case f.Data:{i.handleData(e);return}default:throw new Error("unreachable")}}incomingStream(e){if(this.client!==(e%2===0))throw new y("Both endpoints are clients");if(this.streams.find(r=>r.streamId===e))return;if(this.log.trace("new incoming stream id=%s",e),this.localGoAway!==void 0){this.sendFrame({type:f.WindowUpdate,flag:u.RST,streamID:e,length:0});return}if(this.numInboundStreams>=this.maxInboundStreams){this.log("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:f.WindowUpdate,flag:u.RST,streamID:e,length:0});return}let t=this._newStream(e,b.SYNReceived,"inbound");this.numInboundStreams++,this.onRemoteStream(t)}sendFrame(e,t){let r;if(e.type===f.Data){if(t==null)throw new x("Invalid frame");r=new E(ge(e),t)}else r=ge(e);return this.log.trace("sending frame %o",Ne(e)),this.send(r)}sendPing(e,t=u.SYN){t===u.SYN?this.log.trace("sending ping request pingId=%s",e):this.log.trace("sending ping response pingId=%s",e),this.sendFrame({type:f.Ping,flag:t,streamID:0,length:e})}sendGoAway(e=g.NormalTermination){this.log("sending GoAway reason=%s",g[e]),this.localGoAway=e,this.sendFrame({type:f.GoAway,flag:0,streamID:0,length:e})}};function He(s={}){return()=>new ue(s)}return Ve(Qe);})();
return ChainsafeLibp2PYamux}));
//# sourceMappingURL=index.min.js.map
