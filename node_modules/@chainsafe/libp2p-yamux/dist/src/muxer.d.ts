import { serviceCapabilities } from '@libp2p/interface';
import { AbstractStreamMuxer } from '@libp2p/utils';
import { Uint8ArrayList } from 'uint8arraylist';
import { GoAwayCode } from './frame.js';
import { YamuxStream } from './stream.js';
import type { Config } from './config.js';
import type { AbortOptions, MessageStream, StreamMuxerFactory } from '@libp2p/interface';
export interface YamuxMuxerInit extends Partial<Config> {
}
export declare class Yamux implements StreamMuxerFactory {
    protocol: string;
    private readonly _init;
    constructor(init?: Partial<Config>);
    readonly [Symbol.toStringTag] = "@chainsafe/libp2p-yamux";
    readonly [serviceCapabilities]: string[];
    createStreamMuxer(maConn: MessageStream): YamuxMuxer;
}
export interface CloseOptions extends AbortOptions {
    reason?: GoAwayCode;
}
export interface ActivePing extends PromiseWithResolvers<number> {
    id: number;
    start: number;
}
export declare class YamuxMuxer extends AbstractStreamMuxer<YamuxStream> {
    /** The next stream id to be used when initiating a new stream */
    private nextStreamID;
    /** The next ping id to be used when pinging */
    private nextPingID;
    /** Tracking info for the currently active ping */
    private activePing?;
    /** Round trip time */
    private rtt;
    /** True if client, false if server */
    private client;
    private localGoAway?;
    private remoteGoAway?;
    /** Number of tracked inbound streams */
    private numInboundStreams;
    /** Number of tracked outbound streams */
    private numOutboundStreams;
    private decoder;
    private keepAlive?;
    private enableKeepAlive;
    private keepAliveInterval;
    private maxInboundStreams;
    private maxOutboundStreams;
    constructor(maConn: MessageStream, init?: YamuxMuxerInit);
    onData(buf: Uint8Array | Uint8ArrayList): void;
    onCreateStream(): YamuxStream;
    /**
     * Initiate a ping and wait for a response
     *
     * Note: only a single ping will be initiated at a time.
     * If a ping is already in progress, a new ping will not be initiated.
     *
     * @returns the round-trip-time in milliseconds
     */
    ping(options?: AbortOptions): Promise<number>;
    /**
     * Get the ping round trip time
     *
     * Note: Will return 0 if no successful ping has yet been completed
     *
     * @returns the round-trip-time in milliseconds
     */
    getRTT(): number;
    /**
     * Close the muxer
     */
    close(options?: CloseOptions): Promise<void>;
    abort(err: Error): void;
    onTransportClosed(): void;
    /** Create a new stream */
    private _newStream;
    /**
     * closeStream is used to close a stream once both sides have
     * issued a close.
     */
    private closeStream;
    private handleFrame;
    private handlePing;
    private handlePingResponse;
    private handleGoAway;
    private handleStreamMessage;
    private incomingStream;
    private sendFrame;
    private sendPing;
    private sendGoAway;
}
//# sourceMappingURL=muxer.d.ts.map