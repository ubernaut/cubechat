import { AbstractStream } from '@libp2p/utils';
import { Uint8ArrayList } from 'uint8arraylist';
import type { Frame } from './decode.ts';
import type { FrameHeader } from './frame.js';
import type { AbortOptions } from '@libp2p/interface';
import type { AbstractStreamInit, SendResult } from '@libp2p/utils';
export declare enum StreamState {
    Init = 0,
    SYNSent = 1,
    SYNReceived = 2,
    Established = 3,
    Finished = 4,
    Paused = 5
}
export interface YamuxStreamInit extends AbstractStreamInit {
    streamId: number;
    sendFrame(header: FrameHeader, body?: Uint8ArrayList): boolean;
    getRTT(): number;
    initialStreamWindowSize?: number;
    maxMessageSize?: number;
    maxStreamWindowSize?: number;
    state: StreamState;
}
/** YamuxStream is used to represent a logical stream within a session */
export declare class YamuxStream extends AbstractStream {
    streamId: number;
    state: StreamState;
    /** The number of available bytes to send */
    private sendWindowCapacity;
    /** The number of bytes available to receive in a full window */
    private recvWindow;
    /** The number of available bytes to receive */
    private recvWindowCapacity;
    private maxStreamWindowSize;
    /**
     * An 'epoch' is the time it takes to process and read data
     *
     * Used in conjunction with RTT to determine whether to increase the recvWindow
     */
    private epochStart;
    private readonly getRTT;
    private readonly sendFrame;
    constructor(init: YamuxStreamInit);
    /**
     * Send a data message to the remote muxer
     */
    sendData(buf: Uint8ArrayList): SendResult;
    /**
     * Send a reset message to the remote muxer
     */
    sendReset(): void;
    /**
     * Send a message to the remote muxer, informing them no more data messages
     * will be sent by this end of the stream
     */
    sendCloseWrite(): Promise<void>;
    /**
     * Send a message to the remote muxer, informing them no more data messages
     * will be read by this end of the stream - this is a no-op on Yamux streams
     */
    sendCloseRead(options?: AbortOptions): Promise<void>;
    /**
     * Stop sending window updates temporarily - in the interim the the remote
     * send window will exhaust and the remote will stop sending data
     */
    sendPause(): void;
    /**
     * Start sending window updates as normal
     */
    sendResume(): void;
    /**
     * handleWindowUpdate is called when the stream receives a window update frame
     */
    handleWindowUpdate(frame: Frame): void;
    /**
     * handleData is called when the stream receives a data frame
     */
    handleData(frame: Frame): void;
    /**
     * processFlags is used to update the state of the stream based on set flags, if any.
     */
    private processFlags;
    /**
     * getSendFlags determines any flags that are appropriate
     * based on the current stream state.
     *
     * The state is updated as a side-effect.
     */
    private getSendFlags;
    /**
     * Potentially sends a window update enabling further remote writes to take
     * place.
     */
    sendWindowUpdate(): void;
}
//# sourceMappingURL=stream.d.ts.map