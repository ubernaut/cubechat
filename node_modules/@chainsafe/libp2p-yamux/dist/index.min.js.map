{
  "version": 3,
  "sources": ["../src/index.ts", "../node_modules/@libp2p/interface/src/errors.ts", "../node_modules/@libp2p/interface/src/events.ts", "../node_modules/main-event/src/index.ts", "../node_modules/@libp2p/interface/src/index.ts", "../node_modules/uint8arrays/src/equals.ts", "../node_modules/uint8arrays/src/alloc.ts", "../node_modules/uint8arrays/src/concat.ts", "../node_modules/uint8arraylist/src/index.ts", "../node_modules/p-defer/index.js", "../node_modules/it-pushable/src/fifo.ts", "../node_modules/it-pushable/src/index.ts", "../node_modules/p-timeout/index.js", "../node_modules/@libp2p/utils/node_modules/p-event/index.js", "../node_modules/@libp2p/utils/src/debounce.ts", "../node_modules/@libp2p/utils/src/errors.ts", "../node_modules/race-signal/src/index.ts", "../node_modules/@libp2p/utils/src/abstract-message-stream.ts", "../node_modules/@libp2p/utils/src/is-promise.ts", "../node_modules/@libp2p/utils/src/abstract-stream-muxer.ts", "../node_modules/@libp2p/utils/src/abstract-stream.ts", "../node_modules/any-signal/src/index.ts", "../node_modules/@libp2p/utils/src/repeating-task.ts", "../src/frame.ts", "../src/errors.ts", "../src/constants.ts", "../src/config.ts", "../src/decode.ts", "../src/encode.ts", "../src/stream.ts", "../src/muxer.ts"],
  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * This module is a JavaScript implementation of [Yamux from Hashicorp](https://github.com/hashicorp/yamux/blob/master/spec.md) designed to be used with [js-libp2p](https://github.com/libp2p/js-libp2p).\n *\n * @example Configure libp2p with Yamux\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n * import { yamux } from '@chainsafe/libp2p-yamux'\n *\n * const node = await createLibp2p({\n *   // ... other options\n *   streamMuxers: [\n *     yamux()\n *   ]\n * })\n * ```\n *\n * @example Using the low-level API\n *\n * ```js\n * import { yamux } from '@chainsafe/libp2p-yamux'\n * import { pipe } from 'it-pipe'\n * import { duplexPair } from 'it-pair/duplex'\n * import all from 'it-all'\n *\n * // Connect two yamux muxers to demo basic stream multiplexing functionality\n *\n * const clientMuxer = yamux({\n *   client: true,\n *   onIncomingStream: stream => {\n *     // echo data on incoming streams\n *     pipe(stream, stream)\n *   },\n *   onStreamEnd: stream => {\n *     // do nothing\n *   }\n * })()\n *\n * const serverMuxer = yamux({\n *   client: false,\n *   onIncomingStream: stream => {\n *     // echo data on incoming streams\n *     pipe(stream, stream)\n *   },\n *   onStreamEnd: stream => {\n *     // do nothing\n *   }\n * })()\n *\n * // `p` is our \"connections\", what we use to connect the two sides\n * // In a real application, a connection is usually to a remote computer\n * const p = duplexPair()\n *\n * // connect the muxers together\n * pipe(p[0], clientMuxer, p[0])\n * pipe(p[1], serverMuxer, p[1])\n *\n * // now either side can open streams\n * const stream0 = clientMuxer.newStream()\n * const stream1 = serverMuxer.newStream()\n *\n * // Send some data to the other side\n * const encoder = new TextEncoder()\n * const data = [encoder.encode('hello'), encoder.encode('world')]\n * pipe(data, stream0)\n *\n * // Receive data back\n * const result = await pipe(stream0, all)\n *\n * // close a stream\n * stream1.close()\n *\n * // close the muxer\n * clientMuxer.close()\n * ```\n */\n\nimport { Yamux } from './muxer.js'\nimport type { YamuxMuxer, YamuxMuxerInit } from './muxer.js'\nimport type { StreamMuxerFactory } from '@libp2p/interface'\n\nexport { GoAwayCode } from './frame.js'\nexport type { FrameHeader, FrameType } from './frame.js'\nexport type { YamuxMuxerInit }\n\nexport function yamux (init: YamuxMuxerInit = {}): () => StreamMuxerFactory<YamuxMuxer> {\n  return () => new Yamux(init)\n}\n", "/**\n * When this error is thrown it means an operation was aborted,\n * usually in response to the `abort` event being emitted by an\n * AbortSignal.\n */\nexport class AbortError extends Error {\n  static name = 'AbortError'\n\n  constructor (message: string = 'The operation was aborted') {\n    super(message)\n    this.name = 'AbortError'\n  }\n}\n\n/**\n * Thrown when a remote Peer ID does not match the expected one\n */\nexport class UnexpectedPeerError extends Error {\n  static name = 'UnexpectedPeerError'\n\n  constructor (message = 'Unexpected Peer') {\n    super(message)\n    this.name = 'UnexpectedPeerError'\n  }\n}\n\n/**\n * Thrown when a crypto exchange fails\n */\nexport class InvalidCryptoExchangeError extends Error {\n  static name = 'InvalidCryptoExchangeError'\n\n  constructor (message = 'Invalid crypto exchange') {\n    super(message)\n    this.name = 'InvalidCryptoExchangeError'\n  }\n}\n\n/**\n * Thrown when invalid parameters are passed to a function or method call\n */\nexport class InvalidParametersError extends Error {\n  static name = 'InvalidParametersError'\n\n  constructor (message = 'Invalid parameters') {\n    super(message)\n    this.name = 'InvalidParametersError'\n  }\n}\n\n/**\n * Thrown when a public key is invalid\n */\nexport class InvalidPublicKeyError extends Error {\n  static name = 'InvalidPublicKeyError'\n\n  constructor (message = 'Invalid public key') {\n    super(message)\n    this.name = 'InvalidPublicKeyError'\n  }\n}\n\n/**\n * Thrown when a private key is invalid\n */\nexport class InvalidPrivateKeyError extends Error {\n  static name = 'InvalidPrivateKeyError'\n\n  constructor (message = 'Invalid private key') {\n    super(message)\n    this.name = 'InvalidPrivateKeyError'\n  }\n}\n\n/**\n * Thrown when a operation is unsupported\n */\nexport class UnsupportedOperationError extends Error {\n  static name = 'UnsupportedOperationError'\n\n  constructor (message = 'Unsupported operation') {\n    super(message)\n    this.name = 'UnsupportedOperationError'\n  }\n}\n\n/**\n * Thrown when a connection is closing\n */\nexport class ConnectionClosingError extends Error {\n  static name = 'ConnectionClosingError'\n\n  constructor (message = 'The connection is closing') {\n    super(message)\n    this.name = 'ConnectionClosingError'\n  }\n}\n\n/**\n * Thrown when a connection is closed\n */\nexport class ConnectionClosedError extends Error {\n  static name = 'ConnectionClosedError'\n\n  constructor (message = 'The connection is closed') {\n    super(message)\n    this.name = 'ConnectionClosedError'\n  }\n}\n\n/**\n * Thrown when a connection fails\n */\nexport class ConnectionFailedError extends Error {\n  static name = 'ConnectionFailedError'\n\n  constructor (message = 'Connection failed') {\n    super(message)\n    this.name = 'ConnectionFailedError'\n  }\n}\n\n/**\n * Thrown when the muxer is closed and an attempt to open a stream occurs\n */\nexport class MuxerClosedError extends Error {\n  static name = 'MuxerClosedError'\n\n  constructor (message = 'The muxer is closed') {\n    super(message)\n    this.name = 'MuxerClosedError'\n  }\n}\n\n/**\n * Thrown when a protocol stream is reset by the remote muxer\n */\nexport class StreamResetError extends Error {\n  static name = 'StreamResetError'\n\n  constructor (message = 'The stream has been reset') {\n    super(message)\n    this.name = 'StreamResetError'\n  }\n}\n\n/**\n * Thrown when a protocol stream is aborted locally\n */\nexport class StreamAbortedError extends Error {\n  static name = 'StreamAbortedError'\n\n  constructor (message = 'The stream has been aborted') {\n    super(message)\n    this.name = 'StreamAbortedError'\n  }\n}\n\n/**\n * Thrown when a stream is in an invalid state\n */\nexport class StreamStateError extends Error {\n  static name = 'StreamStateError'\n\n  constructor (message = 'The stream is in an invalid state') {\n    super(message)\n    this.name = 'StreamStateError'\n  }\n}\n\n/**\n * Thrown when a stream buffer is full\n */\nexport class StreamBufferError extends Error {\n  static name = 'StreamBufferError'\n\n  constructor (message = 'The stream buffer was full') {\n    super(message)\n    this.name = 'StreamBufferError'\n  }\n}\n\n/**\n * Thrown when a value could not be found\n */\nexport class NotFoundError extends Error {\n  static name = 'NotFoundError'\n\n  constructor (message = 'Not found') {\n    super(message)\n    this.name = 'NotFoundError'\n  }\n}\n\n/**\n * Thrown when an invalid peer ID is encountered\n */\nexport class InvalidPeerIdError extends Error {\n  static name = 'InvalidPeerIdError'\n\n  constructor (message = 'Invalid PeerID') {\n    super(message)\n    this.name = 'InvalidPeerIdError'\n  }\n}\n\n/**\n * Thrown when an invalid multiaddr is encountered\n */\nexport class InvalidMultiaddrError extends Error {\n  static name = 'InvalidMultiaddrError'\n\n  constructor (message = 'Invalid multiaddr') {\n    super(message)\n    this.name = 'InvalidMultiaddrError'\n  }\n}\n\n/**\n * Thrown when an invalid CID is encountered\n */\nexport class InvalidCIDError extends Error {\n  static name = 'InvalidCIDError'\n\n  constructor (message = 'Invalid CID') {\n    super(message)\n    this.name = 'InvalidCIDError'\n  }\n}\n\n/**\n * Thrown when an invalid multihash is encountered\n */\nexport class InvalidMultihashError extends Error {\n  static name = 'InvalidMultihashError'\n\n  constructor (message = 'Invalid Multihash') {\n    super(message)\n    this.name = 'InvalidMultihashError'\n  }\n}\n\n/**\n * Thrown when a protocol is not supported\n */\nexport class UnsupportedProtocolError extends Error {\n  static name = 'UnsupportedProtocolError'\n\n  constructor (message = 'Unsupported protocol error') {\n    super(message)\n    this.name = 'UnsupportedProtocolError'\n  }\n}\n\n/**\n * An invalid or malformed message was encountered during a protocol exchange\n */\nexport class InvalidMessageError extends Error {\n  static name = 'InvalidMessageError'\n\n  constructor (message = 'Invalid message') {\n    super(message)\n    this.name = 'InvalidMessageError'\n  }\n}\n\n/**\n * Thrown when a remote peer sends a structurally valid message that does not\n * comply with the protocol\n */\nexport class ProtocolError extends Error {\n  static name = 'ProtocolError'\n\n  constructor (message = 'Protocol error') {\n    super(message)\n    this.name = 'ProtocolError'\n  }\n}\n\n/**\n * Throw when an operation times out\n */\nexport class TimeoutError extends Error {\n  static name = 'TimeoutError'\n\n  constructor (message = 'Timed out') {\n    super(message)\n    this.name = 'TimeoutError'\n  }\n}\n\n/**\n * Thrown when a startable component is interacted with but it has not been\n * started yet\n */\nexport class NotStartedError extends Error {\n  static name = 'NotStartedError'\n\n  constructor (message = 'Not started') {\n    super(message)\n    this.name = 'NotStartedError'\n  }\n}\n\n/**\n * Thrown when a component is started that has already been started\n */\nexport class AlreadyStartedError extends Error {\n  static name = 'AlreadyStartedError'\n\n  constructor (message = 'Already started') {\n    super(message)\n    this.name = 'AlreadyStartedError'\n  }\n}\n\n/**\n * Thrown when dialing an address failed\n */\nexport class DialError extends Error {\n  static name = 'DialError'\n\n  constructor (message = 'Dial error') {\n    super(message)\n    this.name = 'DialError'\n  }\n}\n\n/**\n * Thrown when listening on an address failed\n */\nexport class ListenError extends Error {\n  static name = 'ListenError'\n\n  constructor (message = 'Listen error') {\n    super(message)\n    this.name = 'ListenError'\n  }\n}\n\n/**\n * This error is thrown when a limited connection is encountered, i.e. if the\n * user tried to open a stream on a connection for a protocol that is not\n * configured to run over limited connections.\n */\nexport class LimitedConnectionError extends Error {\n  static name = 'LimitedConnectionError'\n\n  constructor (message = 'Limited connection') {\n    super(message)\n    this.name = 'LimitedConnectionError'\n  }\n}\n\n/**\n * This error is thrown where there are too many inbound protocols streams open\n */\nexport class TooManyInboundProtocolStreamsError extends Error {\n  static name = 'TooManyInboundProtocolStreamsError'\n\n  constructor (message = 'Too many inbound protocol streams') {\n    super(message)\n    this.name = 'TooManyInboundProtocolStreamsError'\n  }\n}\n\n/**\n * This error is thrown where there are too many outbound protocols streams open\n */\nexport class TooManyOutboundProtocolStreamsError extends Error {\n  static name = 'TooManyOutboundProtocolStreamsError'\n\n  constructor (message = 'Too many outbound protocol streams') {\n    super(message)\n    this.name = 'TooManyOutboundProtocolStreamsError'\n  }\n}\n\n/**\n * Thrown when an attempt to operate on an unsupported key was made\n */\nexport class UnsupportedKeyTypeError extends Error {\n  static name = 'UnsupportedKeyTypeError'\n\n  constructor (message = 'Unsupported key type') {\n    super(message)\n    this.name = 'UnsupportedKeyTypeError'\n  }\n}\n\n/**\n * Thrown when an operation has not been implemented\n */\nexport class NotImplementedError extends Error {\n  static name = 'NotImplementedError'\n\n  constructor (message = 'Not implemented') {\n    super(message)\n    this.name = 'NotImplementedError'\n  }\n}\n", "import type { Uint8ArrayList } from 'uint8arraylist'\n\n/**\n * A custom implementation of MessageEvent as the Undici version does too much\n * validation in it's constructor so is very slow.\n */\nexport class StreamMessageEvent extends Event {\n  public data: Uint8Array | Uint8ArrayList\n\n  constructor (data: Uint8Array | Uint8ArrayList, eventInitDict?: EventInit) {\n    super('message', eventInitDict)\n\n    this.data = data\n  }\n}\n\n/**\n * An event dispatched when the stream is closed. The `error` property can be\n * inspected to discover if the closing was graceful or not, and the `remote`\n * property shows which end of the stream initiated the closure\n */\nexport class StreamCloseEvent extends Event {\n  public error?: Error\n  public local?: boolean\n\n  constructor (local?: boolean, error?: Error, eventInitDict?: EventInit) {\n    super('close', eventInitDict)\n\n    this.error = error\n    this.local = local\n  }\n}\n\nexport class StreamAbortEvent extends StreamCloseEvent {\n  constructor (error: Error, eventInitDict?: EventInit) {\n    super(true, error, eventInitDict)\n  }\n}\n\nexport class StreamResetEvent extends StreamCloseEvent {\n  constructor (error: Error, eventInitDict?: EventInit) {\n    super(false, error, eventInitDict)\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Adds types to the EventTarget class.\n *\n * Hopefully this won't be necessary\n * forever:\n *\n * - https://github.com/microsoft/TypeScript/issues/28357\n * - https://github.com/microsoft/TypeScript/issues/43477\n * - https://github.com/microsoft/TypeScript/issues/299\n * - https://www.npmjs.com/package/typed-events\n * - https://www.npmjs.com/package/typed-event-emitter\n * - https://www.npmjs.com/package/typed-event-target\n * - etc\n *\n * In addition to types, a `safeDispatchEvent` method is available which\n * prevents dispatching events that aren't in the event map, and a\n * `listenerCount` method which reports the number of listeners that are\n * currently registered for a given event.\n *\n * @example\n *\n * ```ts\n * import { TypedEventEmitter } from 'main-event'\n * import type { TypedEventTarget } from 'main-event'\n *\n * interface EventTypes {\n *   'test': CustomEvent<string>\n * }\n *\n * const target = new TypedEventEmitter<EventTypes>()\n *\n * // it's a regular EventTarget\n * console.info(target instanceof EventTarget) // true\n *\n * // register listeners normally\n * target.addEventListener('test', (evt) => {\n *   // evt is CustomEvent<string>\n * })\n *\n * // @ts-expect-error 'derp' is not in the event map\n * target.addEventListener('derp', () => {})\n *\n * // use normal dispatchEvent method\n * target.dispatchEvent(new CustomEvent('test', {\n *   detail: 'hello'\n * }))\n *\n * // use type safe dispatch method\n * target.safeDispatchEvent('test', {\n *   detail: 'world'\n * })\n *\n * // report listener count\n * console.info(target.listenerCount('test')) // 0\n *\n * // event emitters can be used purely as interfaces too\n * function acceptTarget (target: TypedEventTarget<EventTypes>) {\n *   // ...\n * }\n * ```\n */\n\nimport { setMaxListeners } from './events.js'\n\nexport interface EventCallback<EventType> { (evt: EventType): void }\nexport interface EventObject<EventType> { handleEvent: EventCallback<EventType> }\nexport type EventHandler<EventType> = EventCallback<EventType> | EventObject<EventType>\n\ninterface Listener {\n  once: boolean\n  callback: any\n}\n\n/**\n *\n */\nexport interface TypedEventTarget <EventMap extends Record<string, any>> extends EventTarget {\n  addEventListener<K extends keyof EventMap>(type: K, listener: EventHandler<EventMap[K]> | null, options?: boolean | AddEventListenerOptions): void\n\n  listenerCount (type: string): number\n\n  removeEventListener<K extends keyof EventMap>(type: K, listener?: EventHandler<EventMap[K]> | null, options?: boolean | EventListenerOptions): void\n\n  removeEventListener (type: string, listener?: EventHandler<Event>, options?: boolean | EventListenerOptions): void\n\n  safeDispatchEvent<Detail>(type: keyof EventMap, detail?: CustomEventInit<Detail>): boolean\n}\n\n/**\n * An implementation of a typed event target\n */\nexport class TypedEventEmitter<EventMap extends Record<string, any>> extends EventTarget implements TypedEventTarget<EventMap> {\n  readonly #listeners = new Map<any, Listener[]>()\n\n  constructor () {\n    super()\n\n    // silence MaxListenersExceededWarning warning on Node.js, this is a red\n    // herring almost all of the time\n    setMaxListeners(Infinity, this)\n  }\n\n  listenerCount (type: string): number {\n    const listeners = this.#listeners.get(type)\n\n    if (listeners == null) {\n      return 0\n    }\n\n    return listeners.length\n  }\n\n  addEventListener<K extends keyof EventMap>(type: K, listener: EventHandler<EventMap[K]> | null, options?: boolean | AddEventListenerOptions): void\n  addEventListener (type: string, listener: EventHandler<Event>, options?: boolean | AddEventListenerOptions): void {\n    super.addEventListener(type, listener, options)\n\n    let list = this.#listeners.get(type)\n\n    if (list == null) {\n      list = []\n      this.#listeners.set(type, list)\n    }\n\n    list.push({\n      callback: listener,\n      once: (options !== true && options !== false && options?.once) ?? false\n    })\n  }\n\n  removeEventListener<K extends keyof EventMap>(type: K, listener?: EventHandler<EventMap[K]> | null, options?: boolean | EventListenerOptions): void\n  removeEventListener (type: string, listener?: EventHandler<Event>, options?: boolean | EventListenerOptions): void {\n    super.removeEventListener(type.toString(), listener ?? null, options)\n\n    let list = this.#listeners.get(type)\n\n    if (list == null) {\n      return\n    }\n\n    list = list.filter(({ callback }) => callback !== listener)\n    this.#listeners.set(type, list)\n  }\n\n  dispatchEvent (event: Event): boolean {\n    const result = super.dispatchEvent(event)\n\n    let list = this.#listeners.get(event.type)\n\n    if (list == null) {\n      return result\n    }\n\n    list = list.filter(({ once }) => !once)\n    this.#listeners.set(event.type, list)\n\n    return result\n  }\n\n  safeDispatchEvent<Detail>(type: keyof EventMap, detail: CustomEventInit<Detail> = {}): boolean {\n    return this.dispatchEvent(new CustomEvent<Detail>(type as string, detail))\n  }\n}\n\nexport { setMaxListeners }\n", "/**\n * @packageDocumentation\n *\n * Exports a `Libp2p` type for modules to use as a type argument.\n *\n * @example\n *\n * ```typescript\n * import type { Libp2p } from '@libp2p/interface'\n *\n * function doSomethingWithLibp2p (node: Libp2p) {\n *   // ...\n * }\n * ```\n */\n\nimport type { Connection, NewStreamOptions } from './connection.js'\nimport type { ContentRouting } from './content-routing.js'\nimport type { Ed25519PublicKey, PublicKey, RSAPublicKey, Secp256k1PublicKey } from './keys.js'\nimport type { Metrics } from './metrics.js'\nimport type { Ed25519PeerId, PeerId, RSAPeerId, Secp256k1PeerId, URLPeerId } from './peer-id.js'\nimport type { PeerInfo } from './peer-info.js'\nimport type { PeerRouting } from './peer-routing.js'\nimport type { Address, Peer, PeerStore } from './peer-store.js'\nimport type { Startable } from './startable.js'\nimport type { StreamHandler, StreamHandlerOptions, StreamMiddleware } from './stream-handler.js'\nimport type { Stream } from './stream.js'\nimport type { Topology } from './topology.js'\nimport type { Listener, OutboundConnectionUpgradeEvents } from './transport.js'\nimport type { DNS } from '@multiformats/dns'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { TypedEventTarget } from 'main-event'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\n/**\n * Used by the connection manager to sort addresses into order before dialling\n */\nexport interface AddressSorter {\n  (a: Address, b: Address): -1 | 0 | 1\n}\n\n/**\n * Event detail emitted when peer data changes\n */\nexport interface PeerUpdate {\n  peer: Peer\n  previous?: Peer\n}\n\n/**\n * Peer data signed by the remote Peer's public key\n */\nexport interface SignedPeerRecord {\n  addresses: Multiaddr[]\n  seq: bigint\n}\n\n/**\n * A certificate that can be used to secure connections\n */\nexport interface TLSCertificate {\n  /**\n   * The private key that corresponds to the certificate in PEM format\n   */\n  key: string\n\n  /**\n   * The certificate chain in PEM format\n   */\n  cert: string\n}\n\n/**\n * Data returned from a successful identify response\n */\nexport interface IdentifyResult {\n  /**\n   * The remote Peer's PeerId\n   */\n  peerId: PeerId\n\n  /**\n   * The unsigned addresses they are listening on. Note - any multiaddrs present\n   * in the signed peer record should be preferred to the value here.\n   */\n  listenAddrs: Multiaddr[]\n\n  /**\n   * The protocols the remote peer supports\n   */\n  protocols: string[]\n\n  /**\n   * The remote protocol version\n   */\n  protocolVersion?: string\n\n  /**\n   * The remote agent version\n   */\n  agentVersion?: string\n\n  /**\n   * The public key part of the remote PeerId - this is only useful for older\n   * RSA-based PeerIds, the more modern Ed25519 and secp256k1 types have the\n   * public key embedded in them\n   */\n  publicKey?: Uint8Array\n\n  /**\n   * If set this is the address that the remote peer saw the identify request\n   * originate from\n   */\n  observedAddr?: Multiaddr\n\n  /**\n   * If sent by the remote peer this is the deserialized signed peer record\n   */\n  signedPeerRecord?: SignedPeerRecord\n\n  /**\n   * The connection that the identify protocol ran over\n   */\n  connection: Connection\n}\n\n/**\n * Logger component for libp2p\n */\nexport interface Logger {\n  /**\n   * Log a message\n   */\n  (formatter: any, ...args: any[]): void\n\n  /**\n   * Log an error message\n   */\n  error(formatter: any, ...args: any[]): void\n\n  /**\n   * Log a trace message\n   */\n  trace(formatter: any, ...args: any[]): void\n\n  /**\n   * `true` if this logger is enabled\n   */\n  enabled: boolean\n\n  /**\n   * Create a logger scoped below this one\n   *\n   * @example\n   *\n   * ```ts\n   * import { defaultLogger } from '@libp2p/logger'\n   *\n   * const log = defaultLogger().forComponent('foo')\n   *\n   * log('hello')\n   * // foo hello\n   *\n   * const subLog = log.newScope('bar')\n   *\n   * subLog('hello')\n   * // foo:bar hello\n   * ```\n   */\n  newScope(name: string): Logger\n}\n\n/**\n * Peer logger component for libp2p. This can be used to create loggers that are\n * scoped to individual system components or services.\n *\n * To see logs, run your app with `DEBUG` set as an env var or for browsers, in\n * `localStorage`:\n *\n * ```console\n * $ DEBUG=libp2p* node index.js\n *  libp2p:my-service hello +0ms\n * ```\n */\nexport interface ComponentLogger {\n  /**\n   * Returns a logger for the specified component.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * import { ComponentLogger, Logger } from '@libp2p/interface'\n   *\n   * interface MyServiceComponents {\n   *   logger: ComponentLogger\n   * }\n   *\n   * class MyService {\n   *   private readonly log: Logger\n   *\n   *   constructor (components) {\n   *     this.log = components.logger.forComponent('libp2p:my-service')\n   *\n   *     this.log('hello')\n   *     // logs:\n   *     // libp2p:my-service hello +0ms\n   *   }\n   * }\n   * ```\n   */\n  forComponent(name: string): Logger\n}\n\nexport interface MultiaddrResolveOptions extends AbortOptions, LoggerOptions {\n  /**\n   * An optional DNS resolver\n   */\n  dns?: DNS\n}\n\n/**\n * `MultiaddrResolver`s perform resolution of multiaddr components that require\n * translation by external systems (for example DNSADDR to TXT records).\n */\nexport interface MultiaddrResolver {\n  /**\n   * Returns true if this resolver can resolve components of this multiaddr\n   */\n  canResolve (address: Multiaddr): boolean\n\n  /**\n   * Returns one or more multiaddrs with components resolved to other values\n   */\n  resolve (address: Multiaddr, options: MultiaddrResolveOptions): Promise<Multiaddr[]>\n}\n\n/**\n * Once you have a libp2p instance, you can listen to several events it emits,\n * so that you can be notified of relevant network events.\n *\n * Event names are `noun:verb` so the first part is the name of the object\n * being acted on and the second is the action.\n */\nexport interface Libp2pEvents<T extends ServiceMap = ServiceMap> {\n  /**\n   * This event is dispatched when a new network peer is discovered.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:discovery', (event) => {\n   *    const peerInfo = event.detail\n   *    // ...\n   * })\n   * ```\n   */\n  'peer:discovery': CustomEvent<PeerInfo>\n\n  /**\n   * This event will be triggered any time a new peer connects.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:connect', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:connect': CustomEvent<PeerId>\n\n  /**\n   * This event will be triggered any time we are disconnected from another\n   * peer, regardless of the circumstances of that disconnection. If we happen\n   * to have multiple connections to a peer, this event will **only** be\n   * triggered when the last connection is closed.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:disconnect', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:disconnect': CustomEvent<PeerId>\n\n  /**\n   * When a peer tagged with `keep-alive` disconnects, we will make multiple\n   * attempts to reconnect to it with a backoff factor (see the connection\n   * manager settings for details). If these all fail, the `keep-alive` tag will\n   * be removed and this event will be emitted.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:reconnect-failure', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:reconnect-failure': CustomEvent<PeerId>\n\n  /**\n   * This event is dispatched after a remote peer has successfully responded to\n   * the identify protocol. Note that for this to be emitted, both peers must\n   * have an identify service configured.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:identify', (event) => {\n   *   const identifyResult = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:identify': CustomEvent<IdentifyResult>\n\n  /**\n   * This event is dispatched when the peer store data for a peer has been\n   * updated - e.g. their multiaddrs, protocols etc have changed.\n   *\n   * If they were previously known to this node, the old peer data will be\n   * set in the `previous` field.\n   *\n   * This may be in response to the identify protocol running, a manual\n   * update or some other event.\n   */\n  'peer:update': CustomEvent<PeerUpdate>\n\n  /**\n   * This event is dispatched when the current node's peer record changes -\n   * for example a transport started listening on a new address or a new\n   * protocol handler was registered.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('self:peer:update', (event) => {\n   *   const { peer } = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'self:peer:update': CustomEvent<PeerUpdate>\n\n  /**\n   * This event is dispatched when a transport begins listening on a new address\n   */\n  'transport:listening': CustomEvent<Listener>\n\n  /**\n   * This event is dispatched when a transport stops listening on an address\n   */\n  'transport:close': CustomEvent<Listener>\n\n  /**\n   * This event is dispatched when the connection manager has more than the\n   * configured allowable max connections and has closed some connections to\n   * bring the node back under the limit.\n   */\n  'connection:prune': CustomEvent<Connection[]>\n\n  /**\n   * This event notifies listeners when new incoming or outgoing connections\n   * are opened.\n   */\n  'connection:open': CustomEvent<Connection>\n\n  /**\n   * This event notifies listeners when incoming or outgoing connections are\n   * closed.\n   */\n  'connection:close': CustomEvent<Connection>\n\n  /**\n   * This event notifies listeners that a TLS certificate is available for use\n   */\n  'certificate:provision': CustomEvent<TLSCertificate>\n\n  /**\n   * This event notifies listeners that a new TLS certificate is available for\n   * use. Any previous certificate may no longer be valid.\n   */\n  'certificate:renew': CustomEvent<TLSCertificate>\n\n  /**\n   * This event notifies listeners that the node has started\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('start', (event) => {\n   *   console.info(libp2p.isStarted()) // true\n   * })\n   * ```\n   */\n  start: CustomEvent<Libp2p<T>>\n\n  /**\n   * This event notifies listeners that the node has stopped\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('stop', (event) => {\n   *   console.info(libp2p.isStarted()) // false\n   * })\n   * ```\n   */\n  stop: CustomEvent<Libp2p<T>>\n}\n\n/**\n * A map of user defined services available on the libp2p node via the\n * `services` key\n *\n * @example\n *\n * ```TypeScript\n * const node = await createLibp2p({\n *   // ...other options\n *   services: {\n *     myService: myService({\n *       // ...service options\n *     })\n *   }\n * })\n *\n * // invoke methods on the service\n * node.services.myService.anOperation()\n * ```\n */\nexport type ServiceMap = Record<string, unknown>\n\nexport type PendingDialStatus = 'queued' | 'active' | 'error' | 'success'\n\n/**\n * An item in the dial queue\n */\nexport interface PendingDial {\n  /**\n   * A unique identifier for this dial\n   */\n  id: string\n\n  /**\n   * The current status of the dial\n   */\n  status: PendingDialStatus\n\n  /**\n   * If known, this is the peer id that libp2p expects to be dialling\n   */\n  peerId?: PeerId\n\n  /**\n   * The list of multiaddrs that will be dialled. The returned connection will\n   * use the first address that succeeds, all other dials part of this pending\n   * dial will be cancelled.\n   */\n  multiaddrs: Multiaddr[]\n}\n\nexport type Libp2pStatus = 'starting' | 'started' | 'stopping' | 'stopped'\n\nexport interface IsDialableOptions extends AbortOptions {\n  /**\n   * If the dial attempt would open a protocol, and the multiaddr being dialed\n   * is a circuit relay address, passing true here would cause the test to fail\n   * because that protocol would not be allowed to run over a data/time limited\n   * connection.\n   */\n  runOnLimitedConnection?: boolean\n}\n\nexport type TransportManagerDialProgressEvents =\n  ProgressEvent<'transport-manager:selected-transport', string>\n\nexport type OpenConnectionProgressEvents =\n  TransportManagerDialProgressEvents |\n  ProgressEvent<'dial-queue:already-connected'> |\n  ProgressEvent<'dial-queue:already-in-dial-queue'> |\n  ProgressEvent<'dial-queue:add-to-dial-queue'> |\n  ProgressEvent<'dial-queue:start-dial'> |\n  ProgressEvent<'dial-queue:calculated-addresses', Address[]> |\n  OutboundConnectionUpgradeEvents\n\nexport interface DialOptions extends AbortOptions, ProgressOptions {\n  /**\n   * If true, open a new connection to the remote even if one already exists\n   */\n  force?: boolean\n}\n\nexport interface DialProtocolOptions extends NewStreamOptions {\n\n}\n\n/**\n * Libp2p nodes implement this interface.\n */\nexport interface Libp2p<T extends ServiceMap = ServiceMap> extends Startable, TypedEventTarget<Libp2pEvents<T>> {\n  /**\n   * The PeerId is a unique identifier for a node on the network.\n   *\n   * It is the hash of an RSA public key or, for Ed25519 or secp256k1 keys,\n   * the key itself.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * console.info(libp2p.peerId)\n   * // PeerId(12D3Foo...)\n   * ````\n   */\n  peerId: PeerId\n\n  /**\n   * The peer store holds information we know about other peers on the network.\n   * - multiaddrs, supported protocols, etc.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peer = await libp2p.peerStore.get(peerId)\n   * console.info(peer)\n   * // { id: PeerId(12D3Foo...), addresses: [] ... }\n   * ```\n   */\n  peerStore: PeerStore\n\n  /**\n   * The peer routing subsystem allows the user to find peers on the network\n   * or to find peers close to binary keys.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peerInfo = await libp2p.peerRouting.findPeer(peerId)\n   * console.info(peerInfo)\n   * // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * ```\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for await (const peerInfo of libp2p.peerRouting.getClosestPeers(key)) {\n   *   console.info(peerInfo)\n   *   // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * }\n   * ```\n   */\n  peerRouting: PeerRouting\n\n  /**\n   * The content routing subsystem allows the user to find providers for content,\n   * let the network know they are providers for content, and get/put values to\n   * the DHT.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for await (const peerInfo of libp2p.contentRouting.findProviders(cid)) {\n   *   console.info(peerInfo)\n   *   // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * }\n   * ```\n   */\n  contentRouting: ContentRouting\n\n  /**\n   * The metrics subsystem allows recording values to assess the health/performance\n   * of the running node.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const metric = libp2p.metrics.registerMetric({\n   *   'my-metric'\n   * })\n   *\n   * // later\n   * metric.update(5)\n   * ```\n   */\n  metrics?: Metrics\n\n  /**\n   * The logger used by this libp2p node\n   */\n  logger: ComponentLogger\n\n  /**\n   * The current status of the libp2p node\n   */\n  status: Libp2pStatus\n\n  /**\n   * Get a deduplicated list of peer advertising multiaddrs by concatenating\n   * the listen addresses used by transports with any configured\n   * announce addresses as well as observed addresses reported by peers.\n   *\n   * If Announce addrs are specified, configured listen addresses will be\n   * ignored though observed addresses will still be included.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const listenMa = libp2p.getMultiaddrs()\n   * // [ <Multiaddr 047f00000106f9ba - /ip4/127.0.0.1/tcp/63930> ]\n   * ```\n   */\n  getMultiaddrs(): Multiaddr[]\n\n  /**\n   * Returns a list of supported protocols\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const protocols = libp2p.getProtocols()\n   * // [ '/ipfs/ping/1.0.0', '/ipfs/id/1.0.0' ]\n   * ```\n   */\n  getProtocols(): string[]\n\n  /**\n   * Return a list of all connections this node has open, optionally filtering\n   * by a PeerId\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for (const connection of libp2p.getConnections()) {\n   *   console.log(peerId, connection.remoteAddr.toString())\n   *   // Logs the PeerId string and the observed remote multiaddr of each Connection\n   * }\n   * ```\n   */\n  getConnections(peerId?: PeerId): Connection[]\n\n  /**\n   * Return the list of dials currently in progress or queued to start\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for (const pendingDial of libp2p.getDialQueue()) {\n   *   console.log(pendingDial)\n   * }\n   * ```\n   */\n  getDialQueue(): PendingDial[]\n\n  /**\n   * Return a list of all peers we currently have a connection open to\n   */\n  getPeers(): PeerId[]\n\n  /**\n   * Dials to the provided peer. If successful, the known metadata of the\n   * peer will be added to the nodes `peerStore`.\n   *\n   * If a PeerId is passed as the first argument, the peer will need to have known multiaddrs for it in the PeerStore.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const conn = await libp2p.dial(remotePeerId)\n   *\n   * // create a new stream within the connection\n   * const stream = await conn.newStream(['/echo/1.1.0', '/echo/1.0.0'])\n   *\n   * // protocol negotiated: 'echo/1.0.0' means that the other party only supports the older version\n   *\n   * // ...\n   * await conn.close()\n   * ```\n   */\n  dial(peer: PeerId | Multiaddr | Multiaddr[], options?: DialOptions): Promise<Connection>\n\n  /**\n   * Dials to the provided peer and tries to handshake with the given protocols in order.\n   * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n   * and the `MuxedStream` will be returned together with the successful negotiated protocol.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * import { pipe } from 'it-pipe'\n   *\n   * const { stream, protocol } = await libp2p.dialProtocol(remotePeerId, protocols)\n   *\n   * // Use this new stream like any other duplex stream\n   * pipe([1, 2, 3], stream, consume)\n   * ```\n   */\n  dialProtocol(peer: PeerId | Multiaddr | Multiaddr[], protocols: string | string[], options?: DialProtocolOptions): Promise<Stream>\n\n  /**\n   * Attempts to gracefully close an open connection to the given peer. If the\n   * connection is not closed in the grace period, it will be forcefully closed.\n   *\n   * An AbortSignal can optionally be passed to control when the connection is\n   * forcefully closed.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * await libp2p.hangUp(remotePeerId)\n   * ```\n   */\n  hangUp(peer: PeerId | Multiaddr, options?: AbortOptions): Promise<void>\n\n  /**\n   * Sets up [multistream-select routing](https://github.com/multiformats/multistream-select) of protocols to their application handlers. Whenever a stream is opened on one of the provided protocols, the handler will be called. `handle` must be called in order to register a handler and support for a given protocol. This also informs other peers of the protocols you support.\n   *\n   * `libp2p.handle(protocols, handler, options)`\n   *\n   * In the event of a new handler for the same protocol being added and error\n   * will be thrown. Pass `force: true` to override this.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const handler = ({ connection, stream, protocol }) => {\n   *   // use stream or connection according to the needs\n   * }\n   *\n   * libp2p.handle('/echo/1.0.0', handler, {\n   *   maxInboundStreams: 5,\n   *   maxOutboundStreams: 5\n   * })\n   * ```\n   */\n  handle(protocol: string | string[], handler: StreamHandler, options?: StreamHandlerOptions): Promise<void>\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.unhandle(['/echo/1.0.0'])\n   * ```\n   */\n  unhandle(protocols: string[] | string, options?: AbortOptions): Promise<void>\n\n  /**\n   * Register a topology to be informed when peers are encountered that\n   * support the specified protocol\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const id = await libp2p.register('/echo/1.0.0', {\n   *   onConnect: (peer, connection) => {\n   *     // handle connect\n   *   },\n   *   onDisconnect: (peer, connection) => {\n   *     // handle disconnect\n   *   }\n   * })\n   * ```\n   */\n  register(protocol: string, topology: Topology, options?: AbortOptions): Promise<string>\n\n  /**\n   * Unregister topology to no longer be informed when peers connect or\n   * disconnect.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const id = await libp2p.register(...)\n   *\n   * libp2p.unregister(id)\n   * ```\n   */\n  unregister(id: string): void\n\n  /**\n   * Registers one or more middleware implementations that will be invoked for\n   * incoming and outgoing protocol streams that match the passed protocol.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.use('/my/protocol/1.0.0', (stream, connection, next) => {\n   *   // do something with stream and/or connection\n   *   next(stream, connection)\n   * })\n   * ```\n   */\n  use (protocol: string, middleware: StreamMiddleware | StreamMiddleware[]): void\n\n  /**\n   * Deregisters all middleware for the passed protocol.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.unuse('/my/protocol/1.0.0')\n   * // any previously registered middleware will no longer be invoked\n   * ```\n   */\n  unuse (protocol: string): void\n\n  /**\n   * Returns the public key for the passed PeerId. If the PeerId is of the 'RSA'\n   * type this may mean searching the routing if the peer's key is not present\n   * in the peer store.\n   */\n  getPublicKey(peer: Ed25519PeerId, options?: AbortOptions): Promise<Ed25519PublicKey>\n  getPublicKey(peer: Secp256k1PeerId, options?: AbortOptions): Promise<Secp256k1PublicKey>\n  getPublicKey(peer: RSAPeerId, options?: AbortOptions): Promise<RSAPublicKey>\n  getPublicKey(peer: URLPeerId, options?: AbortOptions): Promise<never>\n  getPublicKey(peer: PeerId, options?: AbortOptions): Promise<PublicKey>\n\n  /**\n   * Given the current node configuration, returns a promise of `true` or\n   * `false` if the node would attempt to dial the passed multiaddr.\n   *\n   * This means a relevant transport is configured, and the connection gater\n   * would not block the dial attempt.\n   *\n   * This may involve resolving DNS addresses so you should pass an AbortSignal.\n   */\n  isDialable(multiaddr: Multiaddr | Multiaddr[], options?: IsDialableOptions): Promise<boolean>\n\n  /**\n   * A set of user defined services\n   */\n  services: T\n}\n\n/**\n * Metadata about the current node\n */\nexport interface NodeInfo {\n  /**\n   * The implementation name\n   */\n  name: string\n\n  /**\n   * The implementation version\n   */\n  version: string\n\n  /**\n   * A string that contains information about the implementation and runtime\n   */\n  userAgent: string\n}\n\n/**\n * An object that contains an AbortSignal as\n * the optional `signal` property.\n *\n * @example\n *\n * ```TypeScript\n * const controller = new AbortController()\n *\n * aLongRunningOperation({\n *   signal: controller.signal\n * })\n *\n * // later\n *\n * controller.abort()\n */\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\n/**\n * An object that contains a Logger as the `log` property.\n */\nexport interface LoggerOptions {\n  log: Logger\n}\n\n/**\n * An object that includes a trace object that is passed onwards.\n *\n * This is used by metrics method tracing to link function calls together.\n */\nexport interface TraceOptions {\n  trace?: any\n}\n\n/**\n * A signal that needs to be cleared when no longer in use\n */\nexport interface ClearableSignal extends AbortSignal {\n  clear(): void\n}\n\n/**\n * When a routing operation involves reading values, these options allow\n * controlling where the values are read from. By default libp2p will check\n * local caches but may not use the network if a valid local value is found,\n * these options allow tuning that behavior.\n */\nexport interface RoutingOptions extends AbortOptions, ProgressOptions, TraceOptions {\n  /**\n   * Pass `false` to not use the network\n   *\n   * @default true\n   */\n  useNetwork?: boolean\n\n  /**\n   * Pass `false` to not use cached values\n   *\n   * @default true\n   */\n  useCache?: boolean\n}\n\n/**\n * This symbol is used by libp2p services to define the capabilities they can\n * provide to other libp2p services.\n *\n * The service should define a property with this symbol as the key and the\n * value should be a string array of provided capabilities.\n */\nexport const serviceCapabilities = Symbol.for('@libp2p/service-capabilities')\n\n/**\n * This symbol is used by libp2p services to define the capabilities they\n * require from other libp2p services.\n *\n * The service should define a property with this symbol as the key and the\n * value should be a string array of required capabilities.\n */\nexport const serviceDependencies = Symbol.for('@libp2p/service-dependencies')\n\nexport * from './connection.js'\nexport * from './connection-encrypter.js'\nexport * from './connection-gater.js'\nexport * from './connection-protector.js'\nexport * from './content-routing.js'\nexport * from './errors.js'\nexport * from './events.js'\nexport * from './keys.js'\nexport * from './message-stream.js'\nexport * from './metrics.js'\nexport * from './multiaddr-connection.js'\nexport * from './peer-discovery.js'\nexport * from './peer-id.js'\nexport * from './peer-info.js'\nexport * from './peer-routing.js'\nexport * from './peer-store.js'\nexport * from './record.js'\nexport * from './startable.js'\nexport * from './stream-handler.js'\nexport * from './stream-muxer.js'\nexport * from './stream.js'\nexport * from './topology.js'\nexport * from './transport.js'\n\nexport * from 'main-event'\n", "/**\n * Returns true if the two passed Uint8Arrays have the same content\n */\nexport function equals (a: Uint8Array, b: Uint8Array): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (a.byteLength !== b.byteLength) {\n    return false\n  }\n\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] !== b[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n", "/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n", "import { allocUnsafe } from '#alloc'\nimport { asUint8Array } from '#util/as-uint8array'\n\n/**\n * Returns a new Uint8Array created by concatenating the passed Uint8Arrays\n */\nexport function concat (arrays: Uint8Array[], length?: number): Uint8Array {\n  if (length == null) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0)\n  }\n\n  const output = allocUnsafe(length)\n  let offset = 0\n\n  for (const arr of arrays) {\n    output.set(arr, offset)\n    offset += arr.length\n  }\n\n  return asUint8Array(output)\n}\n", "/**\n * @packageDocumentation\n *\n * A class that lets you do operations over a list of Uint8Arrays without\n * copying them.\n *\n * ```js\n * import { Uint8ArrayList } from 'uint8arraylist'\n *\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray()\n * // -> Uint8Array([0, 1, 2, 3, 4, 5])\n *\n * list.consume(3)\n * list.subarray()\n * // -> Uint8Array([3, 4, 5])\n *\n * // you can also iterate over the list\n * for (const buf of list) {\n *   // ..do something with `buf`\n * }\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ## Converting Uint8ArrayLists to Uint8Arrays\n *\n * There are two ways to turn a `Uint8ArrayList` into a `Uint8Array` - `.slice` and `.subarray` and one way to turn a `Uint8ArrayList` into a `Uint8ArrayList` with different contents - `.sublist`.\n *\n * ### slice\n *\n * Slice follows the same semantics as [Uint8Array.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice) in that it creates a new `Uint8Array` and copies bytes into it using an optional offset & length.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.slice(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ### subarray\n *\n * Subarray attempts to follow the same semantics as [Uint8Array.subarray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray) with one important different - this is a no-copy operation, unless the requested bytes span two internal buffers in which case it is a copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0]) - no-copy\n *\n * list.subarray(2, 5)\n * // -> Uint8Array([2, 3, 4]) - copy\n * ```\n *\n * ### sublist\n *\n * Sublist creates and returns a new `Uint8ArrayList` that shares the underlying buffers with the original so is always a no-copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.sublist(0, 1)\n * // -> Uint8ArrayList([0]) - no-copy\n *\n * list.sublist(2, 5)\n * // -> Uint8ArrayList([2], [3, 4]) - no-copy\n * ```\n *\n * ## Inspiration\n *\n * Borrows liberally from [bl](https://www.npmjs.com/package/bl) but only uses native JS types.\n */\nimport { allocUnsafe, alloc } from 'uint8arrays/alloc'\nimport { concat } from 'uint8arrays/concat'\nimport { equals } from 'uint8arrays/equals'\n\nconst symbol = Symbol.for('@achingbrain/uint8arraylist')\n\nexport type Appendable = Uint8ArrayList | Uint8Array\n\nfunction findBufAndOffset (bufs: Uint8Array[], index: number): { buf: Uint8Array, index: number } {\n  if (index == null || index < 0) {\n    throw new RangeError('index is out of bounds')\n  }\n\n  let offset = 0\n\n  for (const buf of bufs) {\n    const bufEnd = offset + buf.byteLength\n\n    if (index < bufEnd) {\n      return {\n        buf,\n        index: index - offset\n      }\n    }\n\n    offset = bufEnd\n  }\n\n  throw new RangeError('index is out of bounds')\n}\n\n/**\n * Check if object is a CID instance\n *\n * @example\n *\n * ```js\n * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\n *\n * isUint8ArrayList(true) // false\n * isUint8ArrayList([]) // false\n * isUint8ArrayList(new Uint8ArrayList()) // true\n * ```\n */\nexport function isUint8ArrayList (value: any): value is Uint8ArrayList {\n  return Boolean(value?.[symbol])\n}\n\nexport class Uint8ArrayList implements Iterable<Uint8Array> {\n  private bufs: Uint8Array[]\n  public length: number\n  public readonly [symbol] = true\n\n  constructor (...data: Appendable[]) {\n    this.bufs = []\n    this.length = 0\n\n    if (data.length > 0) {\n      this.appendAll(data)\n    }\n  }\n\n  * [Symbol.iterator] (): Iterator<Uint8Array> {\n    yield * this.bufs\n  }\n\n  get byteLength (): number {\n    return this.length\n  }\n\n  /**\n   * Add one or more `bufs` to the end of this Uint8ArrayList\n   */\n  append (...bufs: Appendable[]): void {\n    this.appendAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the end of this Uint8ArrayList\n   */\n  appendAll (bufs: Appendable[]): void {\n    let length = 0\n\n    for (const buf of bufs) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.push(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.push(...buf.bufs)\n      } else {\n        throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Add one or more `bufs` to the start of this Uint8ArrayList\n   */\n  prepend (...bufs: Appendable[]): void {\n    this.prependAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the start of this Uint8ArrayList\n   */\n  prependAll (bufs: Appendable[]): void {\n    let length = 0\n\n    for (const buf of bufs.reverse()) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.unshift(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.unshift(...buf.bufs)\n      } else {\n        throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Read the value at `index`\n   */\n  get (index: number): number {\n    const res = findBufAndOffset(this.bufs, index)\n\n    return res.buf[res.index]\n  }\n\n  /**\n   * Set the value at `index` to `value`\n   */\n  set (index: number, value: number): void {\n    const res = findBufAndOffset(this.bufs, index)\n\n    res.buf[res.index] = value\n  }\n\n  /**\n   * Copy bytes from `buf` to the index specified by `offset`\n   */\n  write (buf: Appendable, offset: number = 0): void {\n    if (buf instanceof Uint8Array) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf[i])\n      }\n    } else if (isUint8ArrayList(buf)) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf.get(i))\n      }\n    } else {\n      throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList')\n    }\n  }\n\n  /**\n   * Remove bytes from the front of the pool\n   */\n  consume (bytes: number): void {\n    // first, normalize the argument, in accordance with how Buffer does it\n    bytes = Math.trunc(bytes)\n\n    // do nothing if not a positive number\n    if (Number.isNaN(bytes) || bytes <= 0) {\n      return\n    }\n\n    // if consuming all bytes, skip iterating\n    if (bytes === this.byteLength) {\n      this.bufs = []\n      this.length = 0\n      return\n    }\n\n    while (this.bufs.length > 0) {\n      if (bytes >= this.bufs[0].byteLength) {\n        bytes -= this.bufs[0].byteLength\n        this.length -= this.bufs[0].byteLength\n        this.bufs.shift()\n      } else {\n        this.bufs[0] = this.bufs[0].subarray(bytes)\n        this.length -= bytes\n        break\n      }\n    }\n  }\n\n  /**\n   * Extracts a section of an array and returns a new array.\n   *\n   * This is a copy operation as it is with Uint8Arrays and Arrays\n   * - note this is different to the behaviour of Node Buffers.\n   */\n  slice (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a alloc from the given start and end element index.\n   *\n   * In the best case where the data extracted comes from a single Uint8Array\n   * internally this is a no-copy operation otherwise it is a copy operation.\n   */\n  subarray (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    if (bufs.length === 1) {\n      return bufs[0]\n    }\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a allocList from the given start and end element index.\n   *\n   * This is a no-copy operation.\n   */\n  sublist (beginInclusive?: number, endExclusive?: number): Uint8ArrayList {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    const list = new Uint8ArrayList()\n    list.length = length\n    // don't loop, just set the bufs\n    list.bufs = [...bufs]\n\n    return list\n  }\n\n  private _subList (beginInclusive?: number, endExclusive?: number): { bufs: Uint8Array[], length: number } {\n    beginInclusive = beginInclusive ?? 0\n    endExclusive = endExclusive ?? this.length\n\n    if (beginInclusive < 0) {\n      beginInclusive = this.length + beginInclusive\n    }\n\n    if (endExclusive < 0) {\n      endExclusive = this.length + endExclusive\n    }\n\n    if (beginInclusive < 0 || endExclusive > this.length) {\n      throw new RangeError('index is out of bounds')\n    }\n\n    if (beginInclusive === endExclusive) {\n      return { bufs: [], length: 0 }\n    }\n\n    if (beginInclusive === 0 && endExclusive === this.length) {\n      return { bufs: this.bufs, length: this.length }\n    }\n\n    const bufs: Uint8Array[] = []\n    let offset = 0\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      const buf = this.bufs[i]\n      const bufStart = offset\n      const bufEnd = bufStart + buf.byteLength\n\n      // for next loop\n      offset = bufEnd\n\n      if (beginInclusive >= bufEnd) {\n        // start after this buf\n        continue\n      }\n\n      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd\n      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd\n\n      if (sliceStartInBuf && sliceEndsInBuf) {\n        // slice is wholly contained within this buffer\n        if (beginInclusive === bufStart && endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        const start = beginInclusive - bufStart\n        bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)))\n        break\n      }\n\n      if (sliceStartInBuf) {\n        // slice starts in this buffer\n        if (beginInclusive === 0) {\n          // requested whole buffer\n          bufs.push(buf)\n          continue\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(beginInclusive - bufStart))\n        continue\n      }\n\n      if (sliceEndsInBuf) {\n        if (endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(0, endExclusive - bufStart))\n        break\n      }\n\n      // slice started before this buffer and ends after it\n      bufs.push(buf)\n    }\n\n    return { bufs, length: endExclusive - beginInclusive }\n  }\n\n  indexOf (search: Uint8ArrayList | Uint8Array, offset: number = 0): number {\n    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {\n      throw new TypeError('The \"value\" argument must be a Uint8ArrayList or Uint8Array')\n    }\n\n    const needle = search instanceof Uint8Array ? search : search.subarray()\n\n    offset = Number(offset ?? 0)\n\n    if (isNaN(offset)) {\n      offset = 0\n    }\n\n    if (offset < 0) {\n      offset = this.length + offset\n    }\n\n    if (offset < 0) {\n      offset = 0\n    }\n\n    if (search.length === 0) {\n      return offset > this.length ? this.length : offset\n    }\n\n    // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\n    const M: number = needle.byteLength\n\n    if (M === 0) {\n      throw new TypeError('search must be at least 1 byte long')\n    }\n\n    // radix\n    const radix: number = 256\n    const rightmostPositions: Int32Array = new Int32Array(radix)\n\n    // position of the rightmost occurrence of the byte c in the pattern\n    for (let c: number = 0; c < radix; c++) {\n      // -1 for bytes not in pattern\n      rightmostPositions[c] = -1\n    }\n\n    for (let j = 0; j < M; j++) {\n      // rightmost position for bytes in pattern\n      rightmostPositions[needle[j]] = j\n    }\n\n    // Return offset of first match, -1 if no match\n    const right = rightmostPositions\n    const lastIndex = this.byteLength - needle.byteLength\n    const lastPatIndex = needle.byteLength - 1\n    let skip: number\n\n    for (let i = offset; i <= lastIndex; i += skip) {\n      skip = 0\n\n      for (let j = lastPatIndex; j >= 0; j--) {\n        const char: number = this.get(i + j)\n\n        if (needle[j] !== char) {\n          skip = Math.max(1, j - right[char])\n          break\n        }\n      }\n\n      if (skip === 0) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  getInt8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt8(0)\n  }\n\n  setInt8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt16(0, littleEndian)\n  }\n\n  setInt16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt32(0, littleEndian)\n  }\n\n  setInt32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigInt64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigInt64(0, littleEndian)\n  }\n\n  setBigInt64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigInt64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint8(0)\n  }\n\n  setUint8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint16(0, littleEndian)\n  }\n\n  setUint16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint32(0, littleEndian)\n  }\n\n  setUint32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigUint64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigUint64(0, littleEndian)\n  }\n\n  setBigUint64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigUint64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat32(0, littleEndian)\n  }\n\n  setFloat32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat64 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat64(0, littleEndian)\n  }\n\n  setFloat64 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  equals (other: any): other is Uint8ArrayList {\n    if (other == null) {\n      return false\n    }\n\n    if (!(other instanceof Uint8ArrayList)) {\n      return false\n    }\n\n    if (other.bufs.length !== this.bufs.length) {\n      return false\n    }\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      if (!equals(this.bufs[i], other.bufs[i])) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this\n   * method if you know the total size of all the Uint8Arrays ahead of time.\n   */\n  static fromUint8Arrays (bufs: Uint8Array[], length?: number): Uint8ArrayList {\n    const list = new Uint8ArrayList()\n    list.bufs = bufs\n\n    if (length == null) {\n      length = bufs.reduce((acc, curr) => acc + curr.byteLength, 0)\n    }\n\n    list.length = length\n\n    return list\n  }\n}\n\n/*\nfunction indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {\n  for (let i = offset; i < haystack.byteLength; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.byteLength -1) {\n        return i\n      }\n    }\n\n    if (haystack.byteLength - i < needle.byteLength) {\n      break\n    }\n  }\n\n  return -1\n}\n*/\n", "export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n", "// ported from https://www.npmjs.com/package/fast-fifo\n\nexport interface Next<T> {\n  done?: boolean\n  error?: Error\n  value?: T\n}\n\nclass FixedFIFO<T> {\n  public buffer: Array<Next<T> | undefined>\n  private readonly mask: number\n  private top: number\n  private btm: number\n  public next: FixedFIFO<T> | null\n\n  constructor (hwm: number) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) {\n      throw new Error('Max size for a FixedFIFO should be a power of two')\n    }\n\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  push (data: Next<T>): boolean {\n    if (this.buffer[this.top] !== undefined) {\n      return false\n    }\n\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n\n    return true\n  }\n\n  shift (): Next<T> | undefined {\n    const last = this.buffer[this.btm]\n\n    if (last === undefined) {\n      return undefined\n    }\n\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  isEmpty (): boolean {\n    return this.buffer[this.btm] === undefined\n  }\n}\n\nexport interface FIFOOptions {\n  /**\n   * When the queue reaches this size, it will be split into head/tail parts\n   */\n  splitLimit?: number\n}\n\nexport class FIFO<T> {\n  public size: number\n  private readonly hwm: number\n  private head: FixedFIFO<T>\n  private tail: FixedFIFO<T>\n\n  constructor (options: FIFOOptions = {}) {\n    this.hwm = options.splitLimit ?? 16\n    this.head = new FixedFIFO<T>(this.hwm)\n    this.tail = this.head\n    this.size = 0\n  }\n\n  calculateSize (obj: any): number {\n    if (obj?.byteLength != null) {\n      return obj.byteLength\n    }\n\n    return 1\n  }\n\n  push (val: Next<T>): void {\n    if (val?.value != null) {\n      this.size += this.calculateSize(val.value)\n    }\n\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO<T>(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift (): Next<T> | undefined {\n    let val = this.tail.shift()\n\n    if (val === undefined && (this.tail.next != null)) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      val = this.tail.shift()\n    }\n\n    if (val?.value != null) {\n      this.size -= this.calculateSize(val.value)\n    }\n\n    return val\n  }\n\n  isEmpty (): boolean {\n    return this.head.isEmpty()\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\n\nimport deferred from 'p-defer'\nimport { FIFO, type Next } from './fifo.js'\n\nexport class AbortError extends Error {\n  type: string\n  code: string\n\n  constructor (message?: string, code?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\ninterface BasePushable<T> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end(err?: Error): this\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push(value: T): this\n\n  /**\n   * Returns a promise that resolves when the underlying queue becomes empty (e.g.\n   * this.readableLength === 0).\n   *\n   * If an AbortSignal is passed as an option and that signal aborts, it only\n   * causes the returned promise to reject - it does not end the pushable.\n   */\n  onEmpty(options?: AbortOptions): Promise<void>\n\n  /**\n   * This property contains the number of bytes (or objects) in the queue ready to be read.\n   *\n   * If `objectMode` is true, this is the number of objects in the queue, if false it's the\n   * total number of bytes in the queue.\n   */\n  readableLength: number\n}\n\n/**\n * An iterable that you can push values into.\n */\nexport interface Pushable<T, R = void, N = unknown> extends AsyncGenerator<T, R, N>, BasePushable<T> {}\n\n/**\n * Similar to `pushable`, except it yields multiple buffered chunks at a time. All values yielded from the iterable will be arrays.\n */\nexport interface PushableV<T, R = void, N = unknown> extends AsyncGenerator<T[], R, N>, BasePushable<T> {}\n\nexport interface Options {\n  /**\n   * A boolean value that means non-`Uint8Array`s will be passed to `.push`, default: `false`\n   */\n  objectMode?: boolean\n\n  /**\n   * A function called after *all* values have been yielded from the iterator (including\n   * buffered values). In the case when the iterator is ended with an error it will be\n   * passed the error as a parameter.\n   */\n  onEnd?(err?: Error): void\n}\n\nexport interface DoneResult { done: true }\nexport interface ValueResult<T> { done: false, value: T }\nexport type NextResult<T> = ValueResult<T> | DoneResult\n\ninterface getNext<T, V = T> { (buffer: FIFO<T>): NextResult<V> }\n\nexport interface ObjectPushableOptions extends Options {\n  objectMode: true\n}\n\nexport interface BytePushableOptions extends Options {\n  objectMode?: false\n}\n\n/**\n * Create a new async iterable. The values yielded from calls to `.next()`\n * or when used in a `for await of`loop are \"pushed\" into the iterable.\n * Returns an async iterable object with additional methods.\n */\nexport function pushable<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): Pushable<T>\nexport function pushable<T> (options: ObjectPushableOptions): Pushable<T>\nexport function pushable<T> (options: Options = {}): Pushable<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T> => {\n    const next: Next<T> | undefined = buffer.shift()\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    if (next.error != null) {\n      throw next.error\n    }\n\n    return {\n      done: next.done === true,\n      // @ts-expect-error if done is false, value will be present\n      value: next.value\n    }\n  }\n\n  return _pushable<T, T, Pushable<T>>(getNext, options)\n}\n\nexport function pushableV<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): PushableV<T>\nexport function pushableV<T> (options: ObjectPushableOptions): PushableV<T>\nexport function pushableV<T> (options: Options = {}): PushableV<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T[]> => {\n    let next: Next<T> | undefined\n    const values: T[] = []\n\n    while (!buffer.isEmpty()) {\n      next = buffer.shift()\n\n      if (next == null) {\n        break\n      }\n\n      if (next.error != null) {\n        throw next.error\n      }\n\n      if (next.done === false) {\n        // @ts-expect-error if done is false value should be pushed\n        values.push(next.value)\n      }\n    }\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    return {\n      done: next.done === true,\n      value: values\n    }\n  }\n\n  return _pushable<T, T[], PushableV<T>>(getNext, options)\n}\n\nfunction _pushable<PushType, ValueType, ReturnType> (getNext: getNext<PushType, ValueType>, options?: Options): ReturnType {\n  options = options ?? {}\n  let onEnd = options.onEnd\n  let buffer = new FIFO<PushType>()\n  let pushable: any\n  let onNext: ((next: Next<PushType>) => ReturnType) | null\n  let ended: boolean\n  let drain = deferred()\n\n  const waitNext = async (): Promise<NextResult<ValueType>> => {\n    try {\n      if (!buffer.isEmpty()) {\n        return getNext(buffer)\n      }\n\n      if (ended) {\n        return { done: true }\n      }\n\n      return await new Promise<NextResult<ValueType>>((resolve, reject) => {\n        onNext = (next: Next<PushType>) => {\n          onNext = null\n          buffer.push(next)\n\n          try {\n            resolve(getNext(buffer))\n          } catch (err) {\n            reject(err)\n          }\n\n          return pushable\n        }\n      })\n    } finally {\n      if (buffer.isEmpty()) {\n        // settle promise in the microtask queue to give consumers a chance to\n        // await after calling .push\n        queueMicrotask(() => {\n          drain.resolve()\n          drain = deferred()\n        })\n      }\n    }\n  }\n\n  const bufferNext = (next: Next<PushType>): ReturnType => {\n    if (onNext != null) {\n      return onNext(next)\n    }\n\n    buffer.push(next)\n    return pushable\n  }\n\n  const bufferError = (err: Error): ReturnType => {\n    buffer = new FIFO()\n\n    if (onNext != null) {\n      return onNext({ error: err })\n    }\n\n    buffer.push({ error: err })\n    return pushable\n  }\n\n  const push = (value: PushType): ReturnType => {\n    if (ended) {\n      return pushable\n    }\n\n    // @ts-expect-error `byteLength` is not declared on PushType\n    if (options?.objectMode !== true && value?.byteLength == null) {\n      throw new Error('objectMode was not true but tried to push non-Uint8Array value')\n    }\n\n    return bufferNext({ done: false, value })\n  }\n  const end = (err?: Error): ReturnType => {\n    if (ended) return pushable\n    ended = true\n\n    return (err != null) ? bufferError(err) : bufferNext({ done: true })\n  }\n  const _return = (): DoneResult => {\n    buffer = new FIFO()\n    end()\n\n    return { done: true }\n  }\n  const _throw = (err: Error): DoneResult => {\n    end(err)\n\n    return { done: true }\n  }\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next: waitNext,\n    return: _return,\n    throw: _throw,\n    push,\n    end,\n    get readableLength (): number {\n      return buffer.size\n    },\n    onEmpty: async (options?: AbortOptions) => {\n      const signal = options?.signal\n      signal?.throwIfAborted()\n\n      if (buffer.isEmpty()) {\n        return\n      }\n\n      let cancel: Promise<void> | undefined\n      let listener: (() => void) | undefined\n\n      if (signal != null) {\n        cancel = new Promise((resolve, reject) => {\n          listener = () => {\n            reject(new AbortError())\n          }\n\n          signal.addEventListener('abort', listener)\n        })\n      }\n\n      try {\n        await Promise.race([\n          drain.promise,\n          cancel\n        ])\n      } finally {\n        if (listener != null && signal != null) {\n          signal?.removeEventListener('abort', listener)\n        }\n      }\n    }\n  }\n\n  if (onEnd == null) {\n    return pushable\n  }\n\n  const _pushable = pushable\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next () {\n      return _pushable.next()\n    },\n    throw (err: Error) {\n      _pushable.throw(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    return () {\n      _pushable.return()\n\n      if (onEnd != null) {\n        onEnd()\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    push,\n    end (err: Error) {\n      _pushable.end(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return pushable\n    },\n    get readableLength () {\n      return _pushable.readableLength\n    },\n    onEmpty: (opts?: AbortOptions) => {\n      return _pushable.onEmpty(opts)\n    }\n  }\n\n  return pushable\n}\n", "export class TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\n/**\nAn error to be thrown when the request is aborted by AbortController.\nDOMException is thrown instead of this Error when DOMException is available.\n*/\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\n/**\nTODO: Remove AbortError and just throw DOMException when targeting Node 18.\n*/\nconst getDOMException = errorMessage => globalThis.DOMException === undefined\n\t? new AbortError(errorMessage)\n\t: new DOMException(errorMessage);\n\n/**\nTODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.\n*/\nconst getAbortedReason = signal => {\n\tconst reason = signal.reason === undefined\n\t\t? getDOMException('This operation was aborted.')\n\t\t: signal.reason;\n\n\treturn reason instanceof Error ? reason : getDOMException(reason);\n};\n\nexport default function pTimeout(promise, options) {\n\tconst {\n\t\tmilliseconds,\n\t\tfallback,\n\t\tmessage,\n\t\tcustomTimers = {setTimeout, clearTimeout},\n\t} = options;\n\n\tlet timer;\n\tlet abortHandler;\n\n\tconst wrappedPromise = new Promise((resolve, reject) => {\n\t\tif (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n\t\t\tthrow new TypeError(`Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``);\n\t\t}\n\n\t\tif (options.signal) {\n\t\t\tconst {signal} = options;\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t}\n\n\t\t\tabortHandler = () => {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t};\n\n\t\t\tsignal.addEventListener('abort', abortHandler, {once: true});\n\t\t}\n\n\t\tif (milliseconds === Number.POSITIVE_INFINITY) {\n\t\t\tpromise.then(resolve, reject);\n\t\t\treturn;\n\t\t}\n\n\t\t// We create the error outside of `setTimeout` to preserve the stack trace.\n\t\tconst timeoutError = new TimeoutError();\n\n\t\ttimer = customTimers.setTimeout.call(undefined, () => {\n\t\t\tif (fallback) {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(fallback());\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\n\t\t\tif (message === false) {\n\t\t\t\tresolve();\n\t\t\t} else if (message instanceof Error) {\n\t\t\t\treject(message);\n\t\t\t} else {\n\t\t\t\ttimeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;\n\t\t\t\treject(timeoutError);\n\t\t\t}\n\t\t}, milliseconds);\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tresolve(await promise);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t})();\n\t});\n\n\tconst cancelablePromise = wrappedPromise.finally(() => {\n\t\tcancelablePromise.clear();\n\t\tif (abortHandler && options.signal) {\n\t\t\toptions.signal.removeEventListener('abort', abortHandler);\n\t\t}\n\t});\n\n\tcancelablePromise.clear = () => {\n\t\tcustomTimers.clearTimeout.call(undefined, timer);\n\t\ttimer = undefined;\n\t};\n\n\treturn cancelablePromise;\n}\n", "import pTimeout from 'p-timeout';\n\nconst normalizeEmitter = emitter => {\n\tconst addListener = emitter.addEventListener || emitter.on || emitter.addListener;\n\tconst removeListener = emitter.removeEventListener || emitter.off || emitter.removeListener;\n\n\tif (!addListener || !removeListener) {\n\t\tthrow new TypeError('Emitter is not compatible');\n\t}\n\n\treturn {\n\t\taddListener: addListener.bind(emitter),\n\t\tremoveListener: removeListener.bind(emitter),\n\t};\n};\n\nexport function pEventMultiple(emitter, event, options) {\n\tlet cancel;\n\tconst returnValue = new Promise((resolve, reject) => {\n\t\toptions = {\n\t\t\trejectionEvents: ['error'],\n\t\t\tmultiArgs: false,\n\t\t\trejectionMultiArgs: false,\n\t\t\tresolveImmediately: false,\n\t\t\t...options,\n\t\t};\n\n\t\tif (!(options.count >= 0 && (options.count === Number.POSITIVE_INFINITY || Number.isInteger(options.count)))) {\n\t\t\tthrow new TypeError('The `count` option should be at least 0 or more');\n\t\t}\n\n\t\toptions.signal?.throwIfAborted();\n\n\t\t// Allow multiple events\n\t\tconst events = [event].flat();\n\n\t\tconst items = [];\n\t\tconst {addListener, removeListener} = normalizeEmitter(emitter);\n\n\t\tconst onItem = async (...arguments_) => {\n\t\t\tconst value = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\t\tif (options.filter) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!(await options.filter(value))) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tcancel();\n\t\t\t\t\treject(error);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\titems.push(value);\n\n\t\t\tif (options.count === items.length) {\n\t\t\t\tcancel();\n\t\t\t\tresolve(items);\n\t\t\t}\n\t\t};\n\n\t\tconst rejectHandler = (...arguments_) => {\n\t\t\tcancel();\n\t\t\treject(options.rejectionMultiArgs ? arguments_ : arguments_[0]);\n\t\t};\n\n\t\tcancel = () => {\n\t\t\tfor (const event of events) {\n\t\t\t\tremoveListener(event, onItem);\n\t\t\t}\n\n\t\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\t\t// Only remove rejection handler if we actually registered it\n\t\t\t\tif (!events.includes(rejectionEvent)) {\n\t\t\t\t\tremoveListener(rejectionEvent, rejectHandler);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfor (const event of events) {\n\t\t\taddListener(event, onItem);\n\t\t}\n\n\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\t// Skip registering rejection handler if we're already listening to this event\n\t\t\t// as the main event takes priority (as documented)\n\t\t\tif (!events.includes(rejectionEvent)) {\n\t\t\t\taddListener(rejectionEvent, rejectHandler);\n\t\t\t}\n\t\t}\n\n\t\tif (options.signal) {\n\t\t\toptions.signal.addEventListener('abort', () => {\n\t\t\t\trejectHandler(options.signal.reason);\n\t\t\t}, {once: true});\n\t\t}\n\n\t\tif (options.resolveImmediately) {\n\t\t\tresolve(items);\n\t\t}\n\t});\n\n\treturnValue.cancel = cancel;\n\n\tif (typeof options.timeout === 'number') {\n\t\tconst timeout = pTimeout(returnValue, {milliseconds: options.timeout});\n\t\t// When cancelling, also clear the timeout timer\n\t\ttimeout.cancel = () => {\n\t\t\tcancel();\n\t\t\ttimeout.clear();\n\t\t};\n\n\t\treturn timeout;\n\t}\n\n\treturn returnValue;\n}\n\nexport function pEvent(emitter, event, options) {\n\tif (typeof options === 'function') {\n\t\toptions = {filter: options};\n\t}\n\n\toptions = {\n\t\t...options,\n\t\tcount: 1,\n\t\tresolveImmediately: false,\n\t};\n\n\tconst arrayPromise = pEventMultiple(emitter, event, options);\n\tconst promise = arrayPromise.then(array => array[0]); // eslint-disable-line promise/prefer-await-to-then\n\tpromise.cancel = arrayPromise.cancel;\n\n\treturn promise;\n}\n\nexport function pEventIterator(emitter, event, options) {\n\tif (typeof options === 'function') {\n\t\toptions = {filter: options};\n\t}\n\n\t// Allow multiple events\n\tconst events = [event].flat();\n\n\toptions = {\n\t\trejectionEvents: ['error'],\n\t\tresolutionEvents: [],\n\t\tlimit: Number.POSITIVE_INFINITY,\n\t\tmultiArgs: false,\n\t\trejectionMultiArgs: false,\n\t\t...options,\n\t};\n\n\tconst {limit} = options;\n\tconst isValidLimit = limit >= 0 && (limit === Number.POSITIVE_INFINITY || Number.isInteger(limit));\n\tif (!isValidLimit) {\n\t\tthrow new TypeError('The `limit` option should be a non-negative integer or Infinity');\n\t}\n\n\toptions.signal?.throwIfAborted();\n\n\tif (limit === 0) {\n\t\t// Return an empty async iterator to avoid any further cost\n\t\treturn {\n\t\t\t[Symbol.asyncIterator]() {\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tasync next() {\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t};\n\t\t\t},\n\t\t};\n\t}\n\n\tconst {addListener, removeListener} = normalizeEmitter(emitter);\n\n\tlet isDone = false;\n\tlet error;\n\tlet hasPendingError = false;\n\tconst nextQueue = [];\n\tconst valueQueue = [];\n\tlet eventCount = 0;\n\tlet isLimitReached = false;\n\n\tconst valueHandler = (...arguments_) => {\n\t\teventCount++;\n\t\tisLimitReached = eventCount === limit;\n\n\t\tconst value = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\n\t\t\tresolve({done: false, value});\n\n\t\t\tif (isLimitReached) {\n\t\t\t\tcancel();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalueQueue.push(value);\n\n\t\tif (isLimitReached) {\n\t\t\tcancel();\n\t\t}\n\t};\n\n\tconst cancel = () => {\n\t\tisDone = true;\n\n\t\tfor (const event of events) {\n\t\t\tremoveListener(event, valueHandler);\n\t\t}\n\n\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\tremoveListener(rejectionEvent, rejectHandler);\n\t\t}\n\n\t\tfor (const resolutionEvent of options.resolutionEvents) {\n\t\t\tremoveListener(resolutionEvent, resolveHandler);\n\t\t}\n\n\t\twhile (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\t\t\tresolve({done: true, value: undefined});\n\t\t}\n\t};\n\n\tconst rejectHandler = (...arguments_) => {\n\t\terror = options.rejectionMultiArgs ? arguments_ : arguments_[0];\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {reject} = nextQueue.shift();\n\t\t\treject(error);\n\t\t} else {\n\t\t\thasPendingError = true;\n\t\t}\n\n\t\tcancel();\n\t};\n\n\tconst resolveHandler = async (...arguments_) => {\n\t\tconst value = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\tif (options.filter) {\n\t\t\ttry {\n\t\t\t\tif (!(await options.filter(value))) {\n\t\t\t\t\tcancel();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} catch (filterError) {\n\t\t\t\tcancel();\n\t\t\t\tif (nextQueue.length > 0) {\n\t\t\t\t\tconst {reject} = nextQueue.shift();\n\t\t\t\t\treject(filterError);\n\t\t\t\t} else {\n\t\t\t\t\t// Store error for next iterator call\n\t\t\t\t\thasPendingError = true;\n\t\t\t\t\terror = filterError;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\t\t\tresolve({done: true, value});\n\t\t} else {\n\t\t\tvalueQueue.push(value);\n\t\t}\n\n\t\tcancel();\n\t};\n\n\tfor (const event of events) {\n\t\taddListener(event, valueHandler);\n\t}\n\n\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\taddListener(rejectionEvent, rejectHandler);\n\t}\n\n\tfor (const resolutionEvent of options.resolutionEvents) {\n\t\taddListener(resolutionEvent, resolveHandler);\n\t}\n\n\tif (options.signal) {\n\t\toptions.signal.addEventListener('abort', () => {\n\t\t\trejectHandler(options.signal.reason);\n\t\t}, {once: true});\n\t}\n\n\treturn {\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn this;\n\t\t},\n\t\tasync next() {\n\t\t\tif (valueQueue.length > 0) {\n\t\t\t\tconst value = valueQueue.shift();\n\t\t\t\treturn {\n\t\t\t\t\tdone: isDone && valueQueue.length === 0 && !isLimitReached,\n\t\t\t\t\tvalue,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (hasPendingError) {\n\t\t\t\thasPendingError = false;\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tif (isDone) {\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tnextQueue.push({resolve, reject});\n\t\t\t});\n\t\t},\n\t\tasync return(value) {\n\t\t\tcancel();\n\t\t\treturn {\n\t\t\t\tdone: isDone,\n\t\t\t\tvalue,\n\t\t\t};\n\t\t},\n\t};\n}\n\nexport {TimeoutError} from 'p-timeout';\n", "import type { Startable } from '@libp2p/interface'\n\nexport interface DebouncedFunction extends Startable {\n  (): void\n}\n\n/**\n * Returns a function wrapper that will only call the passed function once\n *\n * Important - the passed function should not throw or reject\n */\nexport function debounce (func: () => void | Promise<void>, wait: number): DebouncedFunction {\n  let timeout: ReturnType<typeof setTimeout> | undefined\n\n  const output = function (): void {\n    const later = function (): void {\n      timeout = undefined\n      void func()\n    }\n\n    clearTimeout(timeout)\n    timeout = setTimeout(later, wait)\n  }\n  output.start = (): void => {}\n  output.stop = (): void => {\n    clearTimeout(timeout)\n  }\n\n  return output\n}\n", "import type { RateLimiterResult } from './rate-limiter.js'\n\n/**\n * A rate limit was hit\n */\nexport class RateLimitError extends Error {\n  remainingPoints: number\n  msBeforeNext: number\n  consumedPoints: number\n  isFirstInDuration: boolean\n\n  constructor (message = 'Rate limit exceeded', props: RateLimiterResult) {\n    super(message)\n    this.name = 'RateLimitError'\n    this.remainingPoints = props.remainingPoints\n    this.msBeforeNext = props.msBeforeNext\n    this.consumedPoints = props.consumedPoints\n    this.isFirstInDuration = props.isFirstInDuration\n  }\n}\n\nexport class QueueFullError extends Error {\n  static name = 'QueueFullError'\n\n  constructor (message: string = 'The queue was full') {\n    super(message)\n    this.name = 'QueueFullError'\n  }\n}\n\nexport class UnexpectedEOFError extends Error {\n  static name = 'UnexpectedEOFError'\n  name = 'UnexpectedEOFError'\n}\n\nexport class MaxEarlyStreamsError extends Error {\n  static name = 'MaxEarlyStreamsError'\n  name = 'MaxEarlyStreamsError'\n}\n\nexport class StreamClosedError extends Error {\n  static name = 'StreamClosedError'\n  name = 'StreamClosedError'\n}\n", "/**\n * @packageDocumentation\n *\n * Pass a promise and an abort signal and await the result.\n *\n * @example Basic usage\n *\n * ```ts\n * import { raceSignal } from 'race-signal'\n *\n * const controller = new AbortController()\n *\n * const promise = new Promise((resolve, reject) => {\n *   setTimeout(() => {\n *     resolve('a value')\n *   }, 1000)\n * })\n *\n * setTimeout(() => {\n *   controller.abort()\n * }, 500)\n *\n * // throws an AbortError\n * const resolve = await raceSignal(promise, controller.signal)\n * ```\n *\n * @example Overriding errors\n *\n * By default the thrown error is the `.reason` property of the signal but it's\n * possible to override this behaviour with the `translateError` option:\n *\n * ```ts\n * import { raceSignal } from 'race-signal'\n *\n * const controller = new AbortController()\n *\n * const promise = new Promise((resolve, reject) => {\n *   setTimeout(() => {\n *     resolve('a value')\n *   }, 1000)\n * })\n *\n * setTimeout(() => {\n *   controller.abort()\n * }, 500)\n *\n * // throws `Error('Oh no!')`\n * const resolve = await raceSignal(promise, controller.signal, {\n *   translateError: (signal) => {\n *     // use `signal`, or don't\n *     return new Error('Oh no!')\n *   }\n * })\n * ```\n */\n\nexport interface RaceSignalOptions {\n  /**\n   * By default the rejection reason will be taken from the `.reason` field of\n   * the aborted signal.\n   *\n   * Passing a function here allows overriding the default error.\n   */\n  translateError?(signal: AbortSignal): Error\n}\n\nfunction defaultTranslate (signal: AbortSignal): Error {\n  return signal.reason\n}\n\n/**\n * Race a promise against an abort signal\n */\nexport async function raceSignal <T> (promise: Promise<T>, signal?: AbortSignal, opts?: RaceSignalOptions): Promise<T> {\n  if (signal == null) {\n    return promise\n  }\n\n  const translateError = opts?.translateError ?? defaultTranslate\n\n  if (signal.aborted) {\n    // the passed promise may yet resolve or reject but the use has signalled\n    // they are no longer interested so smother the error\n    promise.catch(() => {})\n    return Promise.reject(translateError(signal))\n  }\n\n  let listener\n\n  try {\n    return await Promise.race([\n      promise,\n      new Promise<T>((resolve, reject) => {\n        listener = () => {\n          reject(translateError(signal))\n        }\n        signal.addEventListener('abort', listener)\n      })\n    ])\n  } finally {\n    if (listener != null) {\n      signal.removeEventListener('abort', listener)\n    }\n  }\n}\n", "import { StreamResetError, TypedEventEmitter, StreamMessageEvent, StreamBufferError, StreamResetEvent, StreamAbortEvent, StreamCloseEvent, StreamStateError } from '@libp2p/interface'\nimport { pushable } from 'it-pushable'\nimport { raceSignal } from 'race-signal'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { StreamClosedError } from './errors.ts'\nimport type { MessageStreamEvents, MessageStreamStatus, MessageStream, AbortOptions, MessageStreamTimeline, MessageStreamDirection, EventHandler, StreamOptions, MessageStreamReadStatus, MessageStreamWriteStatus } from '@libp2p/interface'\nimport type { Logger } from '@libp2p/logger'\n\nconst DEFAULT_MAX_READ_BUFFER_LENGTH = Math.pow(2, 20) * 4 // 4MB\n\nexport interface MessageStreamInit extends StreamOptions {\n  /**\n   * A Logger implementation used to log stream-specific information\n   */\n  log: Logger\n\n  /**\n   * The stream direction\n   */\n  direction?: MessageStreamDirection\n\n  /**\n   * By default all available bytes are passed to the `sendData` method of\n   * extending classes, if smaller chunks are required, pass a value here.\n   */\n  maxMessageSize?: number\n}\n\nexport interface SendResult {\n  /**\n   * The number of bytes from the passed buffer that were sent\n   */\n  sentBytes: number\n\n  /**\n   * If the underlying resource can accept more data immediately. If `true`,\n   * `sent` must equal the `.byteLength` of the buffer passed to `sendData`.\n   */\n  canSendMore: boolean\n}\n\nexport abstract class AbstractMessageStream<Timeline extends MessageStreamTimeline = MessageStreamTimeline> extends TypedEventEmitter<MessageStreamEvents> implements MessageStream {\n  public status: MessageStreamStatus\n  public readonly timeline: Timeline\n  public inactivityTimeout: number\n  public maxReadBufferLength: number\n  public maxWriteBufferLength?: number\n  public readonly log: Logger\n  public direction: MessageStreamDirection\n  public maxMessageSize?: number\n\n  public readStatus: MessageStreamReadStatus\n  public writeStatus: MessageStreamWriteStatus\n  public remoteReadStatus: MessageStreamReadStatus\n  public remoteWriteStatus: MessageStreamWriteStatus\n\n  public writableNeedsDrain: boolean\n\n  /**\n   * Any data stored here is emitted before any new incoming data.\n   *\n   * This is used when the stream is paused or if data is pushed onto the stream\n   */\n  protected readonly readBuffer: Uint8ArrayList\n  protected readonly writeBuffer: Uint8ArrayList\n  protected sendingData: boolean\n\n  private onDrainPromise?: PromiseWithResolvers<void>\n\n  constructor (init: MessageStreamInit) {\n    super()\n\n    this.status = 'open'\n    this.log = init.log\n    this.direction = init.direction ?? 'outbound'\n    this.inactivityTimeout = init.inactivityTimeout ?? 120_000\n    this.maxReadBufferLength = init.maxReadBufferLength ?? DEFAULT_MAX_READ_BUFFER_LENGTH\n    this.maxWriteBufferLength = init.maxWriteBufferLength\n    this.maxMessageSize = init.maxMessageSize\n    this.readBuffer = new Uint8ArrayList()\n    this.writeBuffer = new Uint8ArrayList()\n\n    this.readStatus = 'readable'\n    this.remoteReadStatus = 'readable'\n    this.writeStatus = 'writable'\n    this.remoteWriteStatus = 'writable'\n    this.sendingData = false\n    this.writableNeedsDrain = false\n\n    // @ts-expect-error type could have required fields other than 'open'\n    this.timeline = {\n      open: Date.now()\n    }\n\n    this.processSendQueue = this.processSendQueue.bind(this)\n\n    const continueSendingOnDrain = (): void => {\n      if (this.writableNeedsDrain) {\n        this.log.trace('drain event received, continue sending data')\n        this.writableNeedsDrain = false\n        this.processSendQueue()\n      }\n\n      this.onDrainPromise?.resolve()\n    }\n    this.addEventListener('drain', continueSendingOnDrain)\n\n    const rejectOnDrainOnClose = (evt: StreamCloseEvent): void => {\n      this.onDrainPromise?.reject(evt.error ?? new StreamClosedError())\n    }\n    this.addEventListener('close', rejectOnDrainOnClose)\n  }\n\n  get readBufferLength (): number {\n    return this.readBuffer.byteLength\n  }\n\n  get writeBufferLength (): number {\n    return this.writeBuffer.byteLength\n  }\n\n  async onDrain (options?: AbortOptions): Promise<void> {\n    if (this.writableNeedsDrain !== true) {\n      return Promise.resolve()\n    }\n\n    if (this.onDrainPromise == null) {\n      this.onDrainPromise = Promise.withResolvers()\n    }\n\n    return raceSignal(this.onDrainPromise.promise, options?.signal)\n  }\n\n  async * [Symbol.asyncIterator] (): AsyncGenerator<Uint8Array | Uint8ArrayList> {\n    if (this.readStatus !== 'readable' && this.readStatus !== 'paused') {\n      return\n    }\n\n    const output = pushable<Uint8Array | Uint8ArrayList>()\n\n    const streamAsyncIterableOnMessageListener = (evt: StreamMessageEvent): void => {\n      output.push(evt.data)\n    }\n    this.addEventListener('message', streamAsyncIterableOnMessageListener)\n\n    const streamAsyncIterableOnCloseListener = (evt: StreamCloseEvent): void => {\n      output.end(evt.error)\n    }\n    this.addEventListener('close', streamAsyncIterableOnCloseListener)\n\n    const streamAsyncIterableOnRemoteCloseWriteListener = (): void => {\n      output.end()\n    }\n    this.addEventListener('remoteCloseWrite', streamAsyncIterableOnRemoteCloseWriteListener)\n\n    try {\n      yield * output\n    } finally {\n      this.removeEventListener('message', streamAsyncIterableOnMessageListener)\n      this.removeEventListener('close', streamAsyncIterableOnCloseListener)\n      this.removeEventListener('remoteCloseWrite', streamAsyncIterableOnRemoteCloseWriteListener)\n    }\n  }\n\n  isReadable (): boolean {\n    return this.status === 'open'\n  }\n\n  send (data: Uint8Array | Uint8ArrayList): boolean {\n    if (this.writeStatus === 'closed' || this.writeStatus === 'closing') {\n      throw new StreamStateError(`Cannot write to a stream that is ${this.writeStatus}`)\n    }\n\n    this.log.trace('append %d bytes to write buffer', data.byteLength)\n    this.writeBuffer.append(data)\n\n    return this.processSendQueue()\n  }\n\n  /**\n   * Close immediately for reading and writing and send a reset message (local\n   * error)\n   */\n  abort (err: Error): void {\n    if (this.status === 'aborted' || this.status === 'reset' || this.status === 'closed') {\n      return\n    }\n\n    this.log.error('abort with error - %e', err)\n\n    this.status = 'aborted'\n\n    // throw away unread data\n    if (this.readBuffer.byteLength > 0) {\n      this.readBuffer.consume(this.readBuffer.byteLength)\n    }\n\n    // throw away unsent data\n    if (this.writeBuffer.byteLength > 0) {\n      this.writeBuffer.consume(this.writeBuffer.byteLength)\n      this.safeDispatchEvent('idle')\n    }\n\n    this.writeStatus = 'closed'\n    this.remoteWriteStatus = 'closed'\n\n    this.readStatus = 'closed'\n    this.remoteReadStatus = 'closed'\n    this.timeline.close = Date.now()\n\n    try {\n      this.sendReset(err)\n    } catch (err: any) {\n      this.log('failed to send reset to remote - %e', err)\n    }\n\n    this.dispatchEvent(new StreamAbortEvent(err))\n  }\n\n  pause (): void {\n    if (this.readStatus === 'closed' || this.readStatus === 'closing') {\n      throw new StreamStateError('Cannot pause a stream that is closing/closed')\n    }\n\n    if (this.readStatus === 'paused') {\n      return\n    }\n\n    this.readStatus = 'paused'\n    this.sendPause()\n  }\n\n  resume (): void {\n    if (this.readStatus === 'closed' || this.readStatus === 'closing') {\n      throw new StreamStateError('Cannot resume a stream that is closing/closed')\n    }\n\n    if (this.readStatus === 'readable') {\n      return\n    }\n\n    this.readStatus = 'readable'\n    // emit any data that accumulated while we were paused\n    this.dispatchReadBuffer()\n    this.sendResume()\n  }\n\n  push (data: Uint8Array | Uint8ArrayList): void {\n    if (this.readStatus === 'closed' || this.readStatus === 'closing') {\n      throw new StreamStateError(`Cannot push data onto a stream that is ${this.readStatus}`)\n    }\n\n    if (data.byteLength === 0) {\n      return\n    }\n\n    this.readBuffer.append(data)\n\n    if (this.readStatus === 'paused' || this.listenerCount('message') === 0) {\n      // abort if the read buffer is too large\n      this.checkReadBufferLength()\n\n      return\n    }\n\n    // TODO: use a microtask instead?\n    setTimeout(() => {\n      this.dispatchReadBuffer()\n    }, 0)\n  }\n\n  unshift (data: Uint8Array | Uint8ArrayList): void {\n    if (this.readStatus === 'closed' || this.readStatus === 'closing') {\n      throw new StreamStateError(`Cannot push data onto a stream that is ${this.readStatus}`)\n    }\n\n    if (data.byteLength === 0) {\n      return\n    }\n\n    this.readBuffer.prepend(data)\n\n    if (this.readStatus === 'paused' || this.listenerCount('message') === 0) {\n      // abort if the read buffer is too large\n      this.checkReadBufferLength()\n\n      return\n    }\n\n    // TODO: use a microtask instead?\n    setTimeout(() => {\n      this.dispatchReadBuffer()\n    }, 0)\n  }\n\n  /**\n   * When an extending class reads data from it's implementation-specific source,\n   * call this method to allow the stream consumer to read the data.\n   */\n  onData (data: Uint8Array | Uint8ArrayList): void {\n    if (data.byteLength === 0) {\n      // this.log('ignoring empty data')\n      return\n    }\n\n    // discard the data if our readable end is closed\n    if (this.readStatus === 'closing' || this.readStatus === 'closed') {\n      this.log('ignoring data - read status %s', this.readStatus)\n      return\n    }\n\n    this.readBuffer.append(data)\n    this.dispatchReadBuffer()\n  }\n\n  addEventListener<K extends keyof MessageStreamEvents>(type: K, listener: EventHandler<MessageStreamEvents[K]> | null, options?: boolean | AddEventListenerOptions): void\n  addEventListener (type: string, listener: EventHandler<Event>, options?: boolean | AddEventListenerOptions): void\n  addEventListener (...args: any[]): void {\n    // @ts-expect-error cannot ensure args has enough members\n    super.addEventListener.apply(this, args)\n\n    // if a 'message' listener is being added and we have queued data, dispatch\n    // the data\n    if (args[0] === 'message' && this.readBuffer.byteLength > 0) {\n      // event listeners can be added in constructors and often use object\n      // properties - if this the case we can access a class member before it\n      // has been initialized so dispatch the message in the microtask queue\n      queueMicrotask(() => {\n        this.dispatchReadBuffer()\n      })\n    }\n  }\n\n  /**\n   * Receive a reset message - close immediately for reading and writing (remote\n   * error)\n   */\n  onRemoteReset (): void {\n    this.log('remote reset')\n\n    this.status = 'reset'\n    this.writeStatus = 'closed'\n    this.remoteWriteStatus = 'closed'\n    this.remoteReadStatus = 'closed'\n    this.timeline.close = Date.now()\n\n    if (this.readBuffer.byteLength === 0) {\n      this.readStatus = 'closed'\n    }\n\n    const err = new StreamResetError()\n    this.dispatchEvent(new StreamResetEvent(err))\n  }\n\n  /**\n   * The underlying resource or transport this stream uses has closed - it is\n   * not possible to send any more messages though any data still in the read\n   * buffer may still be read\n   */\n  onTransportClosed (err?: Error): void {\n    this.log('transport closed')\n\n    if (this.readStatus === 'readable' && this.readBuffer.byteLength === 0) {\n      this.log('close readable end after transport closed and read buffer is empty')\n      this.readStatus = 'closed'\n    }\n\n    if (this.remoteReadStatus !== 'closed') {\n      this.remoteReadStatus = 'closed'\n    }\n\n    if (this.remoteWriteStatus !== 'closed') {\n      this.remoteWriteStatus = 'closed'\n    }\n\n    if (this.writeStatus !== 'closed') {\n      this.writeStatus = 'closed'\n    }\n\n    if (err != null) {\n      this.abort(err)\n    } else {\n      if (this.status === 'open' || this.status === 'closing') {\n        this.timeline.close = Date.now()\n        this.status = 'closed'\n        this.writeStatus = 'closed'\n        this.remoteWriteStatus = 'closed'\n        this.remoteReadStatus = 'closed'\n        this.dispatchEvent(new StreamCloseEvent())\n      }\n    }\n  }\n\n  /**\n   * Called by extending classes when the remote closes its writable end\n   */\n  onRemoteCloseWrite (): void {\n    if (this.remoteWriteStatus === 'closed') {\n      return\n    }\n\n    this.log.trace('on remote close write')\n\n    this.remoteWriteStatus = 'closed'\n\n    this.safeDispatchEvent('remoteCloseWrite')\n\n    if (this.writeStatus === 'closed') {\n      this.onTransportClosed()\n    }\n  }\n\n  /**\n   * Called by extending classes when the remote closes its readable end\n   */\n  onRemoteCloseRead (): void {\n    this.log.trace('on remote close read')\n\n    this.remoteReadStatus = 'closed'\n\n    // throw away any unsent bytes if the remote closes it's readable end\n    if (this.writeBuffer.byteLength > 0) {\n      this.writeBuffer.consume(this.writeBuffer.byteLength)\n      this.safeDispatchEvent('idle')\n    }\n  }\n\n  protected processSendQueue (): boolean {\n    // bail if the underlying transport is full\n    if (this.writableNeedsDrain) {\n      this.log.trace('not processing send queue as drain is required')\n      this.checkWriteBufferLength()\n\n      return false\n    }\n\n    // bail if there is no data to send\n    if (this.writeBuffer.byteLength === 0) {\n      this.log.trace('not processing send queue as no bytes to send')\n      return true\n    }\n\n    // bail if we are already sending data\n    if (this.sendingData) {\n      this.log.trace('not processing send queue as already sending data')\n      return true\n    }\n\n    this.sendingData = true\n\n    this.log.trace('processing send queue with %d queued bytes', this.writeBuffer.byteLength)\n\n    try {\n      let canSendMore = true\n      const totalBytes = this.writeBuffer.byteLength\n      let sentBytes = 0\n\n      // send as much data as possible while we have data to send and the\n      // underlying muxer can still accept data\n      while (this.writeBuffer.byteLength > 0) {\n        const end = Math.min(this.maxMessageSize ?? this.writeBuffer.byteLength, this.writeBuffer.byteLength)\n\n        // this can happen if a subclass changes the max message size dynamically\n        if (end === 0) {\n          canSendMore = false\n          break\n        }\n\n        // chunk to send to the remote end\n        const toSend = this.writeBuffer.sublist(0, end)\n\n        // copy toSend in case the extending class modifies the list\n        const willSend = new Uint8ArrayList(toSend)\n\n        this.writeBuffer.consume(toSend.byteLength)\n\n        // sending data can cause buffers to fill up, events to be emitted and\n        // this method to be invoked again\n        const sendResult = this.sendData(toSend)\n        canSendMore = sendResult.canSendMore\n        sentBytes += sendResult.sentBytes\n\n        if (sendResult.sentBytes !== willSend.byteLength) {\n          willSend.consume(sendResult.sentBytes)\n          this.writeBuffer.prepend(willSend)\n        }\n\n        if (!canSendMore) {\n          break\n        }\n      }\n\n      if (!canSendMore) {\n        this.log.trace('sent %d/%d bytes, pausing sending because underlying stream is full, %d bytes left in the write buffer', sentBytes, totalBytes, this.writeBuffer.byteLength)\n        this.writableNeedsDrain = true\n        this.checkWriteBufferLength()\n      }\n\n      // we processed all bytes in the queue, resolve the write queue idle promise\n      if (this.writeBuffer.byteLength === 0) {\n        this.safeDispatchEvent('idle')\n      }\n\n      return canSendMore\n    } finally {\n      this.sendingData = false\n    }\n  }\n\n  protected dispatchReadBuffer (): void {\n    try {\n      if (this.listenerCount('message') === 0) {\n        this.log.trace('not dispatching pause buffer as there are no listeners for the message event')\n        return\n      }\n\n      if (this.readBuffer.byteLength === 0) {\n        this.log.trace('not dispatching pause buffer as there is no data to dispatch')\n        return\n      }\n\n      if (this.readStatus === 'paused') {\n        this.log.trace('not dispatching pause buffer we are paused')\n        return\n      }\n\n      // discard the pause buffer if our readable end is closed\n      if (this.readStatus === 'closing' || this.readStatus === 'closed') {\n        this.log('dropping %d bytes because the readable end is %s', this.readBuffer.byteLength, this.readStatus)\n        this.readBuffer.consume(this.readBuffer.byteLength)\n        return\n      }\n\n      const buf = this.readBuffer.sublist()\n      this.readBuffer.consume(buf.byteLength)\n\n      this.dispatchEvent(new StreamMessageEvent(buf))\n    } finally {\n      if (this.readBuffer.byteLength === 0 && this.remoteWriteStatus === 'closed') {\n        this.log('close readable end after dispatching read buffer and remote writable end is closed')\n        this.readStatus = 'closed'\n      }\n\n      // abort if we failed to consume the read buffer and it is too large\n      this.checkReadBufferLength()\n    }\n  }\n\n  private checkReadBufferLength (): void {\n    if (this.readBuffer.byteLength > this.maxReadBufferLength) {\n      this.abort(new StreamBufferError(`Read buffer length of ${this.readBuffer.byteLength} exceeded limit of ${this.maxReadBufferLength}, read status is ${this.readStatus}`))\n    }\n  }\n\n  private checkWriteBufferLength (): void {\n    if (this.maxWriteBufferLength == null) {\n      return\n    }\n\n    if (this.writeBuffer.byteLength > this.maxWriteBufferLength) {\n      this.abort(new StreamBufferError(`Write buffer length of ${this.writeBuffer.byteLength} exceeded limit of ${this.maxWriteBufferLength}, write status is ${this.writeStatus}`))\n    }\n  }\n\n  public onMuxerNeedsDrain (): void {\n    this.writableNeedsDrain = true\n  }\n\n  public onMuxerDrain (): void {\n    this.safeDispatchEvent('drain')\n  }\n\n  /**\n   * Send a data message to the remote end of the stream. Implementations of\n   * this method should return the number of bytes from the passed buffer that\n   * were sent successfully and if the underlying resource can accept more data.\n   *\n   * The implementation should always attempt to send the maximum amount of data\n   * possible.\n   *\n   * Returning a result that means the data was only partially sent but that the\n   * underlying resource can accept more data is invalid.\n   */\n  abstract sendData (data: Uint8ArrayList): SendResult\n\n  /**\n   * Send a reset message to the remote end of the stream\n   */\n  abstract sendReset (err: Error): void\n\n  /**\n   * If supported, instruct the remote end of the stream to temporarily stop\n   * sending data messages\n   */\n  abstract sendPause (): void\n\n  /**\n   * If supported, inform the remote end of the stream they may resume sending\n   * data messages\n   */\n  abstract sendResume (): void\n\n  /**\n   * Stop accepting new data to send and return a promise that resolves when any\n   * unsent data has been written into the underlying resource.\n   */\n  abstract close (options?: AbortOptions): Promise<void>\n}\n", "export function isPromise <T = unknown> (thing: any): thing is Promise<T> {\n  if (thing == null) {\n    return false\n  }\n\n  return typeof thing.then === 'function' &&\n    typeof thing.catch === 'function' &&\n    typeof thing.finally === 'function'\n}\n", "import { MuxerClosedError, TypedEventEmitter } from '@libp2p/interface'\nimport { raceSignal } from 'race-signal'\nimport { MaxEarlyStreamsError } from './errors.ts'\nimport { isPromise } from './is-promise.ts'\nimport type { AbstractStream } from './abstract-stream.ts'\nimport type { AbortOptions, CounterGroup, CreateStreamOptions, EventHandler, Logger, MessageStream, Stream, StreamCloseEvent, StreamMessageEvent, StreamMuxer, StreamMuxerEvents, StreamMuxerOptions, StreamMuxerStatus, StreamOptions } from '@libp2p/interface'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface AbstractStreamMuxerInit extends StreamMuxerOptions {\n  /**\n   * The protocol name for the muxer\n   */\n  protocol: string\n\n  /**\n   * The name of the muxer, used to create a new logging scope from the passed\n   * connection's logger\n   */\n  name: string\n\n  /**\n   * A counter for muxer metrics\n   */\n  metrics?: CounterGroup\n}\n\nexport abstract class AbstractStreamMuxer <MuxedStream extends AbstractStream = AbstractStream> extends TypedEventEmitter<StreamMuxerEvents<MuxedStream>> implements StreamMuxer<MuxedStream> {\n  public streams: MuxedStream[]\n  public protocol: string\n  public status: StreamMuxerStatus\n\n  protected log: Logger\n  protected maConn: MessageStream\n  protected streamOptions?: StreamOptions\n  protected earlyStreams: MuxedStream[]\n  protected maxEarlyStreams: number\n\n  private readonly metrics?: CounterGroup\n\n  constructor (maConn: MessageStream, init: AbstractStreamMuxerInit) {\n    super()\n\n    this.maConn = maConn\n    this.protocol = init.protocol\n    this.streams = []\n    this.earlyStreams = []\n    this.status = 'open'\n    this.log = maConn.log.newScope(init.name)\n    this.streamOptions = init.streamOptions\n    this.maxEarlyStreams = init.maxEarlyStreams ?? 10\n    this.metrics = init.metrics\n\n    // read/write all data from/to underlying maConn\n    const muxerMaConnOnMessage = (evt: StreamMessageEvent): void => {\n      try {\n        this.onData(evt.data)\n      } catch (err: any) {\n        this.abort(err)\n        this.maConn.abort(err)\n      }\n    }\n    this.maConn.addEventListener('message', muxerMaConnOnMessage)\n\n    // signal stream writers when the underlying connection can accept more data\n    const muxerMaConnOnDrain = (): void => {\n      this.log('underlying stream drained, signal %d streams to continue writing', this.streams.length)\n\n      this.streams.forEach(stream => {\n        stream.onMuxerDrain()\n      })\n    }\n    this.maConn.addEventListener('drain', muxerMaConnOnDrain)\n\n    const muxerOnMaConnClose = (): void => {\n      this.log('underlying stream closed with status %s and %d streams', this.status, this.streams.length)\n      this.onTransportClosed()\n    }\n    this.maConn.addEventListener('close', muxerOnMaConnClose)\n  }\n\n  send (data: Uint8Array | Uint8ArrayList): boolean {\n    const result = this.maConn.send(data)\n\n    if (result === false) {\n      this.log('underlying stream saturated, signal %d streams to pause writing', this.streams.length)\n\n      this.streams.forEach(stream => {\n        stream.onMuxerNeedsDrain()\n      })\n    }\n\n    return result\n  }\n\n  async close (options?: AbortOptions): Promise<void> {\n    if (this.status === 'closed' || this.status === 'closing') {\n      return\n    }\n\n    this.status = 'closing'\n\n    await raceSignal(Promise.all(\n      [...this.streams].map(async s => {\n        await s.close(options)\n      })\n    ), options?.signal)\n\n    this.status = 'closed'\n  }\n\n  abort (err: Error): void {\n    if (this.status === 'closed') {\n      return\n    }\n\n    this.status = 'closing'\n\n    ;[...this.streams].forEach(s => {\n      s.abort(err)\n    })\n\n    this.status = 'closed'\n  }\n\n  onTransportClosed (err?: Error): void {\n    this.status = 'closing'\n\n    try {\n      [...this.streams].forEach(stream => {\n        stream.onTransportClosed(err)\n      })\n    } catch (err: any) {\n      this.abort(err)\n    }\n\n    this.status = 'closed'\n  }\n\n  async createStream (options?: CreateStreamOptions): Promise<MuxedStream> {\n    if (this.status !== 'open') {\n      throw new MuxerClosedError()\n    }\n\n    let stream = this.onCreateStream({\n      ...this.streamOptions,\n      ...options\n    })\n\n    if (isPromise(stream)) {\n      stream = await stream\n    }\n\n    this.streams.push(stream)\n    this.cleanUpStream(stream)\n\n    return stream\n  }\n\n  /**\n   * Extending classes should invoke this method when a new stream was created\n   * by the remote muxer\n   */\n  onRemoteStream (stream: MuxedStream): void {\n    this.streams.push(stream)\n    this.cleanUpStream(stream)\n\n    if (this.listenerCount('stream') === 0) {\n      // no listener has been added for the stream event yet, store the stream\n      // to emit it later\n      this.earlyStreams.push(stream)\n\n      if (this.earlyStreams.length > this.maxEarlyStreams) {\n        this.abort(new MaxEarlyStreamsError(`Too many early streams were opened - ${this.earlyStreams.length}/${this.maxEarlyStreams}`))\n      }\n\n      return\n    }\n\n    this.safeDispatchEvent('stream', {\n      detail: stream\n    })\n  }\n\n  private cleanUpStream (stream: Stream): void {\n    const muxerOnStreamEnd = (evt: StreamCloseEvent): void => {\n      const index = this.streams.findIndex(s => s === stream)\n\n      if (index !== -1) {\n        this.streams.splice(index, 1)\n      }\n\n      if (evt.error != null) {\n        if (evt.local) {\n          this.metrics?.increment({ [`${stream.direction}_stream_reset`]: true })\n        } else {\n          this.metrics?.increment({ [`${stream.direction}_stream_abort`]: true })\n        }\n      } else {\n        this.metrics?.increment({ [`${stream.direction}_stream_end`]: true })\n      }\n    }\n    stream.addEventListener('close', muxerOnStreamEnd)\n\n    this.metrics?.increment({ [`${stream.direction}_stream`]: true })\n  }\n\n  addEventListener<K extends keyof StreamMuxerEvents<MuxedStream>>(type: K, listener: EventHandler<StreamMuxerEvents<MuxedStream>[K]> | null, options?: boolean | AddEventListenerOptions): void\n  addEventListener (type: string, listener: EventHandler<Event>, options?: boolean | AddEventListenerOptions): void\n  addEventListener (...args: any[]): void {\n    // @ts-expect-error cannot ensure args has enough members\n    super.addEventListener.apply(this, args)\n\n    // if a 'stream' listener is being added and we have early streams, emit\n    // them\n    if (args[0] === 'stream' && this.earlyStreams.length > 0) {\n      // event listeners can be added in constructors and often use object\n      // properties - if this the case we can access a class member before it\n      // has been initialized so dispatch the message in the microtask queue\n      queueMicrotask(() => {\n        this.earlyStreams.forEach(stream => {\n          this.safeDispatchEvent('stream', {\n            detail: stream\n          })\n        })\n        this.earlyStreams = []\n      })\n    }\n  }\n\n  /**\n   * A new outgoing stream needs to be created\n   */\n  abstract onCreateStream (options: CreateStreamOptions): MuxedStream | Promise<MuxedStream>\n\n  /**\n   * Multiplexed data was received from the remote muxer\n   */\n  abstract onData (data: Uint8Array | Uint8ArrayList): void\n}\n", "import { pEvent } from 'p-event'\nimport { AbstractMessageStream } from './abstract-message-stream.js'\nimport type { MessageStreamInit } from './abstract-message-stream.js'\nimport type { AbortOptions, Stream } from '@libp2p/interface'\n\nexport interface AbstractStreamInit extends MessageStreamInit {\n  /**\n   * A unique identifier for this stream\n   */\n  id: string\n\n  /**\n   * The protocol name for the stream, if it is known\n   */\n  protocol?: string\n}\n\nexport abstract class AbstractStream extends AbstractMessageStream implements Stream {\n  public id: string\n  public protocol: string\n\n  constructor (init: AbstractStreamInit) {\n    super(init)\n\n    this.id = init.id\n    this.protocol = init.protocol ?? ''\n  }\n\n  async close (options?: AbortOptions): Promise<void> {\n    if (this.writeStatus === 'closing' || this.writeStatus === 'closed') {\n      return\n    }\n\n    this.writeStatus = 'closing'\n\n    // if we are currently sending data, wait for all the data to be written\n    // into the underlying transport\n    if (this.sendingData || this.writeBuffer.byteLength > 0) {\n      this.log('waiting for write queue to become idle before closing writable end of stream, %d unsent bytes', this.writeBuffer.byteLength)\n      await pEvent(this, 'idle', {\n        ...options,\n        rejectionEvents: [\n          'close'\n        ]\n      })\n    }\n\n    // now that the underlying transport has all the data, if the buffer is full\n    // wait for it to be emptied\n    if (this.writableNeedsDrain) {\n      this.log('waiting for write queue to drain before closing writable end of stream, %d unsent bytes, sending %s', this.writeBuffer.byteLength, this.sendingData)\n      await pEvent(this, 'drain', {\n        ...options,\n        rejectionEvents: [\n          'close'\n        ]\n      })\n      this.log('write queue drained, closing writable end of stream, %d unsent bytes, sending %s', this.writeBuffer.byteLength, this.sendingData)\n    }\n\n    await this.sendCloseWrite(options)\n\n    this.writeStatus = 'closed'\n\n    this.log('closed writable end gracefully')\n\n    if (this.remoteWriteStatus === 'closed') {\n      this.onTransportClosed()\n    }\n  }\n\n  async closeRead (options?: AbortOptions): Promise<void> {\n    if (this.readStatus === 'closing' || this.readStatus === 'closed') {\n      return\n    }\n\n    // throw away any unread data\n    if (this.readBuffer.byteLength > 0) {\n      this.readBuffer.consume(this.readBuffer.byteLength)\n    }\n\n    this.readStatus = 'closing'\n\n    await this.sendCloseRead(options)\n\n    this.readStatus = 'closed'\n\n    this.log('closed readable end gracefully')\n  }\n\n  /**\n   * Send a message to the remote end of the stream, informing them that we will\n   * send no more data messages.\n   */\n  abstract sendCloseWrite (options?: AbortOptions): Promise<void>\n\n  /**\n   * If supported, send a message to the remote end of the stream, informing\n   * them that we will read no more data messages.\n   */\n  abstract sendCloseRead (options?: AbortOptions): Promise<void>\n}\n", "\nexport interface ClearableSignal extends AbortSignal {\n  clear: () => void\n}\n\n/**\n * Takes an array of AbortSignals and returns a single signal.\n * If any signals are aborted, the returned signal will be aborted.\n */\nexport function anySignal (signals: Array<AbortSignal | undefined | null>): ClearableSignal {\n  const controller = new globalThis.AbortController()\n\n  function onAbort (): void {\n    controller.abort()\n\n    for (const signal of signals) {\n      if (signal?.removeEventListener != null) {\n        signal.removeEventListener('abort', onAbort)\n      }\n    }\n  }\n\n  for (const signal of signals) {\n    if (signal?.aborted === true) {\n      onAbort()\n      break\n    }\n\n    if (signal?.addEventListener != null) {\n      signal.addEventListener('abort', onAbort)\n    }\n  }\n\n  function clear (): void {\n    for (const signal of signals) {\n      if (signal?.removeEventListener != null) {\n        signal.removeEventListener('abort', onAbort)\n      }\n    }\n  }\n\n  const signal = controller.signal as ClearableSignal\n  signal.clear = clear\n\n  return signal\n}\n", "import { anySignal } from 'any-signal'\nimport { setMaxListeners } from 'main-event'\nimport { debounce } from './debounce.ts'\nimport type { AbortOptions } from '@libp2p/interface'\n\nexport interface RepeatingTask {\n  /**\n   * Update the interval after which the next iteration of the task will run.\n   *\n   * This is useful if, for example, you want to retry a task with a short rest\n   * duration until it succeeds, then periodically after that.\n   *\n   * This only affects the next iteration of the task, if it is currently\n   * running, that run will not be interrupted.\n   *\n   * Setting the interval to the current value has no effect.\n   */\n  setInterval(ms: number): void\n\n  /**\n   * Update the amount of time a task will run before the passed abort signal\n   * will fire.\n   *\n   * This only affects the next iteration of the task, if it is currently\n   * running, that run will not be interrupted.\n   */\n  setTimeout(ms: number): void\n\n  /**\n   * Schedule the task to be run immediately - if the task is not running it\n   * will run after a short delay in order to debounce multiple `.run()`\n   * invocations.\n   */\n  run(): void\n\n  /**\n   * Start the task running\n   */\n  start(): void\n\n  /**\n   * Stop the task running\n   */\n  stop(): void\n}\n\nexport interface RepeatingTaskOptions {\n  /**\n   * How long the task is allowed to run before the passed AbortSignal fires an\n   * abort event\n   */\n  timeout?: number\n\n  /**\n   * Whether to schedule the task to run immediately\n   *\n   * @default false\n   */\n  runImmediately?: boolean\n\n  /**\n   * When `.run()` is called to run the task outside of the current interval,\n   * debounce repeated calls to `.run()` by this amount.\n   *\n   * @default 100\n   */\n  debounce?: number\n}\n\nexport function repeatingTask (fn: (options?: AbortOptions) => void | Promise<void>, interval: number, options?: RepeatingTaskOptions): RepeatingTask {\n  let timeout: ReturnType<typeof setTimeout>\n  let shutdownController: AbortController\n  let running = false\n\n  function runTask (): void {\n    const opts: AbortOptions = {\n      signal: shutdownController.signal\n    }\n\n    if (options?.timeout != null) {\n      const signal = anySignal([shutdownController.signal, AbortSignal.timeout(options.timeout)])\n      setMaxListeners(Infinity, signal)\n\n      opts.signal = signal\n    }\n\n    running = true\n\n    Promise.resolve().then(async () => {\n      await fn(opts)\n    })\n      .catch(() => {})\n      .finally(() => {\n        running = false\n\n        if (shutdownController.signal.aborted) {\n          // task has been cancelled, bail\n          return\n        }\n\n        // reschedule\n        timeout = setTimeout(runTask, interval)\n      })\n  }\n\n  const runTaskDebounced = debounce(runTask, options?.debounce ?? 100)\n\n  let started = false\n\n  return {\n    setInterval: (ms): void => {\n      if (interval === ms) {\n        // already running at this interval, nothing to do\n        return\n      }\n\n      interval = ms\n\n      // maybe reschedule\n      if (timeout != null) {\n        clearTimeout(timeout)\n        timeout = setTimeout(runTask, interval)\n      }\n    },\n    setTimeout: (ms): void => {\n      options ??= {}\n      options.timeout = ms\n    },\n    run: (): void => {\n      if (running) {\n        return\n      }\n\n      clearTimeout(timeout)\n      runTaskDebounced()\n    },\n    start: (): void => {\n      if (started) {\n        return\n      }\n\n      started = true\n      shutdownController = new AbortController()\n      setMaxListeners(Infinity, shutdownController.signal)\n\n      // run now\n      if (options?.runImmediately === true) {\n        queueMicrotask(() => {\n          runTask()\n        })\n      } else {\n        // run later\n        timeout = setTimeout(runTask, interval)\n      }\n    },\n    stop: (): void => {\n      clearTimeout(timeout)\n      shutdownController?.abort()\n      started = false\n    }\n  }\n}\n", "export enum FrameType {\n  /** Used to transmit data. May transmit zero length payloads depending on the flags. */\n  Data = 0x0,\n  /** Used to updated the senders receive window size. This is used to implement per-session flow control. */\n  WindowUpdate = 0x1,\n  /** Used to measure RTT. It can also be used to heart-beat and do keep-alive over TCP. */\n  Ping = 0x2,\n  /** Used to close a session. */\n  GoAway = 0x3\n}\n\nexport enum Flag {\n  /** Signals the start of a new stream. May be sent with a data or window update message. Also sent with a ping to indicate outbound. */\n  SYN = 0x1,\n  /** Acknowledges the start of a new stream. May be sent with a data or window update message. Also sent with a ping to indicate response. */\n  ACK = 0x2,\n  /** Performs a half-close of a stream. May be sent with a data message or window update. */\n  FIN = 0x4,\n  /** Reset a stream immediately. May be sent with a data or window update message. */\n  RST = 0x8\n}\n\nconst flagCodes = Object.values(Flag).filter((x) => typeof x !== 'string') as Flag[]\n\nexport const YAMUX_VERSION = 0\n\nexport enum GoAwayCode {\n  NormalTermination = 0x0,\n  ProtocolError = 0x1,\n  InternalError = 0x2\n}\n\nexport const HEADER_LENGTH = 12\n\nexport interface FrameHeader {\n  /**\n   * The version field is used for future backward compatibility.\n   * At the current time, the field is always set to 0, to indicate the initial version.\n   */\n  version?: number\n  /** The type field is used to switch the frame message type. */\n  type: FrameType\n  /** The flags field is used to provide additional information related to the message type. */\n  flag: number\n  /**\n   * The StreamID field is used to identify the logical stream the frame is addressing.\n   * The client side should use odd ID's, and the server even.\n   * This prevents any collisions. Additionally, the 0 ID is reserved to represent the session.\n   */\n  streamID: number\n  /**\n   * The meaning of the length field depends on the message type:\n   * Data - provides the length of bytes following the header\n   * Window update - provides a delta update to the window size\n   * Ping - Contains an opaque value, echoed back\n   * Go Away - Contains an error code\n   */\n  length: number\n}\n\nexport function stringifyHeader (header: FrameHeader): string {\n  const flags = flagCodes.filter(f => (header.flag & f) === f).map(f => Flag[f]).join('|')\n  return `streamID=${header.streamID} type=${FrameType[header.type]} flag=${flags} length=${header.length}`\n}\n", "import { GoAwayCode } from './frame.ts'\n\nexport class ProtocolError extends Error {\n  static name = 'ProtocolError'\n\n  public reason: GoAwayCode\n\n  constructor (message: string, reason: GoAwayCode) {\n    super(message)\n    this.name = 'ProtocolError'\n    this.reason = reason\n  }\n}\n\nexport function isProtocolError (err?: any): err is ProtocolError {\n  return err?.reason !== null\n}\n\nexport class InvalidFrameError extends ProtocolError {\n  static name = 'InvalidFrameError'\n\n  constructor (message = 'The frame was invalid') {\n    super(message, GoAwayCode.ProtocolError)\n    this.name = 'InvalidFrameError'\n  }\n}\n\nexport class UnRequestedPingError extends ProtocolError {\n  static name = 'UnRequestedPingError'\n\n  constructor (message = 'Un-requested ping error') {\n    super(message, GoAwayCode.ProtocolError)\n    this.name = 'UnRequestedPingError'\n  }\n}\n\nexport class NotMatchingPingError extends ProtocolError {\n  static name = 'NotMatchingPingError'\n\n  constructor (message = 'Not matching ping error') {\n    super(message, GoAwayCode.ProtocolError)\n    this.name = 'NotMatchingPingError'\n  }\n}\n\nexport class InvalidStateError extends Error {\n  static name = 'InvalidStateError'\n\n  constructor (message = 'Invalid state') {\n    super(message)\n    this.name = 'InvalidStateError'\n  }\n}\n\nexport class StreamAlreadyExistsError extends ProtocolError {\n  static name = 'StreamAlreadyExistsError'\n\n  constructor (message = 'Stream already exists') {\n    super(message, GoAwayCode.ProtocolError)\n    this.name = 'StreamAlreadyExistsError'\n  }\n}\n\nexport class DecodeInvalidVersionError extends ProtocolError {\n  static name = 'DecodeInvalidVersionError'\n\n  constructor (message = 'Decode invalid version') {\n    super(message, GoAwayCode.ProtocolError)\n    this.name = 'DecodeInvalidVersionError'\n  }\n}\n\nexport class BothClientsError extends ProtocolError {\n  static name = 'BothClientsError'\n\n  constructor (message = 'Both clients') {\n    super(message, GoAwayCode.ProtocolError)\n    this.name = 'BothClientsError'\n  }\n}\n\nexport class ReceiveWindowExceededError extends ProtocolError {\n  static name = 'ReceiveWindowExceededError'\n\n  constructor (message = 'Receive window exceeded') {\n    super(message, GoAwayCode.ProtocolError)\n    this.name = 'ReceiveWindowExceededError'\n  }\n}\n", "// Protocol violation errors\n\nimport { BothClientsError, DecodeInvalidVersionError, InvalidFrameError, NotMatchingPingError, ReceiveWindowExceededError, StreamAlreadyExistsError, UnRequestedPingError } from './errors.js'\n\nexport const PROTOCOL_ERRORS = new Set([\n  InvalidFrameError.name,\n  UnRequestedPingError.name,\n  NotMatchingPingError.name,\n  StreamAlreadyExistsError.name,\n  DecodeInvalidVersionError.name,\n  BothClientsError.name,\n  ReceiveWindowExceededError.name\n])\n\n/**\n * INITIAL_STREAM_WINDOW is the initial stream window size.\n *\n * Not an implementation choice, this is defined in the specification\n */\nexport const INITIAL_STREAM_WINDOW = 256 * 1024\n\n/**\n * Default max stream window\n */\nexport const MAX_STREAM_WINDOW = 16 * 1024 * 1024\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { INITIAL_STREAM_WINDOW, MAX_STREAM_WINDOW } from './constants.js'\nimport type { StreamMuxerOptions, StreamOptions } from '@libp2p/interface'\n\nexport interface YamuxStreamOptions extends StreamOptions {\n  /**\n   * Used to control the initial window size that we allow for a stream.\n   *\n   * measured in bytes\n   */\n  initialStreamWindowSize?: number\n\n  /**\n   * Used to control the maximum window size that we allow for a stream.\n   */\n  maxStreamWindowSize?: number\n}\n\n// TODO use config items or delete them\nexport interface Config extends StreamMuxerOptions<YamuxStreamOptions> {\n  /**\n   * Used to do periodic keep alive messages using a ping\n   */\n  enableKeepAlive?: boolean\n\n  /**\n   * How often to perform the keep alive\n   *\n   * measured in milliseconds\n   */\n  keepAliveInterval?: number\n}\n\nexport const defaultConfig: Required<Config> & { streamOptions: Required<YamuxStreamOptions> } = {\n  enableKeepAlive: true,\n  keepAliveInterval: 30_000,\n  maxInboundStreams: 1_000,\n  maxOutboundStreams: 1_000,\n  maxMessageSize: 64 * 1024,\n  maxEarlyStreams: 10,\n  streamOptions: {\n    initialStreamWindowSize: INITIAL_STREAM_WINDOW,\n    maxStreamWindowSize: MAX_STREAM_WINDOW,\n    inactivityTimeout: 120_000,\n    maxReadBufferLength: 4_194_304,\n    maxWriteBufferLength: Infinity\n  }\n}\n\nexport function verifyConfig (config: Config): void {\n  if (config.keepAliveInterval != null && config.keepAliveInterval <= 0) {\n    throw new InvalidParametersError('keep-alive interval must be positive')\n  }\n  if (config.maxInboundStreams != null && config.maxInboundStreams < 0) {\n    throw new InvalidParametersError('max inbound streams must be larger or equal 0')\n  }\n  if (config.maxOutboundStreams != null && config.maxOutboundStreams < 0) {\n    throw new InvalidParametersError('max outbound streams must be larger or equal 0')\n  }\n  if (config.maxMessageSize != null && config.maxMessageSize < 1024) {\n    throw new InvalidParametersError('MaxMessageSize must be greater than a kilobyte')\n  }\n  if (config.streamOptions?.initialStreamWindowSize != null && config.streamOptions?.initialStreamWindowSize < INITIAL_STREAM_WINDOW) {\n    throw new InvalidParametersError('InitialStreamWindowSize must be larger or equal 256 kB')\n  }\n  if (config.streamOptions?.maxStreamWindowSize != null && config.streamOptions?.initialStreamWindowSize != null && config.streamOptions?.maxStreamWindowSize < config.streamOptions?.initialStreamWindowSize) {\n    throw new InvalidParametersError('MaxStreamWindowSize must be larger than the InitialStreamWindowSize')\n  }\n  if (config.streamOptions?.maxStreamWindowSize != null && config.streamOptions?.maxStreamWindowSize > 2 ** 32 - 1) {\n    throw new InvalidParametersError('MaxStreamWindowSize must be less than equal MAX_UINT32')\n  }\n}\n", "import { Uint8ArrayList } from 'uint8arraylist'\nimport { InvalidFrameError } from './errors.js'\nimport { FrameType, HEADER_LENGTH, YAMUX_VERSION } from './frame.js'\nimport type { FrameHeader } from './frame.js'\n\nexport interface Frame {\n  header: FrameHeader\n  data?: Uint8ArrayList\n}\n\nexport interface DataFrame {\n  header: FrameHeader\n  data: Uint8ArrayList\n}\n\nexport function isDataFrame (frame: Frame): frame is DataFrame {\n  return frame.header.type === FrameType.Data && frame.data !== null\n}\n\n// used to bit shift in decoding\n// native bit shift can overflow into a negative number, so we bit shift by\n// multiplying by a power of 2\nconst twoPow24 = 2 ** 24\n\n/**\n * Decode a header from the front of a buffer\n *\n * @param data - Assumed to have enough bytes for a header\n */\nexport function decodeHeader (data: Uint8Array): FrameHeader {\n  if (data[0] !== YAMUX_VERSION) {\n    throw new InvalidFrameError('Invalid frame version')\n  }\n\n  return {\n    type: data[1],\n    flag: (data[2] << 8) + data[3],\n    streamID: (data[4] * twoPow24) + (data[5] << 16) + (data[6] << 8) + data[7],\n    length: (data[8] * twoPow24) + (data[9] << 16) + (data[10] << 8) + data[11]\n  }\n}\n\n/**\n * Decodes yamux frames from a source\n */\nexport class Decoder {\n  /** Buffer for in-progress frames */\n  private readonly buffer: Uint8ArrayList\n\n  constructor () {\n    this.buffer = new Uint8ArrayList()\n  }\n\n  /**\n   * Emits frames from the decoder source.\n   *\n   * Note: If `readData` is emitted, it _must_ be called before the next iteration\n   * Otherwise an error is thrown\n   */\n  * emitFrames (buf: Uint8Array | Uint8ArrayList): Generator<Frame> {\n    this.buffer.append(buf)\n\n    // Loop to consume as many bytes from the buffer as possible\n    // Eg: when a single chunk contains several frames\n    while (true) {\n      const frame = this.readFrame()\n\n      if (frame === undefined) {\n        break\n      }\n\n      yield frame\n    }\n  }\n\n  private readFrame (): Frame | undefined {\n    let frameSize = HEADER_LENGTH\n\n    if (this.buffer.byteLength < HEADER_LENGTH) {\n      // not enough data yet\n      return\n    }\n\n    // TODO: use sublist?\n    const header = decodeHeader(this.buffer.subarray(0, HEADER_LENGTH))\n\n    if (header.type === FrameType.Data) {\n      frameSize += header.length\n\n      if (this.buffer.byteLength < frameSize) {\n        // not enough data yet\n        return\n      }\n\n      const data = this.buffer.sublist(HEADER_LENGTH, frameSize)\n      this.buffer.consume(frameSize)\n\n      return { header, data }\n    }\n\n    this.buffer.consume(frameSize)\n\n    return { header }\n  }\n}\n", "import { HEADER_LENGTH } from './frame.js'\nimport type { FrameHeader } from './frame.js'\n\nexport function encodeHeader (header: FrameHeader): Uint8Array {\n  const frame = new Uint8Array(HEADER_LENGTH)\n\n  // always assume version 0\n  // frameView.setUint8(0, header.version)\n\n  frame[1] = header.type\n\n  frame[2] = header.flag >>> 8\n  frame[3] = header.flag\n\n  frame[4] = header.streamID >>> 24\n  frame[5] = header.streamID >>> 16\n  frame[6] = header.streamID >>> 8\n  frame[7] = header.streamID\n\n  frame[8] = header.length >>> 24\n  frame[9] = header.length >>> 16\n  frame[10] = header.length >>> 8\n  frame[11] = header.length\n\n  return frame\n}\n", "import { AbstractStream } from '@libp2p/utils'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { INITIAL_STREAM_WINDOW, MAX_STREAM_WINDOW } from './constants.js'\nimport { isDataFrame } from './decode.ts'\nimport { InvalidFrameError, ReceiveWindowExceededError } from './errors.js'\nimport { Flag, FrameType, HEADER_LENGTH } from './frame.js'\nimport type { Frame } from './decode.ts'\nimport type { FrameHeader } from './frame.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { AbstractStreamInit, SendResult } from '@libp2p/utils'\n\nexport enum StreamState {\n  Init,\n  SYNSent,\n  SYNReceived,\n  Established,\n  Finished,\n  Paused\n}\n\nexport interface YamuxStreamInit extends AbstractStreamInit {\n  streamId: number\n  sendFrame(header: FrameHeader, body?: Uint8ArrayList): boolean\n  getRTT(): number\n  initialStreamWindowSize?: number\n  maxMessageSize?: number\n  maxStreamWindowSize?: number\n  state: StreamState\n}\n\n/** YamuxStream is used to represent a logical stream within a session */\nexport class YamuxStream extends AbstractStream {\n  streamId: number\n  state: StreamState\n\n  /** The number of available bytes to send */\n  private sendWindowCapacity: number\n  /** The number of bytes available to receive in a full window */\n  private recvWindow: number\n  /** The number of available bytes to receive */\n  private recvWindowCapacity: number\n  private maxStreamWindowSize: number\n\n  /**\n   * An 'epoch' is the time it takes to process and read data\n   *\n   * Used in conjunction with RTT to determine whether to increase the recvWindow\n   */\n  private epochStart: number\n  private readonly getRTT: () => number\n\n  private readonly sendFrame: (header: FrameHeader, body?: Uint8ArrayList) => boolean\n\n  constructor (init: YamuxStreamInit) {\n    const initialWindowSize = init.initialStreamWindowSize ?? INITIAL_STREAM_WINDOW\n\n    super({\n      ...init,\n      maxMessageSize: initialWindowSize - HEADER_LENGTH\n    })\n\n    this.streamId = init.streamId\n    this.state = init.state\n    this.sendWindowCapacity = initialWindowSize\n    this.recvWindow = initialWindowSize\n    this.recvWindowCapacity = this.recvWindow\n    this.maxStreamWindowSize = init.maxStreamWindowSize ?? MAX_STREAM_WINDOW\n    this.epochStart = Date.now()\n    this.getRTT = init.getRTT\n    this.sendFrame = init.sendFrame\n\n    const setStateToFinishedOnCloseListener = (): void => {\n      this.state = StreamState.Finished\n    }\n    this.addEventListener('close', setStateToFinishedOnCloseListener)\n  }\n\n  /**\n   * Send a data message to the remote muxer\n   */\n  sendData (buf: Uint8ArrayList): SendResult {\n    const totalBytes = buf.byteLength\n    let sentBytes = 0\n    let canSendMore = true\n\n    this.log?.trace('send window capacity is %d bytes', this.sendWindowCapacity)\n\n    // send in chunks, waiting for window updates\n    while (buf.byteLength > 0) {\n      // we exhausted the send window, sending will resume later\n      if (this.sendWindowCapacity === 0) {\n        canSendMore = false\n        this.log?.trace('sent %d/%d bytes, exhausted send window, waiting for window update', sentBytes, totalBytes)\n        break\n      }\n\n      // send as much as we can\n      const toSend = Math.min(this.sendWindowCapacity, buf.byteLength)\n      const flags = this.getSendFlags()\n\n      const data = buf.sublist(0, toSend)\n      buf.consume(toSend)\n\n      const muxerSendMore = this.sendFrame({\n        type: FrameType.Data,\n        flag: flags,\n        streamID: this.streamId,\n        length: toSend\n      }, data)\n\n      this.sendWindowCapacity -= toSend\n      sentBytes += toSend\n\n      if (!muxerSendMore) {\n        canSendMore = muxerSendMore\n        this.log.trace('sent %d/%d bytes, wait for muxer to have more send capacity', sentBytes, totalBytes)\n        break\n      }\n    }\n\n    return {\n      sentBytes,\n      canSendMore\n    }\n  }\n\n  /**\n   * Send a reset message to the remote muxer\n   */\n  sendReset (): void {\n    this.sendFrame({\n      type: FrameType.WindowUpdate,\n      flag: Flag.RST,\n      streamID: this.streamId,\n      length: 0\n    })\n  }\n\n  /**\n   * Send a message to the remote muxer, informing them no more data messages\n   * will be sent by this end of the stream\n   */\n  async sendCloseWrite (): Promise<void> {\n    const flags = this.getSendFlags() | Flag.FIN\n    this.sendFrame({\n      type: FrameType.WindowUpdate,\n      flag: flags,\n      streamID: this.streamId,\n      length: 0\n    })\n  }\n\n  /**\n   * Send a message to the remote muxer, informing them no more data messages\n   * will be read by this end of the stream - this is a no-op on Yamux streams\n   */\n  async sendCloseRead (options?: AbortOptions): Promise<void> {\n    options?.signal?.throwIfAborted()\n  }\n\n  /**\n   * Stop sending window updates temporarily - in the interim the the remote\n   * send window will exhaust and the remote will stop sending data\n   */\n  sendPause (): void {\n    this.state = StreamState.Paused\n  }\n\n  /**\n   * Start sending window updates as normal\n   */\n  sendResume (): void {\n    this.state = StreamState.Established\n    this.sendWindowUpdate()\n  }\n\n  /**\n   * handleWindowUpdate is called when the stream receives a window update frame\n   */\n  handleWindowUpdate (frame: Frame): void {\n    this.processFlags(frame.header.flag)\n\n    // increase send window\n    this.sendWindowCapacity += frame.header.length\n\n    // change the chunk size the superclass uses\n    this.maxMessageSize = this.sendWindowCapacity - HEADER_LENGTH\n\n    if (this.maxMessageSize < 0) {\n      this.maxMessageSize = 0\n    }\n\n    if (this.maxMessageSize === 0) {\n      return\n    }\n\n    // if writing is paused and the update increases our send window, notify\n    // writers that writing can resume\n    if (this.writeBuffer.byteLength > 0) {\n      this.log?.trace('window update of %d bytes allows more data to be sent, have %d bytes queued, sending data %s', frame.header.length, this.writeBuffer.byteLength, this.sendingData)\n      this.safeDispatchEvent('drain')\n    }\n  }\n\n  /**\n   * handleData is called when the stream receives a data frame\n   */\n  handleData (frame: Frame): void {\n    if (!isDataFrame(frame)) {\n      throw new InvalidFrameError('Frame was not data frame')\n    }\n\n    this.processFlags(frame.header.flag)\n\n    // check that our recv window is not exceeded\n    if (this.recvWindowCapacity < frame.header.length) {\n      throw new ReceiveWindowExceededError('Receive window exceeded')\n    }\n\n    this.recvWindowCapacity -= frame.header.length\n\n    this.onData(frame.data)\n\n    this.sendWindowUpdate()\n  }\n\n  /**\n   * processFlags is used to update the state of the stream based on set flags, if any.\n   */\n  private processFlags (flags: number): void {\n    if ((flags & Flag.ACK) === Flag.ACK) {\n      if (this.state === StreamState.SYNSent) {\n        this.state = StreamState.Established\n      }\n    }\n\n    if ((flags & Flag.FIN) === Flag.FIN) {\n      this.onRemoteCloseWrite()\n    }\n\n    if ((flags & Flag.RST) === Flag.RST) {\n      this.onRemoteReset()\n    }\n  }\n\n  /**\n   * getSendFlags determines any flags that are appropriate\n   * based on the current stream state.\n   *\n   * The state is updated as a side-effect.\n   */\n  private getSendFlags (): number {\n    switch (this.state) {\n      case StreamState.Init:\n        this.state = StreamState.SYNSent\n        return Flag.SYN\n      case StreamState.SYNReceived:\n        this.state = StreamState.Established\n        return Flag.ACK\n      default:\n        return 0\n    }\n  }\n\n  /**\n   * Potentially sends a window update enabling further remote writes to take\n   * place.\n   */\n  sendWindowUpdate (): void {\n    if (this.state === StreamState.Paused) {\n      // we don't want any more data from the remote right now - update the\n      // epoch start as otherwise when we unpause we'd be looking at the epoch\n      // start from before we were paused\n      this.epochStart = Date.now()\n\n      return\n    }\n\n    // determine the flags if any\n    const flags = this.getSendFlags()\n\n    // If the stream has already been established\n    // and we've processed data within the time it takes for 4 round trips\n    // then we (up to) double the recvWindow\n    const now = Date.now()\n    const rtt = this.getRTT()\n\n    if (flags === 0 && rtt > -1 && (now - this.epochStart) <= (rtt * 4)) {\n      // we've already validated that maxStreamWindowSize can't be more than MAX_UINT32\n      this.recvWindow = Math.min(this.recvWindow * 2, this.maxStreamWindowSize)\n    }\n\n    if (this.recvWindowCapacity >= this.recvWindow && flags === 0) {\n      // a window update isn't needed\n      return\n    }\n\n    // update the receive window\n    const delta = this.recvWindow - this.recvWindowCapacity\n    this.recvWindowCapacity = this.recvWindow\n\n    // update the epoch start\n    this.epochStart = now\n\n    // send window update\n    this.sendFrame({\n      type: FrameType.WindowUpdate,\n      flag: flags,\n      streamID: this.streamId,\n      length: delta\n    })\n  }\n}\n", "import { InvalidParametersError, MuxerClosedError, TooManyOutboundProtocolStreamsError, serviceCapabilities } from '@libp2p/interface'\nimport { AbstractStreamMuxer, repeatingTask } from '@libp2p/utils'\nimport { raceSignal } from 'race-signal'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { defaultConfig, verifyConfig } from './config.js'\nimport { Decoder } from './decode.js'\nimport { encodeHeader } from './encode.js'\nimport { InvalidFrameError, isProtocolError, NotMatchingPingError, UnRequestedPingError } from './errors.js'\nimport { Flag, FrameType, GoAwayCode } from './frame.js'\nimport { StreamState, YamuxStream } from './stream.js'\nimport type { Config } from './config.js'\nimport type { Frame } from './decode.js'\nimport type { FrameHeader } from './frame.js'\nimport type { AbortOptions, MessageStream, StreamMuxerFactory } from '@libp2p/interface'\nimport type { RepeatingTask } from '@libp2p/utils'\n\nfunction debugFrame (header: FrameHeader): any {\n  return {\n    type: FrameType[header.type],\n    flags: [\n      (header.flag & Flag.SYN) === Flag.SYN ? 'SYN' : undefined,\n      (header.flag & Flag.ACK) === Flag.ACK ? 'ACK' : undefined,\n      (header.flag & Flag.FIN) === Flag.FIN ? 'FIN' : undefined,\n      (header.flag & Flag.RST) === Flag.RST ? 'RST' : undefined\n    ].filter(Boolean),\n    streamID: header.streamID,\n    length: header.length\n  }\n}\n\nconst YAMUX_PROTOCOL_ID = '/yamux/1.0.0'\n\nexport interface YamuxMuxerInit extends Partial<Config> {\n}\n\nexport class Yamux implements StreamMuxerFactory {\n  protocol = YAMUX_PROTOCOL_ID\n  private readonly _init: Partial<Config>\n\n  constructor (init: Partial<Config> = {}) {\n    this._init = init\n  }\n\n  readonly [Symbol.toStringTag] = '@chainsafe/libp2p-yamux'\n\n  readonly [serviceCapabilities]: string[] = [\n    '@libp2p/stream-multiplexing'\n  ]\n\n  createStreamMuxer (maConn: MessageStream): YamuxMuxer {\n    return new YamuxMuxer(maConn, {\n      ...this._init\n    })\n  }\n}\n\nexport interface CloseOptions extends AbortOptions {\n  reason?: GoAwayCode\n}\n\nexport interface ActivePing extends PromiseWithResolvers<number> {\n  id: number\n  start: number\n}\n\nexport class YamuxMuxer extends AbstractStreamMuxer<YamuxStream> {\n  /** The next stream id to be used when initiating a new stream */\n  private nextStreamID: number\n\n  /** The next ping id to be used when pinging */\n  private nextPingID: number\n  /** Tracking info for the currently active ping */\n  private activePing?: ActivePing\n  /** Round trip time */\n  private rtt: number\n\n  /** True if client, false if server */\n  private client: boolean\n\n  private localGoAway?: GoAwayCode\n  private remoteGoAway?: GoAwayCode\n\n  /** Number of tracked inbound streams */\n  private numInboundStreams: number\n  /** Number of tracked outbound streams */\n  private numOutboundStreams: number\n\n  private decoder: Decoder\n  private keepAlive?: RepeatingTask\n\n  private enableKeepAlive: boolean\n  private keepAliveInterval: number\n  private maxInboundStreams: number\n  private maxOutboundStreams: number\n\n  constructor (maConn: MessageStream, init: YamuxMuxerInit = {}) {\n    super(maConn, {\n      ...init,\n      protocol: YAMUX_PROTOCOL_ID,\n      name: 'yamux'\n    })\n\n    this.client = maConn.direction === 'outbound'\n    verifyConfig(init)\n\n    this.enableKeepAlive = init.enableKeepAlive ?? defaultConfig.enableKeepAlive\n    this.keepAliveInterval = init.keepAliveInterval ?? defaultConfig.keepAliveInterval\n    this.maxInboundStreams = init.maxInboundStreams ?? defaultConfig.maxInboundStreams\n    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultConfig.maxOutboundStreams\n\n    this.decoder = new Decoder()\n\n    this.numInboundStreams = 0\n    this.numOutboundStreams = 0\n\n    // client uses odd streamIDs, server uses even streamIDs\n    this.nextStreamID = this.client ? 1 : 2\n\n    this.nextPingID = 0\n    this.rtt = -1\n\n    this.log.trace('muxer created')\n\n    if (this.enableKeepAlive) {\n      this.log.trace('muxer keepalive enabled interval=%s', this.keepAliveInterval)\n      this.keepAlive = repeatingTask(async (options) => {\n        try {\n          await this.ping(options)\n        } catch (err: any) {\n          // TODO: should abort here?\n          this.log.error('ping error: %s', err)\n        }\n      }, this.keepAliveInterval, {\n        // send an initial ping to establish RTT\n        runImmediately: true\n      })\n      this.keepAlive.start()\n    }\n  }\n\n  onData (buf: Uint8Array | Uint8ArrayList): void {\n    for (const frame of this.decoder.emitFrames(buf)) {\n      this.handleFrame(frame)\n    }\n  }\n\n  onCreateStream (): YamuxStream {\n    if (this.remoteGoAway !== undefined) {\n      throw new MuxerClosedError('Muxer closed remotely')\n    }\n\n    if (this.localGoAway !== undefined) {\n      throw new MuxerClosedError('Muxer closed locally')\n    }\n\n    const id = this.nextStreamID\n    this.nextStreamID += 2\n\n    // check against our configured maximum number of outbound streams\n    if (this.numOutboundStreams >= this.maxOutboundStreams) {\n      throw new TooManyOutboundProtocolStreamsError('max outbound streams exceeded')\n    }\n\n    this.log.trace('new outgoing stream id=%s', id)\n\n    const stream = this._newStream(id, StreamState.Init, 'outbound')\n\n    this.numOutboundStreams++\n\n    // send a window update to open the stream on the receiver end. do this in a\n    // microtask so the stream gets added to the streams array by the superclass\n    // before we send the SYN flag, otherwise we create a race condition whereby\n    // we can receive the ACK before the stream is added to the streams list\n    queueMicrotask(() => {\n      stream.sendWindowUpdate()\n    })\n\n    return stream\n  }\n\n  /**\n   * Initiate a ping and wait for a response\n   *\n   * Note: only a single ping will be initiated at a time.\n   * If a ping is already in progress, a new ping will not be initiated.\n   *\n   * @returns the round-trip-time in milliseconds\n   */\n  async ping (options?: AbortOptions): Promise<number> {\n    if (this.remoteGoAway !== undefined) {\n      throw new MuxerClosedError('Muxer closed remotely')\n    }\n    if (this.localGoAway !== undefined) {\n      throw new MuxerClosedError('Muxer closed locally')\n    }\n\n    if (this.activePing != null) {\n      // an active ping is already in progress, piggyback off that\n      return raceSignal(this.activePing.promise, options?.signal)\n    }\n\n    // An active ping does not yet exist, handle the process here\n    // create active ping\n    this.activePing = Object.assign(Promise.withResolvers<number>(), {\n      id: this.nextPingID++,\n      start: Date.now()\n    })\n    // send ping\n    this.sendPing(this.activePing.id)\n    // await pong\n    try {\n      this.rtt = await raceSignal(this.activePing.promise, options?.signal)\n    } finally {\n      // clean-up active ping\n      this.activePing = undefined\n    }\n\n    return this.rtt\n  }\n\n  /**\n   * Get the ping round trip time\n   *\n   * Note: Will return 0 if no successful ping has yet been completed\n   *\n   * @returns the round-trip-time in milliseconds\n   */\n  getRTT (): number {\n    return this.rtt\n  }\n\n  /**\n   * Close the muxer\n   */\n  async close (options: CloseOptions = {}): Promise<void> {\n    if (this.status !== 'open') {\n      // already closed\n      return\n    }\n\n    try {\n      const reason = options?.reason ?? GoAwayCode.NormalTermination\n\n      this.log.trace('muxer close reason=%s', GoAwayCode[reason])\n\n      await super.close(options)\n\n      // send reason to the other side, allow the other side to close gracefully\n      this.sendGoAway(reason)\n    } finally {\n      this.keepAlive?.stop()\n    }\n  }\n\n  abort (err: Error): void {\n    if (this.status !== 'open') {\n      // already closed\n      return\n    }\n\n    try {\n      super.abort(err)\n\n      let reason = GoAwayCode.InternalError\n\n      if (isProtocolError(err)) {\n        reason = err.reason\n      }\n\n      // If reason was provided, use that, otherwise use the presence of `err` to determine the reason\n      this.log.error('muxer abort reason=%s error=%s', reason, err)\n\n      // send reason to the other side, allow the other side to close gracefully\n      this.sendGoAway(reason)\n    } finally {\n      this.keepAlive?.stop()\n    }\n  }\n\n  onTransportClosed (): void {\n    try {\n      super.onTransportClosed()\n    } finally {\n      this.keepAlive?.stop()\n    }\n  }\n\n  /** Create a new stream */\n  private _newStream (streamId: number, state: StreamState, direction: 'inbound' | 'outbound'): YamuxStream {\n    if (this.streams.find(s => s.streamId === streamId) != null) {\n      throw new InvalidParametersError('Stream already exists with that id')\n    }\n\n    const stream = new YamuxStream({\n      ...this.streamOptions,\n      id: `${streamId}`,\n      streamId,\n      state,\n      direction,\n      sendFrame: this.sendFrame.bind(this),\n      log: this.log.newScope(`${direction}:${streamId}`),\n      getRTT: this.getRTT.bind(this)\n    })\n\n    stream.addEventListener('close', () => {\n      this.closeStream(streamId)\n    }, {\n      once: true\n    })\n\n    return stream\n  }\n\n  /**\n   * closeStream is used to close a stream once both sides have\n   * issued a close.\n   */\n  private closeStream (id: number): void {\n    if (this.client === (id % 2 === 0)) {\n      this.numInboundStreams--\n    } else {\n      this.numOutboundStreams--\n    }\n  }\n\n  private handleFrame (frame: Frame): void {\n    const {\n      streamID,\n      type,\n      length\n    } = frame.header\n\n    this.log.trace('received frame %o', debugFrame(frame.header))\n\n    if (streamID === 0) {\n      switch (type) {\n        case FrameType.Ping:\n        { this.handlePing(frame.header); return }\n        case FrameType.GoAway:\n        { this.handleGoAway(length); return }\n        default:\n          // Invalid state\n          throw new InvalidFrameError('Invalid frame type')\n      }\n    } else {\n      switch (frame.header.type) {\n        case FrameType.Data:\n        case FrameType.WindowUpdate:\n        { this.handleStreamMessage(frame); return }\n        default:\n          // Invalid state\n          throw new InvalidFrameError('Invalid frame type')\n      }\n    }\n  }\n\n  private handlePing (header: FrameHeader): void {\n    // If the ping  is initiated by the sender, send a response\n    if (header.flag === Flag.SYN) {\n      this.log.trace('received ping request pingId=%s', header.length)\n      this.sendPing(header.length, Flag.ACK)\n    } else if (header.flag === Flag.ACK) {\n      this.log.trace('received ping response pingId=%s', header.length)\n      this.handlePingResponse(header.length)\n    } else {\n      // Invalid state\n      throw new InvalidFrameError('Invalid frame flag')\n    }\n  }\n\n  private handlePingResponse (pingId: number): void {\n    if (this.activePing === undefined) {\n      // this ping was not requested\n      throw new UnRequestedPingError('ping not requested')\n    }\n    if (this.activePing.id !== pingId) {\n      // this ping doesn't match our active ping request\n      throw new NotMatchingPingError('ping doesn\\'t match our id')\n    }\n\n    // valid ping response\n    this.activePing.resolve(Date.now() - this.activePing.start)\n  }\n\n  private handleGoAway (reason: GoAwayCode): void {\n    this.log.trace('received GoAway reason=%s', GoAwayCode[reason] ?? 'unknown')\n    this.remoteGoAway = reason\n\n    if (reason === GoAwayCode.NormalTermination) {\n      this.onTransportClosed()\n    } else {\n      // reset any streams that are still open and close the muxer\n      this.abort(new Error('Remote sent GoAway'))\n    }\n  }\n\n  private handleStreamMessage (frame: Frame): void {\n    const { streamID, flag, type } = frame.header\n\n    if ((flag & Flag.SYN) === Flag.SYN) {\n      this.incomingStream(streamID)\n    }\n\n    const stream = this.streams.find(s => s.streamId === streamID)\n    if (stream === undefined) {\n      this.log.trace('frame for missing stream id=%s', streamID)\n\n      return\n    }\n\n    switch (type) {\n      case FrameType.WindowUpdate: {\n        stream.handleWindowUpdate(frame); return\n      }\n      case FrameType.Data: {\n        stream.handleData(frame); return\n      }\n      default:\n        throw new Error('unreachable')\n    }\n  }\n\n  private incomingStream (id: number): void {\n    if (this.client !== (id % 2 === 0)) {\n      throw new InvalidParametersError('Both endpoints are clients')\n    }\n    if (this.streams.find(s => s.streamId === id)) {\n      return\n    }\n\n    this.log.trace('new incoming stream id=%s', id)\n\n    if (this.localGoAway !== undefined) {\n      // reject (reset) immediately if we are doing a go away\n      this.sendFrame({\n        type: FrameType.WindowUpdate,\n        flag: Flag.RST,\n        streamID: id,\n        length: 0\n      })\n      return\n    }\n\n    // check against our configured maximum number of inbound streams\n    if (this.numInboundStreams >= this.maxInboundStreams) {\n      this.log('maxIncomingStreams exceeded, forcing stream reset')\n      this.sendFrame({\n        type: FrameType.WindowUpdate,\n        flag: Flag.RST,\n        streamID: id,\n        length: 0\n      })\n      return\n    }\n\n    // allocate a new stream\n    const stream = this._newStream(id, StreamState.SYNReceived, 'inbound')\n\n    this.numInboundStreams++\n\n    // the stream should now be tracked\n    this.onRemoteStream(stream)\n  }\n\n  private sendFrame (header: FrameHeader, data?: Uint8ArrayList): boolean {\n    let encoded: Uint8Array | Uint8ArrayList\n\n    if (header.type === FrameType.Data) {\n      if (data == null) {\n        throw new InvalidFrameError('Invalid frame')\n      }\n\n      encoded = new Uint8ArrayList(encodeHeader(header), data)\n    } else {\n      encoded = encodeHeader(header)\n    }\n\n    this.log.trace('sending frame %o', debugFrame(header))\n\n    return this.send(encoded)\n  }\n\n  private sendPing (pingId: number, flag: Flag = Flag.SYN): void {\n    if (flag === Flag.SYN) {\n      this.log.trace('sending ping request pingId=%s', pingId)\n    } else {\n      this.log.trace('sending ping response pingId=%s', pingId)\n    }\n    this.sendFrame({\n      type: FrameType.Ping,\n      flag,\n      streamID: 0,\n      length: pingId\n    })\n  }\n\n  private sendGoAway (reason: GoAwayCode = GoAwayCode.NormalTermination): void {\n    this.log('sending GoAway reason=%s', GoAwayCode[reason])\n    this.localGoAway = reason\n    this.sendFrame({\n      type: FrameType.GoAway,\n      flag: 0,\n      streamID: 0,\n      length: reason\n    })\n  }\n}\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "GoAwayCode", "yamux", "InvalidParametersError", "message", "MuxerClosedError", "message", "StreamResetError", "StreamStateError", "message", "StreamBufferError", "TooManyOutboundProtocolStreamsError", "message", "StreamMessageEvent", "data", "eventInitDict", "StreamCloseEvent", "local", "error", "StreamAbortEvent", "StreamResetEvent", "TypedEventEmitter", "#listeners", "type", "listeners", "listener", "options", "list", "callback", "event", "result", "once", "detail", "serviceCapabilities", "serviceDependencies", "equals", "a", "b", "i", "alloc", "size", "allocUnsafe", "concat", "arrays", "length", "acc", "curr", "output", "allocUnsafe", "offset", "arr", "symbol", "findBufAndOffset", "bufs", "index", "offset", "buf", "bufEnd", "isUint8ArrayList", "value", "Uint8ArrayList", "_Uint8ArrayList", "data", "length", "res", "i", "bytes", "beginInclusive", "endExclusive", "concat", "list", "bufStart", "sliceStartInBuf", "sliceEndsInBuf", "start", "search", "needle", "M", "radix", "rightmostPositions", "c", "j", "right", "lastIndex", "lastPatIndex", "skip", "char", "byteOffset", "allocUnsafe", "littleEndian", "alloc", "other", "equals", "acc", "curr", "pDefer", "deferred", "resolve", "reject", "FixedFIFO", "hwm", "data", "last", "FIFO", "options", "obj", "val", "prev", "next", "AbortError", "message", "code", "pushable", "options", "_pushable", "buffer", "next", "_pushable", "getNext", "options", "onEnd", "buffer", "FIFO", "pushable", "onNext", "ended", "drain", "pDefer", "waitNext", "resolve", "reject", "next", "err", "bufferNext", "bufferError", "push", "value", "end", "_return", "_throw", "signal", "cancel", "listener", "AbortError", "opts", "TimeoutError", "message", "AbortError", "getDOMException", "errorMessage", "getAbortedReason", "signal", "reason", "pTimeout", "promise", "options", "milliseconds", "fallback", "customTimers", "timer", "abortHandler", "cancelablePromise", "resolve", "reject", "timeoutError", "error", "normalizeEmitter", "emitter", "addListener", "removeListener", "pEventMultiple", "event", "options", "cancel", "returnValue", "resolve", "reject", "events", "items", "onItem", "arguments_", "value", "error", "rejectHandler", "rejectionEvent", "timeout", "pTimeout", "pEvent", "arrayPromise", "promise", "array", "debounce", "func", "wait", "timeout", "output", "later", "MaxEarlyStreamsError", "StreamClosedError", "defaultTranslate", "signal", "raceSignal", "promise", "opts", "translateError", "listener", "resolve", "reject", "DEFAULT_MAX_READ_BUFFER_LENGTH", "AbstractMessageStream", "TypedEventEmitter", "init", "Uint8ArrayList", "continueSendingOnDrain", "rejectOnDrainOnClose", "evt", "StreamClosedError", "options", "raceSignal", "output", "pushable", "streamAsyncIterableOnMessageListener", "streamAsyncIterableOnCloseListener", "streamAsyncIterableOnRemoteCloseWriteListener", "data", "StreamStateError", "err", "StreamAbortEvent", "args", "StreamResetError", "StreamResetEvent", "StreamCloseEvent", "canSendMore", "totalBytes", "sentBytes", "end", "toSend", "willSend", "sendResult", "buf", "StreamMessageEvent", "StreamBufferError", "isPromise", "thing", "AbstractStreamMuxer", "TypedEventEmitter", "maConn", "init", "muxerMaConnOnMessage", "evt", "err", "muxerMaConnOnDrain", "stream", "muxerOnMaConnClose", "data", "result", "options", "raceSignal", "s", "MuxerClosedError", "isPromise", "MaxEarlyStreamsError", "muxerOnStreamEnd", "index", "args", "AbstractStream", "AbstractMessageStream", "init", "options", "pEvent", "anySignal", "signals", "controller", "onAbort", "signal", "clear", "repeatingTask", "fn", "interval", "options", "timeout", "shutdownController", "running", "runTask", "opts", "signal", "anySignal", "runTaskDebounced", "debounce", "started", "ms", "FrameType", "Flag", "flagCodes", "x", "YAMUX_VERSION", "GoAwayCode", "HEADER_LENGTH", "ProtocolError", "message", "reason", "isProtocolError", "err", "InvalidFrameError", "GoAwayCode", "UnRequestedPingError", "NotMatchingPingError", "StreamAlreadyExistsError", "ProtocolError", "message", "GoAwayCode", "DecodeInvalidVersionError", "BothClientsError", "ReceiveWindowExceededError", "PROTOCOL_ERRORS", "InvalidFrameError", "UnRequestedPingError", "NotMatchingPingError", "StreamAlreadyExistsError", "DecodeInvalidVersionError", "BothClientsError", "ReceiveWindowExceededError", "INITIAL_STREAM_WINDOW", "MAX_STREAM_WINDOW", "defaultConfig", "INITIAL_STREAM_WINDOW", "MAX_STREAM_WINDOW", "verifyConfig", "config", "InvalidParametersError", "isDataFrame", "frame", "FrameType", "twoPow24", "decodeHeader", "data", "YAMUX_VERSION", "InvalidFrameError", "Decoder", "Uint8ArrayList", "buf", "frameSize", "HEADER_LENGTH", "header", "encodeHeader", "header", "frame", "HEADER_LENGTH", "StreamState", "YamuxStream", "AbstractStream", "init", "initialWindowSize", "INITIAL_STREAM_WINDOW", "HEADER_LENGTH", "MAX_STREAM_WINDOW", "setStateToFinishedOnCloseListener", "buf", "totalBytes", "sentBytes", "canSendMore", "toSend", "flags", "data", "muxerSendMore", "FrameType", "Flag", "options", "frame", "isDataFrame", "InvalidFrameError", "ReceiveWindowExceededError", "now", "rtt", "delta", "debugFrame", "header", "FrameType", "Flag", "YAMUX_PROTOCOL_ID", "Yamux", "init", "serviceCapabilities", "maConn", "YamuxMuxer", "AbstractStreamMuxer", "verifyConfig", "defaultConfig", "Decoder", "repeatingTask", "options", "err", "buf", "frame", "MuxerClosedError", "id", "TooManyOutboundProtocolStreamsError", "stream", "StreamState", "raceSignal", "reason", "GoAwayCode", "isProtocolError", "streamId", "state", "direction", "s", "InvalidParametersError", "YamuxStream", "streamID", "type", "length", "InvalidFrameError", "pingId", "UnRequestedPingError", "NotMatchingPingError", "flag", "data", "encoded", "Uint8ArrayList", "encodeHeader", "yamux", "init", "Yamux"]
}
