import { StreamMessageEvent } from '@libp2p/interface';
import { defaultLogger } from '@libp2p/logger';
import { multiaddr } from '@multiformats/multiaddr';
import { pEvent } from 'p-event';
import { raceSignal } from 'race-signal';
import { AbstractMultiaddrConnection } from "./abstract-multiaddr-connection.js";
import { MessageQueue } from "./message-queue.js";
let multiaddrConnectionId = 0;
class MockMultiaddrConnection extends AbstractMultiaddrConnection {
    local;
    remote;
    constructor(init) {
        super(init);
        this.local = init.local;
        this.remote = init.remote;
        this.local.addEventListener('drain', () => {
            this.safeDispatchEvent('drain');
        });
        this.remote.addEventListener('message', (evt) => {
            if (this.status !== 'open') {
                return;
            }
            this.onData(evt.data);
        });
        this.remote.addEventListener('reset', (evt) => {
            if (this.status !== 'open') {
                return;
            }
            this.onRemoteReset();
        });
        this.remote.addEventListener('close', (evt) => {
            this.onTransportClosed();
        });
        this.remote.addEventListener('pause', (evt) => {
            this.local.pause();
        });
        this.remote.addEventListener('resume', (evt) => {
            this.local.resume();
        });
    }
    sendData(data) {
        const canSendMore = this.local.send(new StreamMessageEvent(data));
        return {
            sentBytes: data.byteLength,
            canSendMore
        };
    }
    sendReset() {
        this.local.send(new Event('reset'));
    }
    async sendClose(options) {
        if (this.local.needsDrain) {
            await pEvent(this.local, 'drain', {
                signal: options?.signal
            });
        }
        return raceSignal(new Promise((resolve, reject) => {
            this.local.send(new Event('close'));
            this.local.onIdle().then(resolve, reject);
        }), options?.signal);
    }
    sendPause() {
        this.local.send(new Event('pause'));
    }
    sendResume() {
        this.local.send(new Event('resume'));
    }
}
export function multiaddrConnectionPair(opts = {}) {
    const inboundId = `${multiaddrConnectionId++}`;
    const outboundId = `${multiaddrConnectionId++}`;
    const outboundLog = defaultLogger().forComponent(`libp2p:mock-maconn:outbound:${inboundId}`);
    const inboundLog = defaultLogger().forComponent(`libp2p:mock-maconn:inbound:${outboundId}`);
    const targetA = new MessageQueue({
        ...opts,
        log: outboundLog
    });
    const targetB = new MessageQueue({
        ...opts,
        log: inboundLog
    });
    return [
        new MockMultiaddrConnection({
            ...opts.outbound,
            id: outboundId,
            direction: 'outbound',
            local: targetA,
            remote: targetB,
            remoteAddr: opts?.outbound?.remoteAddr ?? multiaddr(`/ip4/127.0.0.1/tcp/${outboundId}`),
            log: outboundLog
        }),
        new MockMultiaddrConnection({
            ...opts.inbound,
            id: inboundId,
            direction: 'inbound',
            local: targetB,
            remote: targetA,
            remoteAddr: opts?.inbound?.remoteAddr ?? multiaddr(`/ip4/127.0.0.1/tcp/${inboundId}`),
            log: inboundLog
        })
    ];
}
//# sourceMappingURL=multiaddr-connection-pair.js.map