import { TypedEventEmitter } from '@libp2p/interface';
import { Uint8ArrayList } from 'uint8arraylist';
import type { MessageStreamEvents, MessageStreamStatus, MessageStream, AbortOptions, MessageStreamTimeline, MessageStreamDirection, EventHandler, StreamOptions, MessageStreamReadStatus, MessageStreamWriteStatus } from '@libp2p/interface';
import type { Logger } from '@libp2p/logger';
export interface MessageStreamInit extends StreamOptions {
    /**
     * A Logger implementation used to log stream-specific information
     */
    log: Logger;
    /**
     * The stream direction
     */
    direction?: MessageStreamDirection;
    /**
     * By default all available bytes are passed to the `sendData` method of
     * extending classes, if smaller chunks are required, pass a value here.
     */
    maxMessageSize?: number;
}
export interface SendResult {
    /**
     * The number of bytes from the passed buffer that were sent
     */
    sentBytes: number;
    /**
     * If the underlying resource can accept more data immediately. If `true`,
     * `sent` must equal the `.byteLength` of the buffer passed to `sendData`.
     */
    canSendMore: boolean;
}
export declare abstract class AbstractMessageStream<Timeline extends MessageStreamTimeline = MessageStreamTimeline> extends TypedEventEmitter<MessageStreamEvents> implements MessageStream {
    status: MessageStreamStatus;
    readonly timeline: Timeline;
    inactivityTimeout: number;
    maxReadBufferLength: number;
    maxWriteBufferLength?: number;
    readonly log: Logger;
    direction: MessageStreamDirection;
    maxMessageSize?: number;
    readStatus: MessageStreamReadStatus;
    writeStatus: MessageStreamWriteStatus;
    remoteReadStatus: MessageStreamReadStatus;
    remoteWriteStatus: MessageStreamWriteStatus;
    writableNeedsDrain: boolean;
    /**
     * Any data stored here is emitted before any new incoming data.
     *
     * This is used when the stream is paused or if data is pushed onto the stream
     */
    protected readonly readBuffer: Uint8ArrayList;
    protected readonly writeBuffer: Uint8ArrayList;
    protected sendingData: boolean;
    private onDrainPromise?;
    constructor(init: MessageStreamInit);
    get readBufferLength(): number;
    get writeBufferLength(): number;
    onDrain(options?: AbortOptions): Promise<void>;
    [Symbol.asyncIterator](): AsyncGenerator<Uint8Array | Uint8ArrayList>;
    isReadable(): boolean;
    send(data: Uint8Array | Uint8ArrayList): boolean;
    /**
     * Close immediately for reading and writing and send a reset message (local
     * error)
     */
    abort(err: Error): void;
    pause(): void;
    resume(): void;
    push(data: Uint8Array | Uint8ArrayList): void;
    unshift(data: Uint8Array | Uint8ArrayList): void;
    /**
     * When an extending class reads data from it's implementation-specific source,
     * call this method to allow the stream consumer to read the data.
     */
    onData(data: Uint8Array | Uint8ArrayList): void;
    addEventListener<K extends keyof MessageStreamEvents>(type: K, listener: EventHandler<MessageStreamEvents[K]> | null, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventHandler<Event>, options?: boolean | AddEventListenerOptions): void;
    /**
     * Receive a reset message - close immediately for reading and writing (remote
     * error)
     */
    onRemoteReset(): void;
    /**
     * The underlying resource or transport this stream uses has closed - it is
     * not possible to send any more messages though any data still in the read
     * buffer may still be read
     */
    onTransportClosed(err?: Error): void;
    /**
     * Called by extending classes when the remote closes its writable end
     */
    onRemoteCloseWrite(): void;
    /**
     * Called by extending classes when the remote closes its readable end
     */
    onRemoteCloseRead(): void;
    protected processSendQueue(): boolean;
    protected dispatchReadBuffer(): void;
    private checkReadBufferLength;
    private checkWriteBufferLength;
    onMuxerNeedsDrain(): void;
    onMuxerDrain(): void;
    /**
     * Send a data message to the remote end of the stream. Implementations of
     * this method should return the number of bytes from the passed buffer that
     * were sent successfully and if the underlying resource can accept more data.
     *
     * The implementation should always attempt to send the maximum amount of data
     * possible.
     *
     * Returning a result that means the data was only partially sent but that the
     * underlying resource can accept more data is invalid.
     */
    abstract sendData(data: Uint8ArrayList): SendResult;
    /**
     * Send a reset message to the remote end of the stream
     */
    abstract sendReset(err: Error): void;
    /**
     * If supported, instruct the remote end of the stream to temporarily stop
     * sending data messages
     */
    abstract sendPause(): void;
    /**
     * If supported, inform the remote end of the stream they may resume sending
     * data messages
     */
    abstract sendResume(): void;
    /**
     * Stop accepting new data to send and return a promise that resolves when any
     * unsent data has been written into the underlying resource.
     */
    abstract close(options?: AbortOptions): Promise<void>;
}
//# sourceMappingURL=abstract-message-stream.d.ts.map