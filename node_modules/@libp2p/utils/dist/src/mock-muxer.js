import * as cborg from 'cborg';
import * as lp from 'it-length-prefixed';
import { pushable } from 'it-pushable';
import { Uint8ArrayList } from 'uint8arraylist';
import { AbstractStreamMuxer } from "./abstract-stream-muxer.js";
import { AbstractStream } from "./abstract-stream.js";
import { Queue } from './queue/index.js';
class MockMuxedStream extends AbstractStream {
    sendMessage;
    dataQueue;
    encoding;
    constructor(init) {
        super(init);
        this.sendMessage = init.sendMessage;
        this.encoding = init.encoding;
        this.dataQueue = new Queue({
            concurrency: 1
        });
        if (this.direction === 'outbound') {
            this.sendMessage({
                id: this.id,
                type: 'create',
                protocol: this.protocol
            });
        }
    }
    sendData(data) {
        const canSendMore = this.sendMessage({
            id: this.id,
            type: 'data',
            chunk: data.subarray()
        });
        return {
            sentBytes: data.byteLength,
            canSendMore
        };
    }
    sendReset() {
        this.sendMessage({
            id: this.id,
            type: 'reset'
        });
    }
    async sendCloseWrite(options) {
        this.sendMessage({
            id: this.id,
            type: 'closeWrite'
        });
        options?.signal?.throwIfAborted();
    }
    async sendCloseRead(options) {
        this.sendMessage({
            id: this.id,
            type: 'closeRead'
        });
        options?.signal?.throwIfAborted();
    }
    sendPause() {
        this.sendMessage({
            id: this.id,
            type: 'pause'
        });
    }
    sendResume() {
        this.sendMessage({
            id: this.id,
            type: 'resume'
        });
    }
    onRemotePaused() {
        this.dataQueue.pause();
    }
    onRemoteResumed() {
        this.dataQueue.resume();
    }
}
// CBOR encoding of non-message data fields
const MESSAGE_OVERHEAD = 30;
class MockMuxer extends AbstractStreamMuxer {
    input;
    maxInputQueueSize;
    encoding;
    maxMessageSize;
    nextStreamId;
    constructor(maConn, init) {
        super(maConn, {
            ...init,
            protocol: '/mock-muxer/1.0.0',
            name: 'mock-muxer'
        });
        this.maxInputQueueSize = init.maxInputQueueSize ?? 1024 * 1024 * 10;
        this.maxMessageSize = (init.maxMessageSize ?? 1024 * 1024 * 4) + MESSAGE_OVERHEAD;
        this.encoding = init.encoding ?? 'base64';
        this.input = pushable();
        this.sendMessage = this.sendMessage.bind(this);
        this.nextStreamId = this.maConn.direction === 'outbound' ? 0 : 1;
        Promise.resolve()
            .then(async () => {
            for await (const buf of lp.decode(this.input, {
                maxDataLength: this.maxMessageSize
            })) {
                this.onMessage(cborg.decode(buf.subarray()));
            }
        })
            .catch(err => {
            this.abort(err);
        });
    }
    onData(data) {
        if (this.input.readableLength >= this.maxInputQueueSize) {
            this.abort(new Error(`Input queue exceeded maximum size ${this.input.readableLength} >= ${this.maxInputQueueSize}`));
            return;
        }
        this.input.push(data);
    }
    sendMessage(message) {
        if (message.type === 'data') {
            this.log.trace('send message %o', { ...message, chunk: `[ ${message.chunk.byteLength} bytes ]` });
        }
        else {
            this.log.trace('send message %o', message);
        }
        const buf = cborg.encode(message);
        const encoded = lp.encode.single(buf, {
            maxDataLength: this.maxMessageSize
        });
        return this.send(encoded);
    }
    onMessage(message) {
        if (message.type === 'data') {
            this.log.trace('incoming message %o', { ...message, chunk: `[ ${message.chunk.byteLength} bytes ]` });
        }
        else {
            this.log.trace('incoming message %o', message);
        }
        let stream = this.streams.find(s => s.id === message.id);
        if (message.type === 'create') {
            if (stream != null) {
                throw new Error(`Already had stream for ${message.id}`);
            }
            this.log.trace('create stream inbound %s', message.id);
            stream = this._createStream(message.id, 'inbound', {
                protocol: message.protocol
            });
            this.onRemoteStream(stream);
        }
        if (stream == null) {
            this.log.error(`no stream found for ${message.id}`);
            return;
        }
        if (message.type === 'data') {
            stream.onData(message.chunk);
        }
        else if (message.type === 'reset') {
            stream.onRemoteReset();
        }
        else if (message.type === 'closeWrite') {
            stream.onRemoteCloseWrite();
        }
        else if (message.type === 'closeRead') {
            stream.onRemoteCloseRead();
        }
        else if (message.type === 'pause') {
            stream.onRemotePaused();
        }
        else if (message.type === 'resume') {
            stream.onRemoteResumed();
        }
    }
    async onCreateStream(options) {
        this.nextStreamId += 2;
        return this._createStream(`${this.nextStreamId}`, 'outbound', options);
    }
    _createStream(id, direction, options) {
        this.log.trace('createStream %s %s', direction, id);
        return new MockMuxedStream({
            ...this.streamOptions,
            ...options,
            id,
            direction,
            log: this.log.newScope(`stream:${direction}:${id}`),
            sendMessage: this.sendMessage,
            encoding: this.encoding,
            maxMessageSize: this.maxMessageSize - MESSAGE_OVERHEAD,
            protocol: ''
        });
    }
}
class MockMuxerFactory {
    protocol = '/mock-muxer/1.0.0';
    init;
    constructor(init) {
        this.init = init;
    }
    createStreamMuxer(maConn) {
        return new MockMuxer(maConn, {
            ...this.init
        });
    }
}
export function mockMuxer(init = {}) {
    return new MockMuxerFactory(init);
}
//# sourceMappingURL=mock-muxer.js.map