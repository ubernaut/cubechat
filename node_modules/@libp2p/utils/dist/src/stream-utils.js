import { StreamMessageEvent, StreamCloseEvent, InvalidParametersError } from '@libp2p/interface';
import { pipe as itPipe } from 'it-pipe';
import { pushable } from 'it-pushable';
import { pEvent } from 'p-event';
import { raceSignal } from 'race-signal';
import * as varint from 'uint8-varint';
import { Uint8ArrayList } from 'uint8arraylist';
import { UnexpectedEOFError } from './errors.js';
const DEFAULT_MAX_BUFFER_SIZE = 4_194_304;
export class UnwrappedError extends Error {
    static name = 'UnwrappedError';
    name = 'UnwrappedError';
}
/**
 * The reported length of the next data message was not a positive integer
 */
export class InvalidMessageLengthError extends Error {
    name = 'InvalidMessageLengthError';
    code = 'ERR_INVALID_MSG_LENGTH';
}
/**
 * The reported length of the next data message was larger than the configured
 * max allowable value
 */
export class InvalidDataLengthError extends Error {
    name = 'InvalidDataLengthError';
    code = 'ERR_MSG_DATA_TOO_LONG';
}
/**
 * The varint used to specify the length of the next data message contained more
 * bytes than the configured max allowable value
 */
export class InvalidDataLengthLengthError extends Error {
    name = 'InvalidDataLengthLengthError';
    code = 'ERR_MSG_LENGTH_TOO_LONG';
}
function isStream(obj) {
    return typeof obj?.closeRead === 'function';
}
function isMultiaddrConnection(obj) {
    return typeof obj?.close === 'function';
}
function isEOF(obj) {
    if (isStream(obj)) {
        return obj.remoteWriteStatus !== 'writable' && obj.readBufferLength === 0;
    }
    if (isMultiaddrConnection(obj)) {
        return obj.status !== 'open';
    }
    return false;
}
function isValid(obj) {
    return obj?.addEventListener != null && obj?.removeEventListener != null && obj?.send != null && obj?.push != null && obj?.log != null;
}
export function byteStream(stream, opts) {
    const maxBufferSize = opts?.maxBufferSize ?? DEFAULT_MAX_BUFFER_SIZE;
    const readBuffer = new Uint8ArrayList();
    let hasBytes;
    let unwrapped = false;
    if (!isValid(stream)) {
        throw new InvalidParametersError('Argument should be a Stream or a Multiaddr');
    }
    const byteStreamOnMessageListener = (evt) => {
        readBuffer.append(evt.data);
        if (readBuffer.byteLength > maxBufferSize) {
            const readBufferSize = readBuffer.byteLength;
            readBuffer.consume(readBuffer.byteLength);
            hasBytes?.reject(new Error(`Read buffer overflow - ${readBufferSize} > ${maxBufferSize}`));
        }
        hasBytes?.resolve();
    };
    stream.addEventListener('message', byteStreamOnMessageListener);
    const byteStreamOnCloseListener = (evt) => {
        if (evt.error != null) {
            hasBytes?.reject(evt.error);
        }
        else {
            hasBytes?.resolve();
        }
    };
    stream.addEventListener('close', byteStreamOnCloseListener);
    const byteStreamOnRemoteCloseWrite = () => {
        hasBytes?.resolve();
    };
    stream.addEventListener('remoteCloseWrite', byteStreamOnRemoteCloseWrite);
    const byteStream = {
        readBuffer,
        // @ts-expect-error options type prevents type inference
        async read(options) {
            if (unwrapped === true) {
                throw new UnwrappedError('Stream was unwrapped');
            }
            if (isEOF(stream)) {
                if (options?.bytes == null) {
                    return null;
                }
                if (readBuffer.byteLength < options.bytes) {
                    stream.log.error('closed after reading %d/%d bytes', readBuffer.byteLength, options.bytes);
                    throw new UnexpectedEOFError(`Unexpected EOF - stream closed after reading ${readBuffer.byteLength}/${options.bytes} bytes`);
                }
            }
            const bytesToRead = options?.bytes ?? 1;
            hasBytes = Promise.withResolvers();
            while (true) {
                if (readBuffer.byteLength >= bytesToRead) {
                    // if we are about to exit the loop this promise will not be awaited
                    // so resolve it to prevent and unhandled promise rejections that may
                    // occur
                    hasBytes.resolve();
                    break;
                }
                await raceSignal(hasBytes.promise, options?.signal);
                if (isEOF(stream)) {
                    if (readBuffer.byteLength === 0 && options?.bytes == null) {
                        return null;
                    }
                    break;
                }
                hasBytes = Promise.withResolvers();
            }
            const toRead = options?.bytes ?? readBuffer.byteLength;
            if (readBuffer.byteLength < toRead) {
                if (isEOF(stream)) {
                    stream.log.error('closed while reading %d/%d bytes', readBuffer.byteLength, toRead);
                    throw new UnexpectedEOFError(`Unexpected EOF - stream closed while reading ${readBuffer.byteLength}/${toRead} bytes`);
                }
                return byteStream.read(options);
            }
            const output = readBuffer.sublist(0, toRead);
            readBuffer.consume(toRead);
            return output;
        },
        async write(data, options) {
            if (unwrapped === true) {
                throw new UnwrappedError('Stream was unwrapped');
            }
            if (!stream.send(data)) {
                await pEvent(stream, 'drain', {
                    signal: options?.signal,
                    rejectionEvents: ['close']
                });
            }
        },
        unwrap() {
            // already unwrapped, just return the original stream
            if (unwrapped) {
                return stream;
            }
            // only unwrap once
            unwrapped = true;
            stream.removeEventListener('message', byteStreamOnMessageListener);
            stream.removeEventListener('close', byteStreamOnCloseListener);
            stream.removeEventListener('remoteCloseWrite', byteStreamOnRemoteCloseWrite);
            // emit any unread data
            if (readBuffer.byteLength > 0) {
                stream.log('stream unwrapped with %d unread bytes', readBuffer.byteLength);
                stream.push(readBuffer);
            }
            return stream;
        }
    };
    return byteStream;
}
export function lpStream(stream, opts = {}) {
    const bytes = byteStream(stream, opts);
    if (opts.maxDataLength != null && opts.maxLengthLength == null) {
        // if max data length is set but max length length is not, calculate the
        // max length length needed to encode max data length
        opts.maxLengthLength = varint.encodingLength(opts.maxDataLength);
    }
    const decodeLength = opts?.lengthDecoder ?? varint.decode;
    const encodeLength = opts?.lengthEncoder ?? varint.encode;
    const lpStream = {
        async read(options) {
            let dataLength = -1;
            const lengthBuffer = new Uint8ArrayList();
            while (true) {
                // read one byte at a time until we can decode a varint
                const buf = await bytes.read({
                    ...options,
                    bytes: 1
                });
                // the underlying resource closed gracefully
                if (buf == null) {
                    break;
                }
                // append byte and try to decode
                lengthBuffer.append(buf);
                try {
                    dataLength = decodeLength(lengthBuffer);
                }
                catch (err) {
                    if (err instanceof RangeError) {
                        continue;
                    }
                    throw err;
                }
                if (dataLength < 0) {
                    throw new InvalidMessageLengthError('Invalid message length');
                }
                if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {
                    throw new InvalidDataLengthLengthError(`Message length length too long - ${lengthBuffer.byteLength} > ${opts.maxLengthLength}`);
                }
                if (dataLength > -1) {
                    break;
                }
            }
            if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {
                throw new InvalidDataLengthError(`Message length too long - ${dataLength} > ${opts.maxDataLength}`);
            }
            const buf = await bytes.read({
                ...options,
                bytes: dataLength
            });
            if (buf == null) {
                stream.log.error('tried to read %d bytes but the stream closed', dataLength);
                throw new UnexpectedEOFError(`Unexpected EOF - tried to read ${dataLength} bytes but the stream closed`);
            }
            if (buf.byteLength !== dataLength) {
                stream.log.error('read %d/%d bytes before the stream closed', buf.byteLength, dataLength);
                throw new UnexpectedEOFError(`Unexpected EOF - read ${buf.byteLength}/${dataLength} bytes before the stream closed`);
            }
            return buf;
        },
        async write(data, options) {
            // encode, write
            await bytes.write(new Uint8ArrayList(encodeLength(data.byteLength), data), options);
        },
        async writeV(data, options) {
            const list = new Uint8ArrayList(...data.flatMap(buf => ([encodeLength(buf.byteLength), buf])));
            // encode, write
            await bytes.write(list, options);
        },
        unwrap() {
            return bytes.unwrap();
        }
    };
    return lpStream;
}
export function pbStream(stream, opts) {
    const lp = lpStream(stream, opts);
    const pbStream = {
        read: async (proto, options) => {
            // readLP, decode
            const value = await lp.read(options);
            return proto.decode(value);
        },
        write: async (message, proto, options) => {
            // encode, writeLP
            await lp.write(proto.encode(message), options);
        },
        writeV: async (messages, proto, options) => {
            // encode, writeLP
            await lp.writeV(messages.map(message => proto.encode(message)), options);
        },
        pb: (proto) => {
            return {
                read: async (options) => pbStream.read(proto, options),
                write: async (d, options) => pbStream.write(d, proto, options),
                writeV: async (d, options) => pbStream.writeV(d, proto, options),
                unwrap: () => pbStream
            };
        },
        unwrap: () => {
            return lp.unwrap();
        }
    };
    return pbStream;
}
export async function echo(stream, options) {
    const log = stream.log.newScope('echo');
    const start = Date.now();
    let bytes = 0;
    try {
        for await (const buf of stream) {
            bytes += buf.byteLength;
            if (!stream.send(buf)) {
                stream.pause();
                await pEvent(stream, 'drain', {
                    rejectionEvents: [
                        'close'
                    ],
                    ...options
                });
                stream.resume();
            }
        }
        log('echoed %d bytes in %dms', bytes, Date.now() - start);
        await stream.close(options);
    }
    catch (err) {
        stream.abort(err);
    }
}
function isMessageStream(obj) {
    return obj?.addEventListener != null;
}
export function messageStreamToDuplex(stream) {
    const source = pushable();
    let onError;
    const onMessage = (evt) => {
        source.push(evt.data);
    };
    const onRemoteCloseWrite = () => {
        source.end();
        stream.removeEventListener('message', onMessage);
        stream.removeEventListener('close', onClose);
        stream.removeEventListener('remoteCloseWrite', onRemoteCloseWrite);
    };
    const onClose = (evt) => {
        source.end(evt.error);
        if (evt.error != null) {
            onError?.reject(evt.error);
        }
        stream.removeEventListener('message', onMessage);
        stream.removeEventListener('close', onClose);
        stream.removeEventListener('remoteCloseWrite', onRemoteCloseWrite);
    };
    stream.addEventListener('message', onMessage);
    stream.addEventListener('close', onClose, {
        once: true
    });
    stream.addEventListener('remoteCloseWrite', onRemoteCloseWrite, {
        once: true
    });
    return {
        source,
        async sink(source) {
            async function* toGenerator() {
                yield* source;
            }
            const gen = toGenerator();
            while (true) {
                onError = Promise.withResolvers();
                const { done, value } = await Promise.race([
                    gen.next(),
                    onError.promise
                ]);
                if (stream.writeStatus === 'closing' || stream.writeStatus === 'closed') {
                    break;
                }
                if (value != null) {
                    if (!stream.send(value)) {
                        await Promise.race([
                            pEvent(stream, 'drain', {
                                rejectionEvents: [
                                    'close'
                                ]
                            })
                        ]);
                    }
                }
                if (done === true) {
                    break;
                }
            }
            await stream.close();
        }
    };
}
export function pipe(...input) {
    const sources = input.map(source => {
        if (isMessageStream(source)) {
            return messageStreamToDuplex(source);
        }
        return source;
    });
    // @ts-expect-error it-pipe types say args cannot be spread like this
    return itPipe(...sources);
}
//# sourceMappingURL=stream-utils.js.map