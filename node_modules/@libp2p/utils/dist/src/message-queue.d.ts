import { StreamMessageEvent } from '@libp2p/interface';
import { TypedEventEmitter } from 'main-event';
import type { Logger } from '@libp2p/interface';
export interface MessageQueueEvents {
    /**
     * Message data
     */
    message: StreamMessageEvent;
    /**
     * Emitted when the queue is empty
     */
    drain: Event;
    /**
     * The remote closed the connection abruptly
     */
    reset: Event;
}
export interface MessageQueueInit {
    /**
     * How much delay there should be between each message send in ms (note that
     * even 0 introduces a small delay)
     *
     * @default 0
     */
    delay?: number;
    /**
     * How many messages to hold in the send queue before applying backpressure to
     * the sender
     */
    capacity?: number;
    /**
     * Data messages larger than this size will be chunked into smaller messages.
     *
     * Defaults to the maximum TCP package size.
     *
     * @default 65_536
     */
    chunkSize?: number;
}
/**
 * Accepts events to emit after a short delay, and with a configurable maximum
 * queue capacity after which the send method will return false to let us
 * simulate write backpressure.
 */
export declare class MessageQueue<Events> extends TypedEventEmitter<Events & MessageQueueEvents> {
    needsDrain: boolean;
    private queue;
    private capacity;
    private delay;
    private log;
    private chunkSize;
    constructor(init: MessageQueueInit & {
        log: Logger;
    });
    send(evt: Event): boolean;
    pause(): void;
    resume(): void;
    onIdle(): Promise<void>;
    size(): number;
}
//# sourceMappingURL=message-queue.d.ts.map