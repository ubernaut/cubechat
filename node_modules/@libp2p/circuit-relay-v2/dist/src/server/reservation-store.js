import { trackedPeerMap } from '@libp2p/peer-collections';
import { retimeableSignal } from 'retimeable-signal';
import { DEFAULT_DATA_LIMIT, DEFAULT_DURATION_LIMIT, DEFAULT_MAX_RESERVATION_STORE_SIZE, DEFAULT_MAX_RESERVATION_TTL } from '../constants.js';
import { Status } from '../pb/index.js';
export class ReservationStore {
    reservations;
    maxReservations;
    applyDefaultLimit;
    reservationTtl;
    defaultDurationLimit;
    defaultDataLimit;
    log;
    constructor(components, init = {}) {
        this.log = components.logger.forComponent('libp2p:circuit-relay:server:reservation-store');
        this.maxReservations = init.maxReservations ?? DEFAULT_MAX_RESERVATION_STORE_SIZE;
        this.applyDefaultLimit = init.applyDefaultLimit !== false;
        this.reservationTtl = init.reservationTtl ?? DEFAULT_MAX_RESERVATION_TTL;
        this.defaultDurationLimit = init.defaultDurationLimit ?? DEFAULT_DURATION_LIMIT;
        this.defaultDataLimit = init.defaultDataLimit ?? DEFAULT_DATA_LIMIT;
        this.reservations = trackedPeerMap({
            metrics: components.metrics,
            name: 'libp2p_circuit_relay_server_reservations_total'
        });
    }
    reserve(peer, addr, limit) {
        let reservation = this.reservations.get(peer);
        if (this.reservations.size >= this.maxReservations && reservation == null) {
            return { status: Status.RESERVATION_REFUSED };
        }
        const expiry = new Date(Date.now() + this.reservationTtl);
        let checkedLimit;
        if (this.applyDefaultLimit) {
            checkedLimit = limit ?? {
                data: this.defaultDataLimit,
                duration: this.defaultDurationLimit
            };
        }
        if (reservation != null) {
            this.log('refreshing reservation for client %p', peer);
            reservation.signal.reset(this.reservationTtl);
        }
        else {
            this.log('creating new reservation for client %p', peer);
            reservation = {
                addr,
                expiry,
                limit: checkedLimit,
                signal: retimeableSignal(this.reservationTtl)
            };
        }
        this.reservations.set(peer, reservation);
        reservation.signal.addEventListener('abort', () => {
            this.reservations.delete(peer);
        });
        // return expiry time in seconds
        return { status: Status.OK, expire: Math.round(expiry.getTime() / 1000) };
    }
    removeReservation(peer) {
        this.reservations.delete(peer);
    }
    get(peer) {
        return this.reservations.get(peer);
    }
    clear() {
        this.reservations.clear();
    }
}
//# sourceMappingURL=reservation-store.js.map