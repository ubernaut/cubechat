import { TypedEventEmitter } from 'main-event';
import type { TransportReservationStoreComponents, TransportReservationStoreInit } from '../index.ts';
import type { Reservation } from '../pb/index.js';
import type { PeerId, Startable } from '@libp2p/interface';
export type RelayType = 'discovered' | 'configured';
export interface DiscoveredRelayEntry {
    timeout: ReturnType<typeof setTimeout>;
    type: 'discovered';
    reservation: Reservation;
    /**
     * Stores the id of the connection we have to the relay
     */
    connection: string;
    /**
     * Stores the identifier returned when the reservation was requested
     */
    id: string;
}
export interface ConfiguredRelayEntry {
    timeout: ReturnType<typeof setTimeout>;
    type: 'configured';
    reservation: Reservation;
    /**
     * Stores the id of the connection we have to the relay
     */
    connection: string;
}
export type RelayEntry = DiscoveredRelayEntry | ConfiguredRelayEntry;
export interface RelayReservation {
    relay: PeerId;
    details: RelayEntry;
}
export interface ReservationStoreEvents {
    'relay:not-enough-relays': CustomEvent;
    'relay:found-enough-relays': CustomEvent;
    'relay:removed': CustomEvent<RelayReservation>;
    'relay:created-reservation': CustomEvent<RelayReservation>;
}
export declare class ReservationStore extends TypedEventEmitter<ReservationStoreEvents> implements Startable {
    #private;
    private readonly peerId;
    private readonly connectionManager;
    private readonly peerStore;
    private readonly events;
    private readonly reserveQueue;
    private readonly reservations;
    private readonly pendingReservations;
    private readonly maxReservationQueueLength;
    private readonly reservationCompletionTimeout;
    private started;
    private readonly log;
    private relayFilter;
    constructor(components: TransportReservationStoreComponents, init?: TransportReservationStoreInit);
    isStarted(): boolean;
    start(): void;
    afterStart(): void;
    stop(): void;
    reserveRelay(): string;
    /**
     * If the number of current relays is beneath the configured `maxReservations`
     * value, and the passed peer id is not our own, and we have a non-relayed
     * connection to the remote, and the remote peer speaks the hop protocol, try
     * to reserve a slot on the remote peer
     */
    addRelay(peerId: PeerId, type: RelayType): Promise<RelayReservation>;
    hasReservation(peerId: PeerId): boolean;
    getReservation(peerId: PeerId): Reservation | undefined;
    reservationCount(type?: RelayType): number;
    cancelReservations(): void;
}
//# sourceMappingURL=reservation-store.d.ts.map