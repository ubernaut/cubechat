import { setMaxListeners } from '@libp2p/interface';
import { pipe } from '@libp2p/utils';
import { CODE_P2P_CIRCUIT } from '@multiformats/multiaddr';
import { P2P } from '@multiformats/multiaddr-matcher';
import { fmt, code, and } from '@multiformats/multiaddr-matcher/utils';
import { anySignal } from 'any-signal';
import { CID } from 'multiformats/cid';
import { sha256 } from 'multiformats/hashes/sha2';
import { DurationLimitError, TransferLimitError } from './errors.js';
function countStreamBytes(source, limit, options) {
    const limitBytes = limit.remaining;
    const abortIfStreamByteLimitExceeded = (evt) => {
        const len = BigInt(evt.data.byteLength);
        limit.remaining -= len;
        if (limit.remaining < 0) {
            source.abort(new TransferLimitError(`data limit of ${limitBytes} bytes exceeded`));
        }
    };
    source.addEventListener('message', abortIfStreamByteLimitExceeded);
}
export function createLimitedRelay(src, dst, abortSignal, reservation, options) {
    function abortStreams(err) {
        src.abort(err);
        dst.abort(err);
    }
    // combine shutdown signal and reservation expiry signal
    const signals = [abortSignal, reservation.signal];
    if (reservation.limit?.duration != null) {
        options.log('limiting relayed connection duration to %dms', reservation.limit.duration);
        const durationSignal = AbortSignal.timeout(reservation.limit.duration);
        setMaxListeners(Infinity, durationSignal);
        signals.push(durationSignal);
    }
    const signal = anySignal(signals);
    setMaxListeners(Infinity, signal);
    let dataLimit;
    if (reservation.limit?.data != null) {
        dataLimit = {
            remaining: reservation.limit.data
        };
    }
    const onAbort = () => {
        let err;
        if (abortSignal.aborted) {
            err = abortSignal.reason;
        }
        else {
            err = new DurationLimitError(`duration limit of ${reservation.limit?.duration} ms exceeded`);
        }
        abortStreams(err);
    };
    signal.addEventListener('abort', onAbort, { once: true });
    if (dataLimit != null) {
        countStreamBytes(dst, dataLimit, options);
        countStreamBytes(src, dataLimit, options);
    }
    // join the streams together
    pipe(src, dst, src)
        .catch(err => {
        abortStreams(err);
    })
        .finally(() => {
        signal.clear();
    });
}
/**
 * Convert a namespace string into a cid
 */
export async function namespaceToCid(namespace) {
    const bytes = new TextEncoder().encode(namespace);
    const hash = await sha256.digest(bytes);
    return CID.createV0(hash);
}
/**
 * returns number of ms between now and expiration time
 */
export function getExpirationMilliseconds(expireTimeSeconds) {
    const expireTimeMillis = expireTimeSeconds * BigInt(1000);
    const currentTime = new Date().getTime();
    // downcast to number to use with setTimeout
    return Number(expireTimeMillis - BigInt(currentTime));
}
export class LimitTracker {
    expires;
    bytes;
    constructor(limits) {
        if (limits?.duration != null && limits?.duration !== 0) {
            this.expires = Date.now() + (limits.duration * 1000);
        }
        this.bytes = limits?.data;
        if (this.bytes === 0n) {
            this.bytes = undefined;
        }
        this.onData = this.onData.bind(this);
    }
    onData(buf) {
        if (this.bytes == null) {
            return;
        }
        this.bytes -= BigInt(buf.byteLength);
        if (this.bytes < 0n) {
            this.bytes = 0n;
        }
    }
    getLimits() {
        if (this.expires == null && this.bytes == null) {
            return;
        }
        const output = {};
        if (this.bytes != null) {
            const self = this;
            Object.defineProperty(output, 'bytes', {
                get() {
                    return self.bytes;
                }
            });
        }
        if (this.expires != null) {
            const self = this;
            Object.defineProperty(output, 'seconds', {
                get() {
                    return Math.round(((self.expires ?? 0) - Date.now()) / 1000);
                }
            });
        }
        return output;
    }
}
/**
 * A custom matcher that tells us to listen on a particular relay
 */
export const CircuitListen = fmt(and(P2P.matchers[0], code(CODE_P2P_CIRCUIT)));
/**
 * A custom matcher that tells us to discover available relays
 */
export const CircuitSearch = fmt(code(CODE_P2P_CIRCUIT));
//# sourceMappingURL=utils.js.map