import type { AbortOptions } from '@libp2p/interface';
export interface RepeatingTask {
    /**
     * Update the interval after which the next iteration of the task will run.
     *
     * This is useful if, for example, you want to retry a task with a short rest
     * duration until it succeeds, then periodically after that.
     *
     * This only affects the next iteration of the task, if it is currently
     * running, that run will not be interrupted.
     *
     * Setting the interval to the current value has no effect.
     */
    setInterval(ms: number): void;
    /**
     * Update the amount of time a task will run before the passed abort signal
     * will fire.
     *
     * This only affects the next iteration of the task, if it is currently
     * running, that run will not be interrupted.
     */
    setTimeout(ms: number): void;
    /**
     * Schedule the task to be run immediately - if the task is not running it
     * will run after a short delay in order to debounce multiple `.run()`
     * invocations.
     */
    run(): void;
    /**
     * Start the task running
     */
    start(): void;
    /**
     * Stop the task running
     */
    stop(): void;
}
export interface RepeatingTaskOptions {
    /**
     * How long the task is allowed to run before the passed AbortSignal fires an
     * abort event
     */
    timeout?: number;
    /**
     * Whether to schedule the task to run immediately
     *
     * @default false
     */
    runImmediately?: boolean;
    /**
     * When `.run()` is called to run the task outside of the current interval,
     * debounce repeated calls to `.run()` by this amount.
     *
     * @default 100
     */
    debounce?: number;
}
export declare function repeatingTask(fn: (options?: AbortOptions) => void | Promise<void>, interval: number, options?: RepeatingTaskOptions): RepeatingTask;
//# sourceMappingURL=repeating-task.d.ts.map