{
  "version": 3,
  "sources": ["../src/index.ts", "../../interface/src/errors.ts", "../../interface/src/events.ts", "../../interface/src/transport.ts", "../../../node_modules/main-event/src/index.ts", "../../interface/src/index.ts", "../../../node_modules/uint8arrays/src/equals.ts", "../../../node_modules/uint8arrays/src/alloc.ts", "../../../node_modules/uint8-varint/src/index.ts", "../../../node_modules/uint8arrays/src/concat.ts", "../../../node_modules/multiformats/src/bases/base10.ts", "../../../node_modules/multiformats/src/bytes.ts", "../../../node_modules/multiformats/src/vendor/base-x.js", "../../../node_modules/multiformats/src/bases/base.ts", "../../../node_modules/multiformats/src/bases/base16.ts", "../../../node_modules/multiformats/src/bases/base2.ts", "../../../node_modules/multiformats/src/bases/base256emoji.ts", "../../../node_modules/multiformats/src/bases/base32.ts", "../../../node_modules/multiformats/src/bases/base36.ts", "../../../node_modules/multiformats/src/bases/base58.ts", "../../../node_modules/multiformats/src/bases/base64.ts", "../../../node_modules/multiformats/src/bases/base8.ts", "../../../node_modules/multiformats/src/bases/identity.ts", "../../../node_modules/multiformats/src/codecs/json.ts", "../../../node_modules/multiformats/src/hashes/identity.ts", "../../../node_modules/multiformats/src/vendor/varint.js", "../../../node_modules/multiformats/src/varint.ts", "../../../node_modules/multiformats/src/hashes/digest.ts", "../../../node_modules/multiformats/src/hashes/sha2-browser.ts", "../../../node_modules/multiformats/src/hashes/hasher.ts", "../../../node_modules/multiformats/src/cid.ts", "../../../node_modules/multiformats/src/basics.ts", "../../../node_modules/uint8arrays/src/util/bases.ts", "../../../node_modules/uint8arrays/src/from-string.ts", "../../../node_modules/uint8arrays/src/to-string.ts", "../../../node_modules/@multiformats/multiaddr/src/errors.ts", "../../../node_modules/@chainsafe/is-ip/src/parser.ts", "../../../node_modules/@chainsafe/is-ip/src/parse.ts", "../../../node_modules/@chainsafe/is-ip/src/is-ip.ts", "../../../node_modules/@multiformats/multiaddr/src/utils.ts", "../../../node_modules/@multiformats/multiaddr/src/validation.ts", "../../../node_modules/@multiformats/multiaddr/src/registry.ts", "../../../node_modules/@multiformats/multiaddr/src/components.ts", "../../../node_modules/@multiformats/multiaddr/src/multiaddr.ts", "../../../node_modules/@multiformats/multiaddr/src/index.ts", "../../../node_modules/@multiformats/multiaddr-matcher/src/utils.ts", "../../../node_modules/@multiformats/multiaddr-matcher/src/index.ts", "../../../node_modules/@multiformats/multiaddr-to-uri/src/index.ts", "../../../node_modules/p-event/node_modules/p-timeout/index.js", "../../../node_modules/p-event/index.js", "../../../node_modules/progress-events/src/index.ts", "../src/listener.browser.ts", "../../../node_modules/uint8arraylist/src/index.ts", "../../../node_modules/p-defer/index.js", "../../../node_modules/it-pushable/src/fifo.ts", "../../../node_modules/it-pushable/src/index.ts", "../../utils/src/debounce.ts", "../../utils/src/errors.ts", "../../../node_modules/race-signal/src/index.ts", "../../utils/src/abstract-message-stream.ts", "../../utils/src/abstract-multiaddr-connection.ts", "../../../node_modules/any-signal/src/index.ts", "../../utils/src/repeating-task.ts", "../src/websocket-to-conn.ts"],
  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * A [libp2p transport](https://docs.libp2p.io/concepts/transports/overview/) based on [WebSockets](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API).\n *\n * @example\n *\n * ```TypeScript\n * import { createLibp2p } from 'libp2p'\n * import { webSockets } from '@libp2p/websockets'\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const node = await createLibp2p({\n *   transports: [\n *     webSockets()\n *   ]\n * //... other config\n * })\n * await node.start()\n *\n * const ma = multiaddr('/dns4/example.com/tcp/9090/tls/ws')\n * await node.dial(ma)\n * ```\n */\n\nimport { transportSymbol, serviceCapabilities, ConnectionFailedError } from '@libp2p/interface'\nimport { WebSockets as WebSocketsMatcher, WebSocketsSecure } from '@multiformats/multiaddr-matcher'\nimport { multiaddrToUri as toUri } from '@multiformats/multiaddr-to-uri'\nimport { pEvent } from 'p-event'\nimport { CustomProgressEvent } from 'progress-events'\nimport { createListener } from './listener.js'\nimport { webSocketToMaConn } from './websocket-to-conn.js'\nimport type { Transport, CreateListenerOptions, DialTransportOptions, Listener, AbortOptions, ComponentLogger, Logger, Connection, OutboundConnectionUpgradeEvents, Metrics, CounterGroup, Libp2pEvents } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { TypedEventTarget } from 'main-event'\nimport type http from 'node:http'\nimport type https from 'node:https'\nimport type { ProgressEvent } from 'progress-events'\n\nexport interface WebSocketsInit extends AbortOptions {\n  /**\n   * Options used to create the HTTP server\n   */\n  http?: http.ServerOptions\n\n  /**\n   * Options used to create the HTTPs server. `options.http` will be used if\n   * unspecified.\n   */\n  https?: https.ServerOptions\n\n  /**\n   * How large the outgoing [bufferedAmount](https://websockets.spec.whatwg.org/#dom-websocket-bufferedamount)\n   * property of incoming and outgoing websockets is allowed to get in bytes.\n   *\n   * If this limit is exceeded, backpressure will be applied to the writer.\n   *\n   * @default 4_194_304\n   */\n  maxBufferedAmount?: number\n\n  /**\n   * If the [bufferedAmount](https://websockets.spec.whatwg.org/#dom-websocket-bufferedamount)\n   * property of a WebSocket exceeds `maxBufferedAmount`, poll the field every\n   * this number of ms to see if the socket can accept new data.\n   *\n   * @default 500\n   */\n  bufferedAmountPollInterval?: number\n}\n\nexport interface WebSocketsComponents {\n  logger: ComponentLogger\n  events: TypedEventTarget<Libp2pEvents>\n  metrics?: Metrics\n}\n\nexport interface WebSocketsMetrics {\n  dialerEvents: CounterGroup\n}\n\nexport type WebSocketsDialEvents =\n  OutboundConnectionUpgradeEvents |\n  ProgressEvent<'websockets:open-connection'>\n\nclass WebSockets implements Transport<WebSocketsDialEvents> {\n  private readonly log: Logger\n  private readonly init: WebSocketsInit\n  private readonly logger: ComponentLogger\n  private readonly metrics?: WebSocketsMetrics\n  private readonly components: WebSocketsComponents\n\n  constructor (components: WebSocketsComponents, init: WebSocketsInit = {}) {\n    this.log = components.logger.forComponent('libp2p:websockets')\n    this.logger = components.logger\n    this.components = components\n    this.init = init\n\n    if (components.metrics != null) {\n      this.metrics = {\n        dialerEvents: components.metrics.registerCounterGroup('libp2p_websockets_dialer_events_total', {\n          label: 'event',\n          help: 'Total count of WebSockets dialer events by type'\n        })\n      }\n    }\n  }\n\n  readonly [transportSymbol] = true\n\n  readonly [Symbol.toStringTag] = '@libp2p/websockets'\n\n  readonly [serviceCapabilities]: string[] = [\n    '@libp2p/transport'\n  ]\n\n  async dial (ma: Multiaddr, options: DialTransportOptions<WebSocketsDialEvents>): Promise<Connection> {\n    this.log('dialing %s', ma)\n    options = options ?? {}\n\n    const maConn = webSocketToMaConn({\n      websocket: await this._connect(ma, options),\n      remoteAddr: ma,\n      metrics: this.metrics?.dialerEvents,\n      direction: 'outbound',\n      log: this.components.logger.forComponent('libp2p:websockets:connection'),\n      maxBufferedAmount: this.init.maxBufferedAmount,\n      bufferedAmountPollInterval: this.init.bufferedAmountPollInterval\n    })\n    this.log('new outbound connection %s', maConn.remoteAddr)\n\n    const conn = await options.upgrader.upgradeOutbound(maConn, options)\n    this.log('outbound connection %s upgraded', maConn.remoteAddr)\n    return conn\n  }\n\n  async _connect (ma: Multiaddr, options: DialTransportOptions<WebSocketsDialEvents>): Promise<WebSocket> {\n    options?.signal?.throwIfAborted()\n\n    const uri = toUri(ma)\n    this.log('create websocket connection to %s', uri)\n    const websocket = new WebSocket(uri)\n    websocket.binaryType = 'arraybuffer'\n\n    try {\n      options.onProgress?.(new CustomProgressEvent('websockets:open-connection'))\n      await pEvent(websocket, 'open', options)\n    } catch (err: any) {\n      if (options.signal?.aborted) {\n        this.metrics?.dialerEvents.increment({ abort: true })\n        throw new ConnectionFailedError(`Could not connect to ${uri}`)\n      } else {\n        this.metrics?.dialerEvents.increment({ error: true })\n      }\n\n      try {\n        websocket.close()\n      } catch {}\n\n      throw err\n    }\n\n    this.log('connected %s', ma)\n    this.metrics?.dialerEvents.increment({ connect: true })\n    return websocket\n  }\n\n  /**\n   * Creates a WebSockets listener. The provided `handler` function will be called\n   * anytime a new incoming Connection has been successfully upgraded via\n   * `upgrader.upgradeInbound`\n   */\n  createListener (options: CreateListenerOptions): Listener {\n    return createListener({\n      logger: this.logger,\n      events: this.components.events,\n      metrics: this.components.metrics\n    }, {\n      ...this.init,\n      ...options\n    })\n  }\n\n  listenFilter (multiaddrs: Multiaddr[]): Multiaddr[] {\n    return multiaddrs.filter(ma => WebSocketsMatcher.exactMatch(ma) || WebSocketsSecure.exactMatch(ma))\n  }\n\n  dialFilter (multiaddrs: Multiaddr[]): Multiaddr[] {\n    return this.listenFilter(multiaddrs)\n  }\n}\n\nexport function webSockets (init: WebSocketsInit = {}): (components: WebSocketsComponents) => Transport {\n  return (components) => {\n    return new WebSockets(components, init)\n  }\n}\n", "/**\n * When this error is thrown it means an operation was aborted,\n * usually in response to the `abort` event being emitted by an\n * AbortSignal.\n */\nexport class AbortError extends Error {\n  static name = 'AbortError'\n\n  constructor (message: string = 'The operation was aborted') {\n    super(message)\n    this.name = 'AbortError'\n  }\n}\n\n/**\n * Thrown when a remote Peer ID does not match the expected one\n */\nexport class UnexpectedPeerError extends Error {\n  static name = 'UnexpectedPeerError'\n\n  constructor (message = 'Unexpected Peer') {\n    super(message)\n    this.name = 'UnexpectedPeerError'\n  }\n}\n\n/**\n * Thrown when a crypto exchange fails\n */\nexport class InvalidCryptoExchangeError extends Error {\n  static name = 'InvalidCryptoExchangeError'\n\n  constructor (message = 'Invalid crypto exchange') {\n    super(message)\n    this.name = 'InvalidCryptoExchangeError'\n  }\n}\n\n/**\n * Thrown when invalid parameters are passed to a function or method call\n */\nexport class InvalidParametersError extends Error {\n  static name = 'InvalidParametersError'\n\n  constructor (message = 'Invalid parameters') {\n    super(message)\n    this.name = 'InvalidParametersError'\n  }\n}\n\n/**\n * Thrown when a public key is invalid\n */\nexport class InvalidPublicKeyError extends Error {\n  static name = 'InvalidPublicKeyError'\n\n  constructor (message = 'Invalid public key') {\n    super(message)\n    this.name = 'InvalidPublicKeyError'\n  }\n}\n\n/**\n * Thrown when a private key is invalid\n */\nexport class InvalidPrivateKeyError extends Error {\n  static name = 'InvalidPrivateKeyError'\n\n  constructor (message = 'Invalid private key') {\n    super(message)\n    this.name = 'InvalidPrivateKeyError'\n  }\n}\n\n/**\n * Thrown when a operation is unsupported\n */\nexport class UnsupportedOperationError extends Error {\n  static name = 'UnsupportedOperationError'\n\n  constructor (message = 'Unsupported operation') {\n    super(message)\n    this.name = 'UnsupportedOperationError'\n  }\n}\n\n/**\n * Thrown when a connection is closing\n */\nexport class ConnectionClosingError extends Error {\n  static name = 'ConnectionClosingError'\n\n  constructor (message = 'The connection is closing') {\n    super(message)\n    this.name = 'ConnectionClosingError'\n  }\n}\n\n/**\n * Thrown when a connection is closed\n */\nexport class ConnectionClosedError extends Error {\n  static name = 'ConnectionClosedError'\n\n  constructor (message = 'The connection is closed') {\n    super(message)\n    this.name = 'ConnectionClosedError'\n  }\n}\n\n/**\n * Thrown when a connection fails\n */\nexport class ConnectionFailedError extends Error {\n  static name = 'ConnectionFailedError'\n\n  constructor (message = 'Connection failed') {\n    super(message)\n    this.name = 'ConnectionFailedError'\n  }\n}\n\n/**\n * Thrown when the muxer is closed and an attempt to open a stream occurs\n */\nexport class MuxerClosedError extends Error {\n  static name = 'MuxerClosedError'\n\n  constructor (message = 'The muxer is closed') {\n    super(message)\n    this.name = 'MuxerClosedError'\n  }\n}\n\n/**\n * Thrown when a protocol stream is reset by the remote muxer\n */\nexport class StreamResetError extends Error {\n  static name = 'StreamResetError'\n\n  constructor (message = 'The stream has been reset') {\n    super(message)\n    this.name = 'StreamResetError'\n  }\n}\n\n/**\n * Thrown when a protocol stream is aborted locally\n */\nexport class StreamAbortedError extends Error {\n  static name = 'StreamAbortedError'\n\n  constructor (message = 'The stream has been aborted') {\n    super(message)\n    this.name = 'StreamAbortedError'\n  }\n}\n\n/**\n * Thrown when a stream is in an invalid state\n */\nexport class StreamStateError extends Error {\n  static name = 'StreamStateError'\n\n  constructor (message = 'The stream is in an invalid state') {\n    super(message)\n    this.name = 'StreamStateError'\n  }\n}\n\n/**\n * Thrown when a stream buffer is full\n */\nexport class StreamBufferError extends Error {\n  static name = 'StreamBufferError'\n\n  constructor (message = 'The stream buffer was full') {\n    super(message)\n    this.name = 'StreamBufferError'\n  }\n}\n\n/**\n * Thrown when a value could not be found\n */\nexport class NotFoundError extends Error {\n  static name = 'NotFoundError'\n\n  constructor (message = 'Not found') {\n    super(message)\n    this.name = 'NotFoundError'\n  }\n}\n\n/**\n * Thrown when an invalid peer ID is encountered\n */\nexport class InvalidPeerIdError extends Error {\n  static name = 'InvalidPeerIdError'\n\n  constructor (message = 'Invalid PeerID') {\n    super(message)\n    this.name = 'InvalidPeerIdError'\n  }\n}\n\n/**\n * Thrown when an invalid multiaddr is encountered\n */\nexport class InvalidMultiaddrError extends Error {\n  static name = 'InvalidMultiaddrError'\n\n  constructor (message = 'Invalid multiaddr') {\n    super(message)\n    this.name = 'InvalidMultiaddrError'\n  }\n}\n\n/**\n * Thrown when an invalid CID is encountered\n */\nexport class InvalidCIDError extends Error {\n  static name = 'InvalidCIDError'\n\n  constructor (message = 'Invalid CID') {\n    super(message)\n    this.name = 'InvalidCIDError'\n  }\n}\n\n/**\n * Thrown when an invalid multihash is encountered\n */\nexport class InvalidMultihashError extends Error {\n  static name = 'InvalidMultihashError'\n\n  constructor (message = 'Invalid Multihash') {\n    super(message)\n    this.name = 'InvalidMultihashError'\n  }\n}\n\n/**\n * Thrown when a protocol is not supported\n */\nexport class UnsupportedProtocolError extends Error {\n  static name = 'UnsupportedProtocolError'\n\n  constructor (message = 'Unsupported protocol error') {\n    super(message)\n    this.name = 'UnsupportedProtocolError'\n  }\n}\n\n/**\n * An invalid or malformed message was encountered during a protocol exchange\n */\nexport class InvalidMessageError extends Error {\n  static name = 'InvalidMessageError'\n\n  constructor (message = 'Invalid message') {\n    super(message)\n    this.name = 'InvalidMessageError'\n  }\n}\n\n/**\n * Thrown when a remote peer sends a structurally valid message that does not\n * comply with the protocol\n */\nexport class ProtocolError extends Error {\n  static name = 'ProtocolError'\n\n  constructor (message = 'Protocol error') {\n    super(message)\n    this.name = 'ProtocolError'\n  }\n}\n\n/**\n * Throw when an operation times out\n */\nexport class TimeoutError extends Error {\n  static name = 'TimeoutError'\n\n  constructor (message = 'Timed out') {\n    super(message)\n    this.name = 'TimeoutError'\n  }\n}\n\n/**\n * Thrown when a startable component is interacted with but it has not been\n * started yet\n */\nexport class NotStartedError extends Error {\n  static name = 'NotStartedError'\n\n  constructor (message = 'Not started') {\n    super(message)\n    this.name = 'NotStartedError'\n  }\n}\n\n/**\n * Thrown when a component is started that has already been started\n */\nexport class AlreadyStartedError extends Error {\n  static name = 'AlreadyStartedError'\n\n  constructor (message = 'Already started') {\n    super(message)\n    this.name = 'AlreadyStartedError'\n  }\n}\n\n/**\n * Thrown when dialing an address failed\n */\nexport class DialError extends Error {\n  static name = 'DialError'\n\n  constructor (message = 'Dial error') {\n    super(message)\n    this.name = 'DialError'\n  }\n}\n\n/**\n * Thrown when listening on an address failed\n */\nexport class ListenError extends Error {\n  static name = 'ListenError'\n\n  constructor (message = 'Listen error') {\n    super(message)\n    this.name = 'ListenError'\n  }\n}\n\n/**\n * This error is thrown when a limited connection is encountered, i.e. if the\n * user tried to open a stream on a connection for a protocol that is not\n * configured to run over limited connections.\n */\nexport class LimitedConnectionError extends Error {\n  static name = 'LimitedConnectionError'\n\n  constructor (message = 'Limited connection') {\n    super(message)\n    this.name = 'LimitedConnectionError'\n  }\n}\n\n/**\n * This error is thrown where there are too many inbound protocols streams open\n */\nexport class TooManyInboundProtocolStreamsError extends Error {\n  static name = 'TooManyInboundProtocolStreamsError'\n\n  constructor (message = 'Too many inbound protocol streams') {\n    super(message)\n    this.name = 'TooManyInboundProtocolStreamsError'\n  }\n}\n\n/**\n * This error is thrown where there are too many outbound protocols streams open\n */\nexport class TooManyOutboundProtocolStreamsError extends Error {\n  static name = 'TooManyOutboundProtocolStreamsError'\n\n  constructor (message = 'Too many outbound protocol streams') {\n    super(message)\n    this.name = 'TooManyOutboundProtocolStreamsError'\n  }\n}\n\n/**\n * Thrown when an attempt to operate on an unsupported key was made\n */\nexport class UnsupportedKeyTypeError extends Error {\n  static name = 'UnsupportedKeyTypeError'\n\n  constructor (message = 'Unsupported key type') {\n    super(message)\n    this.name = 'UnsupportedKeyTypeError'\n  }\n}\n\n/**\n * Thrown when an operation has not been implemented\n */\nexport class NotImplementedError extends Error {\n  static name = 'NotImplementedError'\n\n  constructor (message = 'Not implemented') {\n    super(message)\n    this.name = 'NotImplementedError'\n  }\n}\n", "import type { Uint8ArrayList } from 'uint8arraylist'\n\n/**\n * A custom implementation of MessageEvent as the Undici version does too much\n * validation in it's constructor so is very slow.\n */\nexport class StreamMessageEvent extends Event {\n  public data: Uint8Array | Uint8ArrayList\n\n  constructor (data: Uint8Array | Uint8ArrayList, eventInitDict?: EventInit) {\n    super('message', eventInitDict)\n\n    this.data = data\n  }\n}\n\n/**\n * An event dispatched when the stream is closed. The `error` property can be\n * inspected to discover if the closing was graceful or not, and the `remote`\n * property shows which end of the stream initiated the closure\n */\nexport class StreamCloseEvent extends Event {\n  public error?: Error\n  public local?: boolean\n\n  constructor (local?: boolean, error?: Error, eventInitDict?: EventInit) {\n    super('close', eventInitDict)\n\n    this.error = error\n    this.local = local\n  }\n}\n\nexport class StreamAbortEvent extends StreamCloseEvent {\n  constructor (error: Error, eventInitDict?: EventInit) {\n    super(true, error, eventInitDict)\n  }\n}\n\nexport class StreamResetEvent extends StreamCloseEvent {\n  constructor (error: Error, eventInitDict?: EventInit) {\n    super(false, error, eventInitDict)\n  }\n}\n", "import type { AbortOptions, ClearableSignal, ConnectionEncrypter, MultiaddrConnection, Connection, ConnectionLimits, StreamMuxerFactory, PeerId } from './index.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { TypedEventTarget } from 'main-event'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\nexport interface ListenerEvents {\n  /**\n   * This event signals to the transport manager that the listening addresses\n   * have changed and may be emitted at any point and/or multiple times\n   */\n  listening: CustomEvent\n\n  /**\n   * Emitted if listening on an address failed\n   */\n  error: CustomEvent<Error>\n\n  /**\n   * Emitted when the listener has been shut down, has no open connections and\n   * will no longer accept new connections\n   */\n  close: CustomEvent\n}\n\nexport interface Listener extends TypedEventTarget<ListenerEvents> {\n  /**\n   * Start a listener\n   */\n  listen(multiaddr: Multiaddr): Promise<void>\n\n  /**\n   * Get listen addresses\n   */\n  getAddrs(): Multiaddr[]\n\n  /**\n   * Close listener\n   *\n   * @returns {Promise<void>}\n   */\n  close(): Promise<void>\n\n  /**\n   * Allows transports to amend announce addresses - to add certificate hashes\n   * or other metadata that cannot be known before runtime\n   */\n  updateAnnounceAddrs(addrs: Multiaddr[]): void\n}\n\nexport const transportSymbol = Symbol.for('@libp2p/transport')\n\n/**\n * A filter that acts on a list of multiaddrs\n */\nexport interface MultiaddrFilter {\n  (multiaddrs: Multiaddr[]): Multiaddr[]\n}\n\nexport interface CreateListenerOptions {\n  /**\n   * The upgrader turns a MultiaddrConnection into a Connection and notifies\n   * other libp2p components about a new incoming connection.\n   */\n  upgrader: Upgrader\n}\n\nexport interface DialTransportOptions<DialEvents extends ProgressEvent = ProgressEvent> extends Required<AbortOptions>, ProgressOptions<DialEvents> {\n  /**\n   * The upgrader turns a MultiaddrConnection into a Connection which should be\n   * returned by the transport's dial method\n   */\n  upgrader: Upgrader\n}\n\n/**\n * A libp2p transport offers dial and listen methods to establish connections.\n */\nexport interface Transport<DialEvents extends ProgressEvent = ProgressEvent> {\n  /**\n   * Used to identify the transport\n   */\n  [Symbol.toStringTag]: string\n\n  /**\n   * Used by the isTransport function\n   */\n  [transportSymbol]: true\n\n  /**\n   * Dial a given multiaddr.\n   */\n  dial(ma: Multiaddr, options: DialTransportOptions<DialEvents>): Promise<Connection>\n\n  /**\n   * Create transport listeners.\n   */\n  createListener(options: CreateListenerOptions): Listener\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only addresses that are valid for\n   * the transport to listen on\n   */\n  listenFilter: MultiaddrFilter\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only addresses that are valid for\n   * the transport to dial\n   */\n  dialFilter: MultiaddrFilter\n}\n\n/**\n * Used to disambiguate transport implementations\n */\nexport function isTransport (other?: any): other is Transport {\n  return other != null && Boolean(other[transportSymbol])\n}\n\n/**\n * Enum Transport Manager Fault Tolerance values\n */\nexport enum FaultTolerance {\n  /**\n   * should be used for failing in any listen circumstance\n   */\n  FATAL_ALL = 0,\n\n  /**\n   * should be used for not failing when not listening\n   */\n  NO_FATAL\n}\n\n/**\n * Options accepted by the upgrader during connection establishment\n */\nexport interface UpgraderOptions<ConnectionUpgradeEvents extends ProgressEvent = ProgressEvent> extends ProgressOptions<ConnectionUpgradeEvents>, Required<AbortOptions> {\n  /**\n   * If true no connection protection will be performed on the connection.\n   */\n  skipProtection?: boolean\n\n  /**\n   * By default a stream muxer protocol will be negotiated via multi-stream\n   * select after an encryption protocol has been agreed on.\n   *\n   * If a transport provides it's own stream muxing facility pass a muxer\n   * factory instance here to skip muxer negotiation.\n   */\n  muxerFactory?: StreamMuxerFactory\n\n  /**\n   * If the connection is to have limits applied to it, pass them here\n   */\n  limits?: ConnectionLimits\n\n  /**\n   * Multi-stream select is a initiator/responder protocol. By default a\n   * connection returned from `upgrader.upgradeOutbound` will be the initiator\n   * and one returned from `upgrader.upgradeInbound` will be the responder.\n   *\n   * Pass a value here to override the default.\n   */\n  initiator?: boolean\n}\n\n/**\n * Options accepted by the upgrader during connection establishment\n */\nexport interface UpgraderWithoutEncryptionOptions extends UpgraderOptions {\n  /**\n   * If true the invoking transport is expected to implement it's own encryption\n   * and an encryption protocol will not attempted to be negotiated via\n   * multi-stream select\n   */\n  skipEncryption: true\n\n  /**\n   * If `skipEncryption` is true, a remote PeerId must be supplied\n   */\n  remotePeer: PeerId\n}\n\nexport type InboundConnectionUpgradeEvents =\nProgressEvent<'upgrader:encrypt-inbound-connection'> |\nProgressEvent<'upgrader:multiplex-inbound-connection'>\n\nexport type OutboundConnectionUpgradeEvents =\nProgressEvent<'upgrader:encrypt-outbound-connection'> |\nProgressEvent<'upgrader:multiplex-outbound-connection'>\n\nexport interface Upgrader {\n  /**\n   * Upgrades an outbound connection created by the `dial` method of a transport\n   */\n  upgradeOutbound(maConn: MultiaddrConnection, opts: UpgraderOptions<OutboundConnectionUpgradeEvents>): Promise<Connection>\n  upgradeOutbound(maConn: MultiaddrConnection, opts: UpgraderWithoutEncryptionOptions): Promise<Connection>\n\n  /**\n   * Upgrades an inbound connection received by a transport listener and\n   * notifies other libp2p components about the new connection\n   */\n  upgradeInbound(maConn: MultiaddrConnection, opts: UpgraderOptions<InboundConnectionUpgradeEvents>): Promise<void>\n  upgradeInbound(maConn: MultiaddrConnection, opts: UpgraderWithoutEncryptionOptions): Promise<void>\n\n  /**\n   * Used by transports that perform part of the upgrade process themselves and\n   * do some async work. This allows configuring inbound upgrade timeouts from a\n   * single location.\n   *\n   * Regular transports should just pass the signal from their shutdown\n   * controller to `upgradeInbound`.\n   */\n  createInboundAbortSignal (signal: AbortSignal): ClearableSignal\n\n  /**\n   * Returns configured stream muxers\n   */\n  getStreamMuxers (): Map<string, StreamMuxerFactory>\n\n  /**\n   * Returns configured connection encrypters\n   */\n  getConnectionEncrypters (): Map<string, ConnectionEncrypter>\n}\n", "/**\n * @packageDocumentation\n *\n * Adds types to the EventTarget class.\n *\n * Hopefully this won't be necessary\n * forever:\n *\n * - https://github.com/microsoft/TypeScript/issues/28357\n * - https://github.com/microsoft/TypeScript/issues/43477\n * - https://github.com/microsoft/TypeScript/issues/299\n * - https://www.npmjs.com/package/typed-events\n * - https://www.npmjs.com/package/typed-event-emitter\n * - https://www.npmjs.com/package/typed-event-target\n * - etc\n *\n * In addition to types, a `safeDispatchEvent` method is available which\n * prevents dispatching events that aren't in the event map, and a\n * `listenerCount` method which reports the number of listeners that are\n * currently registered for a given event.\n *\n * @example\n *\n * ```ts\n * import { TypedEventEmitter } from 'main-event'\n * import type { TypedEventTarget } from 'main-event'\n *\n * interface EventTypes {\n *   'test': CustomEvent<string>\n * }\n *\n * const target = new TypedEventEmitter<EventTypes>()\n *\n * // it's a regular EventTarget\n * console.info(target instanceof EventTarget) // true\n *\n * // register listeners normally\n * target.addEventListener('test', (evt) => {\n *   // evt is CustomEvent<string>\n * })\n *\n * // @ts-expect-error 'derp' is not in the event map\n * target.addEventListener('derp', () => {})\n *\n * // use normal dispatchEvent method\n * target.dispatchEvent(new CustomEvent('test', {\n *   detail: 'hello'\n * }))\n *\n * // use type safe dispatch method\n * target.safeDispatchEvent('test', {\n *   detail: 'world'\n * })\n *\n * // report listener count\n * console.info(target.listenerCount('test')) // 0\n *\n * // event emitters can be used purely as interfaces too\n * function acceptTarget (target: TypedEventTarget<EventTypes>) {\n *   // ...\n * }\n * ```\n */\n\nimport { setMaxListeners } from './events.js'\n\nexport interface EventCallback<EventType> { (evt: EventType): void }\nexport interface EventObject<EventType> { handleEvent: EventCallback<EventType> }\nexport type EventHandler<EventType> = EventCallback<EventType> | EventObject<EventType>\n\ninterface Listener {\n  once: boolean\n  callback: any\n}\n\n/**\n *\n */\nexport interface TypedEventTarget <EventMap extends Record<string, any>> extends EventTarget {\n  addEventListener<K extends keyof EventMap>(type: K, listener: EventHandler<EventMap[K]> | null, options?: boolean | AddEventListenerOptions): void\n\n  listenerCount (type: string): number\n\n  removeEventListener<K extends keyof EventMap>(type: K, listener?: EventHandler<EventMap[K]> | null, options?: boolean | EventListenerOptions): void\n\n  removeEventListener (type: string, listener?: EventHandler<Event>, options?: boolean | EventListenerOptions): void\n\n  safeDispatchEvent<Detail>(type: keyof EventMap, detail?: CustomEventInit<Detail>): boolean\n}\n\n/**\n * An implementation of a typed event target\n */\nexport class TypedEventEmitter<EventMap extends Record<string, any>> extends EventTarget implements TypedEventTarget<EventMap> {\n  readonly #listeners = new Map<any, Listener[]>()\n\n  constructor () {\n    super()\n\n    // silence MaxListenersExceededWarning warning on Node.js, this is a red\n    // herring almost all of the time\n    setMaxListeners(Infinity, this)\n  }\n\n  listenerCount (type: string): number {\n    const listeners = this.#listeners.get(type)\n\n    if (listeners == null) {\n      return 0\n    }\n\n    return listeners.length\n  }\n\n  addEventListener<K extends keyof EventMap>(type: K, listener: EventHandler<EventMap[K]> | null, options?: boolean | AddEventListenerOptions): void\n  addEventListener (type: string, listener: EventHandler<Event>, options?: boolean | AddEventListenerOptions): void {\n    super.addEventListener(type, listener, options)\n\n    let list = this.#listeners.get(type)\n\n    if (list == null) {\n      list = []\n      this.#listeners.set(type, list)\n    }\n\n    list.push({\n      callback: listener,\n      once: (options !== true && options !== false && options?.once) ?? false\n    })\n  }\n\n  removeEventListener<K extends keyof EventMap>(type: K, listener?: EventHandler<EventMap[K]> | null, options?: boolean | EventListenerOptions): void\n  removeEventListener (type: string, listener?: EventHandler<Event>, options?: boolean | EventListenerOptions): void {\n    super.removeEventListener(type.toString(), listener ?? null, options)\n\n    let list = this.#listeners.get(type)\n\n    if (list == null) {\n      return\n    }\n\n    list = list.filter(({ callback }) => callback !== listener)\n    this.#listeners.set(type, list)\n  }\n\n  dispatchEvent (event: Event): boolean {\n    const result = super.dispatchEvent(event)\n\n    let list = this.#listeners.get(event.type)\n\n    if (list == null) {\n      return result\n    }\n\n    list = list.filter(({ once }) => !once)\n    this.#listeners.set(event.type, list)\n\n    return result\n  }\n\n  safeDispatchEvent<Detail>(type: keyof EventMap, detail: CustomEventInit<Detail> = {}): boolean {\n    return this.dispatchEvent(new CustomEvent<Detail>(type as string, detail))\n  }\n}\n\nexport { setMaxListeners }\n", "/**\n * @packageDocumentation\n *\n * Exports a `Libp2p` type for modules to use as a type argument.\n *\n * @example\n *\n * ```typescript\n * import type { Libp2p } from '@libp2p/interface'\n *\n * function doSomethingWithLibp2p (node: Libp2p) {\n *   // ...\n * }\n * ```\n */\n\nimport type { Connection, NewStreamOptions } from './connection.js'\nimport type { ContentRouting } from './content-routing.js'\nimport type { Ed25519PublicKey, PublicKey, RSAPublicKey, Secp256k1PublicKey } from './keys.js'\nimport type { Metrics } from './metrics.js'\nimport type { Ed25519PeerId, PeerId, RSAPeerId, Secp256k1PeerId, URLPeerId } from './peer-id.js'\nimport type { PeerInfo } from './peer-info.js'\nimport type { PeerRouting } from './peer-routing.js'\nimport type { Address, Peer, PeerStore } from './peer-store.js'\nimport type { Startable } from './startable.js'\nimport type { StreamHandler, StreamHandlerOptions, StreamMiddleware } from './stream-handler.js'\nimport type { Stream } from './stream.js'\nimport type { Topology } from './topology.js'\nimport type { Listener, OutboundConnectionUpgradeEvents } from './transport.js'\nimport type { DNS } from '@multiformats/dns'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { TypedEventTarget } from 'main-event'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\n/**\n * Used by the connection manager to sort addresses into order before dialling\n */\nexport interface AddressSorter {\n  (a: Address, b: Address): -1 | 0 | 1\n}\n\n/**\n * Event detail emitted when peer data changes\n */\nexport interface PeerUpdate {\n  peer: Peer\n  previous?: Peer\n}\n\n/**\n * Peer data signed by the remote Peer's public key\n */\nexport interface SignedPeerRecord {\n  addresses: Multiaddr[]\n  seq: bigint\n}\n\n/**\n * A certificate that can be used to secure connections\n */\nexport interface TLSCertificate {\n  /**\n   * The private key that corresponds to the certificate in PEM format\n   */\n  key: string\n\n  /**\n   * The certificate chain in PEM format\n   */\n  cert: string\n}\n\n/**\n * Data returned from a successful identify response\n */\nexport interface IdentifyResult {\n  /**\n   * The remote Peer's PeerId\n   */\n  peerId: PeerId\n\n  /**\n   * The unsigned addresses they are listening on. Note - any multiaddrs present\n   * in the signed peer record should be preferred to the value here.\n   */\n  listenAddrs: Multiaddr[]\n\n  /**\n   * The protocols the remote peer supports\n   */\n  protocols: string[]\n\n  /**\n   * The remote protocol version\n   */\n  protocolVersion?: string\n\n  /**\n   * The remote agent version\n   */\n  agentVersion?: string\n\n  /**\n   * The public key part of the remote PeerId - this is only useful for older\n   * RSA-based PeerIds, the more modern Ed25519 and secp256k1 types have the\n   * public key embedded in them\n   */\n  publicKey?: Uint8Array\n\n  /**\n   * If set this is the address that the remote peer saw the identify request\n   * originate from\n   */\n  observedAddr?: Multiaddr\n\n  /**\n   * If sent by the remote peer this is the deserialized signed peer record\n   */\n  signedPeerRecord?: SignedPeerRecord\n\n  /**\n   * The connection that the identify protocol ran over\n   */\n  connection: Connection\n}\n\n/**\n * Logger component for libp2p\n */\nexport interface Logger {\n  /**\n   * Log a message\n   */\n  (formatter: any, ...args: any[]): void\n\n  /**\n   * Log an error message\n   */\n  error(formatter: any, ...args: any[]): void\n\n  /**\n   * Log a trace message\n   */\n  trace(formatter: any, ...args: any[]): void\n\n  /**\n   * `true` if this logger is enabled\n   */\n  enabled: boolean\n\n  /**\n   * Create a logger scoped below this one\n   *\n   * @example\n   *\n   * ```ts\n   * import { defaultLogger } from '@libp2p/logger'\n   *\n   * const log = defaultLogger().forComponent('foo')\n   *\n   * log('hello')\n   * // foo hello\n   *\n   * const subLog = log.newScope('bar')\n   *\n   * subLog('hello')\n   * // foo:bar hello\n   * ```\n   */\n  newScope(name: string): Logger\n}\n\n/**\n * Peer logger component for libp2p. This can be used to create loggers that are\n * scoped to individual system components or services.\n *\n * To see logs, run your app with `DEBUG` set as an env var or for browsers, in\n * `localStorage`:\n *\n * ```console\n * $ DEBUG=libp2p* node index.js\n *  libp2p:my-service hello +0ms\n * ```\n */\nexport interface ComponentLogger {\n  /**\n   * Returns a logger for the specified component.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * import { ComponentLogger, Logger } from '@libp2p/interface'\n   *\n   * interface MyServiceComponents {\n   *   logger: ComponentLogger\n   * }\n   *\n   * class MyService {\n   *   private readonly log: Logger\n   *\n   *   constructor (components) {\n   *     this.log = components.logger.forComponent('libp2p:my-service')\n   *\n   *     this.log('hello')\n   *     // logs:\n   *     // libp2p:my-service hello +0ms\n   *   }\n   * }\n   * ```\n   */\n  forComponent(name: string): Logger\n}\n\nexport interface MultiaddrResolveOptions extends AbortOptions, LoggerOptions {\n  /**\n   * An optional DNS resolver\n   */\n  dns?: DNS\n}\n\n/**\n * `MultiaddrResolver`s perform resolution of multiaddr components that require\n * translation by external systems (for example DNSADDR to TXT records).\n */\nexport interface MultiaddrResolver {\n  /**\n   * Returns true if this resolver can resolve components of this multiaddr\n   */\n  canResolve (address: Multiaddr): boolean\n\n  /**\n   * Returns one or more multiaddrs with components resolved to other values\n   */\n  resolve (address: Multiaddr, options: MultiaddrResolveOptions): Promise<Multiaddr[]>\n}\n\n/**\n * Once you have a libp2p instance, you can listen to several events it emits,\n * so that you can be notified of relevant network events.\n *\n * Event names are `noun:verb` so the first part is the name of the object\n * being acted on and the second is the action.\n */\nexport interface Libp2pEvents<T extends ServiceMap = ServiceMap> {\n  /**\n   * This event is dispatched when a new network peer is discovered.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:discovery', (event) => {\n   *    const peerInfo = event.detail\n   *    // ...\n   * })\n   * ```\n   */\n  'peer:discovery': CustomEvent<PeerInfo>\n\n  /**\n   * This event will be triggered any time a new peer connects.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:connect', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:connect': CustomEvent<PeerId>\n\n  /**\n   * This event will be triggered any time we are disconnected from another\n   * peer, regardless of the circumstances of that disconnection. If we happen\n   * to have multiple connections to a peer, this event will **only** be\n   * triggered when the last connection is closed.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:disconnect', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:disconnect': CustomEvent<PeerId>\n\n  /**\n   * When a peer tagged with `keep-alive` disconnects, we will make multiple\n   * attempts to reconnect to it with a backoff factor (see the connection\n   * manager settings for details). If these all fail, the `keep-alive` tag will\n   * be removed and this event will be emitted.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:reconnect-failure', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:reconnect-failure': CustomEvent<PeerId>\n\n  /**\n   * This event is dispatched after a remote peer has successfully responded to\n   * the identify protocol. Note that for this to be emitted, both peers must\n   * have an identify service configured.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:identify', (event) => {\n   *   const identifyResult = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:identify': CustomEvent<IdentifyResult>\n\n  /**\n   * This event is dispatched when the peer store data for a peer has been\n   * updated - e.g. their multiaddrs, protocols etc have changed.\n   *\n   * If they were previously known to this node, the old peer data will be\n   * set in the `previous` field.\n   *\n   * This may be in response to the identify protocol running, a manual\n   * update or some other event.\n   */\n  'peer:update': CustomEvent<PeerUpdate>\n\n  /**\n   * This event is dispatched when the current node's peer record changes -\n   * for example a transport started listening on a new address or a new\n   * protocol handler was registered.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('self:peer:update', (event) => {\n   *   const { peer } = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'self:peer:update': CustomEvent<PeerUpdate>\n\n  /**\n   * This event is dispatched when a transport begins listening on a new address\n   */\n  'transport:listening': CustomEvent<Listener>\n\n  /**\n   * This event is dispatched when a transport stops listening on an address\n   */\n  'transport:close': CustomEvent<Listener>\n\n  /**\n   * This event is dispatched when the connection manager has more than the\n   * configured allowable max connections and has closed some connections to\n   * bring the node back under the limit.\n   */\n  'connection:prune': CustomEvent<Connection[]>\n\n  /**\n   * This event notifies listeners when new incoming or outgoing connections\n   * are opened.\n   */\n  'connection:open': CustomEvent<Connection>\n\n  /**\n   * This event notifies listeners when incoming or outgoing connections are\n   * closed.\n   */\n  'connection:close': CustomEvent<Connection>\n\n  /**\n   * This event notifies listeners that a TLS certificate is available for use\n   */\n  'certificate:provision': CustomEvent<TLSCertificate>\n\n  /**\n   * This event notifies listeners that a new TLS certificate is available for\n   * use. Any previous certificate may no longer be valid.\n   */\n  'certificate:renew': CustomEvent<TLSCertificate>\n\n  /**\n   * This event notifies listeners that the node has started\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('start', (event) => {\n   *   console.info(libp2p.isStarted()) // true\n   * })\n   * ```\n   */\n  start: CustomEvent<Libp2p<T>>\n\n  /**\n   * This event notifies listeners that the node has stopped\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('stop', (event) => {\n   *   console.info(libp2p.isStarted()) // false\n   * })\n   * ```\n   */\n  stop: CustomEvent<Libp2p<T>>\n}\n\n/**\n * A map of user defined services available on the libp2p node via the\n * `services` key\n *\n * @example\n *\n * ```TypeScript\n * const node = await createLibp2p({\n *   // ...other options\n *   services: {\n *     myService: myService({\n *       // ...service options\n *     })\n *   }\n * })\n *\n * // invoke methods on the service\n * node.services.myService.anOperation()\n * ```\n */\nexport type ServiceMap = Record<string, unknown>\n\nexport type PendingDialStatus = 'queued' | 'active' | 'error' | 'success'\n\n/**\n * An item in the dial queue\n */\nexport interface PendingDial {\n  /**\n   * A unique identifier for this dial\n   */\n  id: string\n\n  /**\n   * The current status of the dial\n   */\n  status: PendingDialStatus\n\n  /**\n   * If known, this is the peer id that libp2p expects to be dialling\n   */\n  peerId?: PeerId\n\n  /**\n   * The list of multiaddrs that will be dialled. The returned connection will\n   * use the first address that succeeds, all other dials part of this pending\n   * dial will be cancelled.\n   */\n  multiaddrs: Multiaddr[]\n}\n\nexport type Libp2pStatus = 'starting' | 'started' | 'stopping' | 'stopped'\n\nexport interface IsDialableOptions extends AbortOptions {\n  /**\n   * If the dial attempt would open a protocol, and the multiaddr being dialed\n   * is a circuit relay address, passing true here would cause the test to fail\n   * because that protocol would not be allowed to run over a data/time limited\n   * connection.\n   */\n  runOnLimitedConnection?: boolean\n}\n\nexport type TransportManagerDialProgressEvents =\n  ProgressEvent<'transport-manager:selected-transport', string>\n\nexport type OpenConnectionProgressEvents =\n  TransportManagerDialProgressEvents |\n  ProgressEvent<'dial-queue:already-connected'> |\n  ProgressEvent<'dial-queue:already-in-dial-queue'> |\n  ProgressEvent<'dial-queue:add-to-dial-queue'> |\n  ProgressEvent<'dial-queue:start-dial'> |\n  ProgressEvent<'dial-queue:calculated-addresses', Address[]> |\n  OutboundConnectionUpgradeEvents\n\nexport interface DialOptions extends AbortOptions, ProgressOptions {\n  /**\n   * If true, open a new connection to the remote even if one already exists\n   */\n  force?: boolean\n}\n\nexport interface DialProtocolOptions extends NewStreamOptions {\n\n}\n\n/**\n * Libp2p nodes implement this interface.\n */\nexport interface Libp2p<T extends ServiceMap = ServiceMap> extends Startable, TypedEventTarget<Libp2pEvents<T>> {\n  /**\n   * The PeerId is a unique identifier for a node on the network.\n   *\n   * It is the hash of an RSA public key or, for Ed25519 or secp256k1 keys,\n   * the key itself.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * console.info(libp2p.peerId)\n   * // PeerId(12D3Foo...)\n   * ````\n   */\n  peerId: PeerId\n\n  /**\n   * The peer store holds information we know about other peers on the network.\n   * - multiaddrs, supported protocols, etc.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peer = await libp2p.peerStore.get(peerId)\n   * console.info(peer)\n   * // { id: PeerId(12D3Foo...), addresses: [] ... }\n   * ```\n   */\n  peerStore: PeerStore\n\n  /**\n   * The peer routing subsystem allows the user to find peers on the network\n   * or to find peers close to binary keys.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peerInfo = await libp2p.peerRouting.findPeer(peerId)\n   * console.info(peerInfo)\n   * // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * ```\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for await (const peerInfo of libp2p.peerRouting.getClosestPeers(key)) {\n   *   console.info(peerInfo)\n   *   // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * }\n   * ```\n   */\n  peerRouting: PeerRouting\n\n  /**\n   * The content routing subsystem allows the user to find providers for content,\n   * let the network know they are providers for content, and get/put values to\n   * the DHT.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for await (const peerInfo of libp2p.contentRouting.findProviders(cid)) {\n   *   console.info(peerInfo)\n   *   // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * }\n   * ```\n   */\n  contentRouting: ContentRouting\n\n  /**\n   * The metrics subsystem allows recording values to assess the health/performance\n   * of the running node.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const metric = libp2p.metrics.registerMetric({\n   *   'my-metric'\n   * })\n   *\n   * // later\n   * metric.update(5)\n   * ```\n   */\n  metrics?: Metrics\n\n  /**\n   * The logger used by this libp2p node\n   */\n  logger: ComponentLogger\n\n  /**\n   * The current status of the libp2p node\n   */\n  status: Libp2pStatus\n\n  /**\n   * Get a deduplicated list of peer advertising multiaddrs by concatenating\n   * the listen addresses used by transports with any configured\n   * announce addresses as well as observed addresses reported by peers.\n   *\n   * If Announce addrs are specified, configured listen addresses will be\n   * ignored though observed addresses will still be included.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const listenMa = libp2p.getMultiaddrs()\n   * // [ <Multiaddr 047f00000106f9ba - /ip4/127.0.0.1/tcp/63930> ]\n   * ```\n   */\n  getMultiaddrs(): Multiaddr[]\n\n  /**\n   * Returns a list of supported protocols\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const protocols = libp2p.getProtocols()\n   * // [ '/ipfs/ping/1.0.0', '/ipfs/id/1.0.0' ]\n   * ```\n   */\n  getProtocols(): string[]\n\n  /**\n   * Return a list of all connections this node has open, optionally filtering\n   * by a PeerId\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for (const connection of libp2p.getConnections()) {\n   *   console.log(peerId, connection.remoteAddr.toString())\n   *   // Logs the PeerId string and the observed remote multiaddr of each Connection\n   * }\n   * ```\n   */\n  getConnections(peerId?: PeerId): Connection[]\n\n  /**\n   * Return the list of dials currently in progress or queued to start\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for (const pendingDial of libp2p.getDialQueue()) {\n   *   console.log(pendingDial)\n   * }\n   * ```\n   */\n  getDialQueue(): PendingDial[]\n\n  /**\n   * Return a list of all peers we currently have a connection open to\n   */\n  getPeers(): PeerId[]\n\n  /**\n   * Dials to the provided peer. If successful, the known metadata of the\n   * peer will be added to the nodes `peerStore`.\n   *\n   * If a PeerId is passed as the first argument, the peer will need to have known multiaddrs for it in the PeerStore.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const conn = await libp2p.dial(remotePeerId)\n   *\n   * // create a new stream within the connection\n   * const stream = await conn.newStream(['/echo/1.1.0', '/echo/1.0.0'])\n   *\n   * // protocol negotiated: 'echo/1.0.0' means that the other party only supports the older version\n   *\n   * // ...\n   * await conn.close()\n   * ```\n   */\n  dial(peer: PeerId | Multiaddr | Multiaddr[], options?: DialOptions): Promise<Connection>\n\n  /**\n   * Dials to the provided peer and tries to handshake with the given protocols in order.\n   * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n   * and the `MuxedStream` will be returned together with the successful negotiated protocol.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * import { pipe } from 'it-pipe'\n   *\n   * const { stream, protocol } = await libp2p.dialProtocol(remotePeerId, protocols)\n   *\n   * // Use this new stream like any other duplex stream\n   * pipe([1, 2, 3], stream, consume)\n   * ```\n   */\n  dialProtocol(peer: PeerId | Multiaddr | Multiaddr[], protocols: string | string[], options?: DialProtocolOptions): Promise<Stream>\n\n  /**\n   * Attempts to gracefully close an open connection to the given peer. If the\n   * connection is not closed in the grace period, it will be forcefully closed.\n   *\n   * An AbortSignal can optionally be passed to control when the connection is\n   * forcefully closed.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * await libp2p.hangUp(remotePeerId)\n   * ```\n   */\n  hangUp(peer: PeerId | Multiaddr, options?: AbortOptions): Promise<void>\n\n  /**\n   * Sets up [multistream-select routing](https://github.com/multiformats/multistream-select) of protocols to their application handlers. Whenever a stream is opened on one of the provided protocols, the handler will be called. `handle` must be called in order to register a handler and support for a given protocol. This also informs other peers of the protocols you support.\n   *\n   * `libp2p.handle(protocols, handler, options)`\n   *\n   * In the event of a new handler for the same protocol being added and error\n   * will be thrown. Pass `force: true` to override this.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const handler = ({ connection, stream, protocol }) => {\n   *   // use stream or connection according to the needs\n   * }\n   *\n   * libp2p.handle('/echo/1.0.0', handler, {\n   *   maxInboundStreams: 5,\n   *   maxOutboundStreams: 5\n   * })\n   * ```\n   */\n  handle(protocol: string | string[], handler: StreamHandler, options?: StreamHandlerOptions): Promise<void>\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.unhandle(['/echo/1.0.0'])\n   * ```\n   */\n  unhandle(protocols: string[] | string, options?: AbortOptions): Promise<void>\n\n  /**\n   * Register a topology to be informed when peers are encountered that\n   * support the specified protocol\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const id = await libp2p.register('/echo/1.0.0', {\n   *   onConnect: (peer, connection) => {\n   *     // handle connect\n   *   },\n   *   onDisconnect: (peer, connection) => {\n   *     // handle disconnect\n   *   }\n   * })\n   * ```\n   */\n  register(protocol: string, topology: Topology, options?: AbortOptions): Promise<string>\n\n  /**\n   * Unregister topology to no longer be informed when peers connect or\n   * disconnect.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const id = await libp2p.register(...)\n   *\n   * libp2p.unregister(id)\n   * ```\n   */\n  unregister(id: string): void\n\n  /**\n   * Registers one or more middleware implementations that will be invoked for\n   * incoming and outgoing protocol streams that match the passed protocol.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.use('/my/protocol/1.0.0', (stream, connection, next) => {\n   *   // do something with stream and/or connection\n   *   next(stream, connection)\n   * })\n   * ```\n   */\n  use (protocol: string, middleware: StreamMiddleware | StreamMiddleware[]): void\n\n  /**\n   * Deregisters all middleware for the passed protocol.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.unuse('/my/protocol/1.0.0')\n   * // any previously registered middleware will no longer be invoked\n   * ```\n   */\n  unuse (protocol: string): void\n\n  /**\n   * Returns the public key for the passed PeerId. If the PeerId is of the 'RSA'\n   * type this may mean searching the routing if the peer's key is not present\n   * in the peer store.\n   */\n  getPublicKey(peer: Ed25519PeerId, options?: AbortOptions): Promise<Ed25519PublicKey>\n  getPublicKey(peer: Secp256k1PeerId, options?: AbortOptions): Promise<Secp256k1PublicKey>\n  getPublicKey(peer: RSAPeerId, options?: AbortOptions): Promise<RSAPublicKey>\n  getPublicKey(peer: URLPeerId, options?: AbortOptions): Promise<never>\n  getPublicKey(peer: PeerId, options?: AbortOptions): Promise<PublicKey>\n\n  /**\n   * Given the current node configuration, returns a promise of `true` or\n   * `false` if the node would attempt to dial the passed multiaddr.\n   *\n   * This means a relevant transport is configured, and the connection gater\n   * would not block the dial attempt.\n   *\n   * This may involve resolving DNS addresses so you should pass an AbortSignal.\n   */\n  isDialable(multiaddr: Multiaddr | Multiaddr[], options?: IsDialableOptions): Promise<boolean>\n\n  /**\n   * A set of user defined services\n   */\n  services: T\n}\n\n/**\n * Metadata about the current node\n */\nexport interface NodeInfo {\n  /**\n   * The implementation name\n   */\n  name: string\n\n  /**\n   * The implementation version\n   */\n  version: string\n\n  /**\n   * A string that contains information about the implementation and runtime\n   */\n  userAgent: string\n}\n\n/**\n * An object that contains an AbortSignal as\n * the optional `signal` property.\n *\n * @example\n *\n * ```TypeScript\n * const controller = new AbortController()\n *\n * aLongRunningOperation({\n *   signal: controller.signal\n * })\n *\n * // later\n *\n * controller.abort()\n */\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\n/**\n * An object that contains a Logger as the `log` property.\n */\nexport interface LoggerOptions {\n  log: Logger\n}\n\n/**\n * An object that includes a trace object that is passed onwards.\n *\n * This is used by metrics method tracing to link function calls together.\n */\nexport interface TraceOptions {\n  trace?: any\n}\n\n/**\n * A signal that needs to be cleared when no longer in use\n */\nexport interface ClearableSignal extends AbortSignal {\n  clear(): void\n}\n\n/**\n * When a routing operation involves reading values, these options allow\n * controlling where the values are read from. By default libp2p will check\n * local caches but may not use the network if a valid local value is found,\n * these options allow tuning that behavior.\n */\nexport interface RoutingOptions extends AbortOptions, ProgressOptions, TraceOptions {\n  /**\n   * Pass `false` to not use the network\n   *\n   * @default true\n   */\n  useNetwork?: boolean\n\n  /**\n   * Pass `false` to not use cached values\n   *\n   * @default true\n   */\n  useCache?: boolean\n}\n\n/**\n * This symbol is used by libp2p services to define the capabilities they can\n * provide to other libp2p services.\n *\n * The service should define a property with this symbol as the key and the\n * value should be a string array of provided capabilities.\n */\nexport const serviceCapabilities = Symbol.for('@libp2p/service-capabilities')\n\n/**\n * This symbol is used by libp2p services to define the capabilities they\n * require from other libp2p services.\n *\n * The service should define a property with this symbol as the key and the\n * value should be a string array of required capabilities.\n */\nexport const serviceDependencies = Symbol.for('@libp2p/service-dependencies')\n\nexport * from './connection.js'\nexport * from './connection-encrypter.js'\nexport * from './connection-gater.js'\nexport * from './connection-protector.js'\nexport * from './content-routing.js'\nexport * from './errors.js'\nexport * from './events.js'\nexport * from './keys.js'\nexport * from './message-stream.js'\nexport * from './metrics.js'\nexport * from './multiaddr-connection.js'\nexport * from './peer-discovery.js'\nexport * from './peer-id.js'\nexport * from './peer-info.js'\nexport * from './peer-routing.js'\nexport * from './peer-store.js'\nexport * from './record.js'\nexport * from './startable.js'\nexport * from './stream-handler.js'\nexport * from './stream-muxer.js'\nexport * from './stream.js'\nexport * from './topology.js'\nexport * from './transport.js'\n\nexport * from 'main-event'\n", "/**\n * Returns true if the two passed Uint8Arrays have the same content\n */\nexport function equals (a: Uint8Array, b: Uint8Array): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (a.byteLength !== b.byteLength) {\n    return false\n  }\n\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] !== b[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n", "/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n", "/* eslint-disable no-fallthrough */\nimport { allocUnsafe } from 'uint8arrays/alloc'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst N1 = Math.pow(2, 7)\nconst N2 = Math.pow(2, 14)\nconst N3 = Math.pow(2, 21)\nconst N4 = Math.pow(2, 28)\nconst N5 = Math.pow(2, 35)\nconst N6 = Math.pow(2, 42)\nconst N7 = Math.pow(2, 49)\n\n/** Most significant bit of a byte */\nconst MSB = 0x80\n/** Rest of the bits in a byte */\nconst REST = 0x7f\n\nexport function encodingLength (value: number): number {\n  if (value < N1) {\n    return 1\n  }\n\n  if (value < N2) {\n    return 2\n  }\n\n  if (value < N3) {\n    return 3\n  }\n\n  if (value < N4) {\n    return 4\n  }\n\n  if (value < N5) {\n    return 5\n  }\n\n  if (value < N6) {\n    return 6\n  }\n\n  if (value < N7) {\n    return 7\n  }\n\n  if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('Could not encode varint')\n  }\n\n  return 8\n}\n\nexport function encodeUint8Array (value: number, buf: Uint8Array, offset: number = 0): Uint8Array {\n  switch (encodingLength(value)) {\n    case 8: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 7: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 6: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 5: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 4: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 3: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 2: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 1: {\n      buf[offset++] = (value & 0xFF)\n      value >>>= 7\n      break\n    }\n    default: throw new Error('unreachable')\n  }\n  return buf\n}\n\nexport function encodeUint8ArrayList (value: number, buf: Uint8ArrayList, offset: number = 0): Uint8ArrayList {\n  switch (encodingLength(value)) {\n    case 8: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 7: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 6: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 5: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 4: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 3: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 2: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 1: {\n      buf.set(offset++, (value & 0xFF))\n      value >>>= 7\n      break\n    }\n    default: throw new Error('unreachable')\n  }\n  return buf\n}\n\nexport function decodeUint8Array (buf: Uint8Array, offset: number): number {\n  let b = buf[offset]\n  let res = 0\n\n  res += b & REST\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 1]\n  res += (b & REST) << 7\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 2]\n  res += (b & REST) << 14\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 3]\n  res += (b & REST) << 21\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 4]\n  res += (b & REST) * N4\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 5]\n  res += (b & REST) * N5\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 6]\n  res += (b & REST) * N6\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 7]\n  res += (b & REST) * N7\n  if (b < MSB) {\n    return res\n  }\n\n  throw new RangeError('Could not decode varint')\n}\n\nexport function decodeUint8ArrayList (buf: Uint8ArrayList, offset: number): number {\n  let b = buf.get(offset)\n  let res = 0\n\n  res += b & REST\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 1)\n  res += (b & REST) << 7\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 2)\n  res += (b & REST) << 14\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 3)\n  res += (b & REST) << 21\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 4)\n  res += (b & REST) * N4\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 5)\n  res += (b & REST) * N5\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 6)\n  res += (b & REST) * N6\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 7)\n  res += (b & REST) * N7\n  if (b < MSB) {\n    return res\n  }\n\n  throw new RangeError('Could not decode varint')\n}\n\nexport function encode (value: number): Uint8Array\nexport function encode (value: number, buf: Uint8Array, offset?: number): Uint8Array\nexport function encode (value: number, buf: Uint8ArrayList, offset?: number): Uint8ArrayList\nexport function encode <T extends Uint8Array | Uint8ArrayList = Uint8Array> (value: number, buf?: T, offset: number = 0): T {\n  if (buf == null) {\n    buf = allocUnsafe(encodingLength(value)) as T\n  }\n  if (buf instanceof Uint8Array) {\n    return encodeUint8Array(value, buf, offset) as T\n  } else {\n    return encodeUint8ArrayList(value, buf, offset) as T\n  }\n}\n\nexport function decode (buf: Uint8ArrayList | Uint8Array, offset: number = 0): number {\n  if (buf instanceof Uint8Array) {\n    return decodeUint8Array(buf, offset)\n  } else {\n    return decodeUint8ArrayList(buf, offset)\n  }\n}\n", "import { allocUnsafe } from '#alloc'\nimport { asUint8Array } from '#util/as-uint8array'\n\n/**\n * Returns a new Uint8Array created by concatenating the passed Uint8Arrays\n */\nexport function concat (arrays: Uint8Array[], length?: number): Uint8Array {\n  if (length == null) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0)\n  }\n\n  const output = allocUnsafe(length)\n  let offset = 0\n\n  for (const arr of arrays) {\n    output.set(arr, offset)\n    offset += arr.length\n  }\n\n  return asUint8Array(output)\n}\n", "import { baseX } from './base.js'\n\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n})\n", "export const empty = new Uint8Array(0)\n\nexport function toHex (d: Uint8Array): string {\n  return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n}\n\nexport function fromHex (hex: string): Uint8Array {\n  const hexes = hex.match(/../g)\n  return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\nexport function equals (aa: Uint8Array, bb: Uint8Array): boolean {\n  if (aa === bb) { return true }\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function coerce (o: ArrayBufferView | ArrayBuffer | Uint8Array): Uint8Array {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') { return o }\n  if (o instanceof ArrayBuffer) { return new Uint8Array(o) }\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\nexport function isBinary (o: unknown): o is ArrayBuffer | ArrayBufferView {\n  return o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n}\n\nexport function fromString (str: string): Uint8Array {\n  return new TextEncoder().encode(str)\n}\n\nexport function toString (b: Uint8Array): string {\n  return new TextDecoder().decode(b)\n}\n", "/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  /**\n   * @param {any[] | Iterable<number>} source\n   */\n  function encode (source) {\n    // @ts-ignore\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  /**\n   * @param {string | string[]} source\n   */\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  /**\n   * @param {string | string[]} string\n   */\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n", "import { coerce } from '../bytes.js'\nimport basex from '../vendor/base-x.js'\nimport type { BaseCodec, BaseDecoder, BaseEncoder, CombobaseDecoder, Multibase, MultibaseCodec, MultibaseDecoder, MultibaseEncoder, UnibaseDecoder } from './interface.js'\n\ninterface EncodeFn { (bytes: Uint8Array): string }\ninterface DecodeFn { (text: string): Uint8Array }\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder<Base extends string, Prefix extends string> implements MultibaseEncoder<Prefix>, BaseEncoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  encode (bytes: Uint8Array): Multibase<Prefix> {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder<Base extends string, Prefix extends string> implements MultibaseDecoder<Prefix>, UnibaseDecoder<Prefix>, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseDecode: DecodeFn\n  private readonly prefixCodePoint: number\n\n  constructor (name: Base, prefix: Prefix, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    const prefixCodePoint = prefix.codePointAt(0)\n    /* c8 ignore next 3 */\n    if (prefixCodePoint === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    this.prefixCodePoint = prefixCodePoint\n    this.baseDecode = baseDecode\n  }\n\n  decode (text: string): Uint8Array {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  or<OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n}\n\ntype Decoders<Prefix extends string> = Record<Prefix, UnibaseDecoder<Prefix>>\n\nclass ComposedDecoder<Prefix extends string> implements MultibaseDecoder<Prefix>, CombobaseDecoder<Prefix> {\n  readonly decoders: Decoders<Prefix>\n\n  constructor (decoders: Decoders<Prefix>) {\n    this.decoders = decoders\n  }\n\n  or <OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n\n  decode (input: string): Uint8Array {\n    const prefix = input[0] as Prefix\n    const decoder = this.decoders[prefix]\n    if (decoder != null) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\nexport function or <L extends string, R extends string> (left: UnibaseDecoder<L> | CombobaseDecoder<L>, right: UnibaseDecoder<R> | CombobaseDecoder<R>): ComposedDecoder<L | R> {\n  return new ComposedDecoder({\n    ...(left.decoders ?? { [(left as UnibaseDecoder<L>).prefix]: left }),\n    ...(right.decoders ?? { [(right as UnibaseDecoder<R>).prefix]: right })\n  } as Decoders<L | R>)\n}\n\nexport class Codec<Base extends string, Prefix extends string> implements MultibaseCodec<Prefix>, MultibaseEncoder<Prefix>, MultibaseDecoder<Prefix>, BaseCodec, BaseEncoder, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n  readonly baseDecode: DecodeFn\n  readonly encoder: Encoder<Base, Prefix>\n  readonly decoder: Decoder<Base, Prefix>\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  encode (input: Uint8Array): string {\n    return this.encoder.encode(input)\n  }\n\n  decode (input: string): Uint8Array {\n    return this.decoder.decode(input)\n  }\n}\n\nexport function from <Base extends string, Prefix extends string> ({ name, prefix, encode, decode }: { name: Base, prefix: Prefix, encode: EncodeFn, decode: DecodeFn }): Codec<Base, Prefix> {\n  return new Codec(name, prefix, encode, decode)\n}\n\nexport function baseX <Base extends string, Prefix extends string> ({ name, prefix, alphabet }: { name: Base, prefix: Prefix, alphabet: string }): Codec<Base, Prefix> {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: (text: string): Uint8Array => coerce(decode(text))\n  })\n}\n\nfunction decode (string: string, alphabetIdx: Record<string, number>, bitsPerChar: number, name: string): Uint8Array {\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = alphabetIdx[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\nfunction encode (data: Uint8Array, alphabet: string, bitsPerChar: number): string {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits !== 0) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while (((out.length * bitsPerChar) & 7) !== 0) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\nfunction createAlphabetIdx (alphabet: string): Record<string, number> {\n  // Build the character lookup table:\n  const alphabetIdx: Record<string, number> = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    alphabetIdx[alphabet[i]] = i\n  }\n  return alphabetIdx\n}\n\n/**\n * RFC4648 Factory\n */\nexport function rfc4648 <Base extends string, Prefix extends string> ({ name, prefix, bitsPerChar, alphabet }: { name: Base, prefix: Prefix, bitsPerChar: number, alphabet: string }): Codec<Base, Prefix> {\n  const alphabetIdx = createAlphabetIdx(alphabet)\n  return from({\n    prefix,\n    name,\n    encode (input: Uint8Array): string {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input: string): Uint8Array {\n      return decode(input, alphabetIdx, bitsPerChar, name)\n    }\n  })\n}\n", "import { rfc4648 } from './base.js'\n\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n})\n\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n})\n", "import { from } from './base.js'\n\nconst alphabet = Array.from('\uD83D\uDE80\uD83E\uDE90\u2604\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\u2600\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\u2764\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\u263A\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\u270C\u2728\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\u2763\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\u270B\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\u2B50\u2705\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\u2714\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\u2639\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\u261D\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\u26BD\uD83E\uDD19\u2615\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\u26A1\uD83C\uDF1E\uD83C\uDF88\u274C\u270A\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\u2708\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\u25B6\u27A1\u2753\uD83D\uDC8E\uD83D\uDCB8\u2B07\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\u26A0\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\u260E\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\u2744\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42')\nconst alphabetBytesToChars: string[] = (alphabet.reduce<string[]>((p, c, i) => { p[i] = c; return p }, ([])))\nconst alphabetCharsToBytes: number[] = (alphabet.reduce<number[]>((p, c, i) => {\n  const codePoint = c.codePointAt(0)\n  if (codePoint == null) {\n    throw new Error(`Invalid character: ${c}`)\n  }\n  p[codePoint] = i\n  return p\n}, ([])))\n\nfunction encode (data: Uint8Array): string {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c]\n    return p\n  }, '')\n}\n\nfunction decode (str: string): Uint8Array {\n  const byts = []\n  for (const char of str) {\n    const codePoint = char.codePointAt(0)\n    if (codePoint == null) {\n      throw new Error(`Invalid character: ${char}`)\n    }\n    const byt = alphabetCharsToBytes[codePoint]\n    if (byt == null) {\n      throw new Error(`Non-base256emoji character: ${char}`)\n    }\n    byts.push(byt)\n  }\n  return new Uint8Array(byts)\n}\n\nexport const base256emoji = from({\n  prefix: '\uD83D\uDE80',\n  name: 'base256emoji',\n  encode,\n  decode\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n", "import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n", "import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n})\n", "import { fromString, toString } from '../bytes.js'\nimport { from } from './base.js'\n\nexport const identity = from({\n  prefix: '\\x00',\n  name: 'identity',\n  encode: (buf) => toString(buf),\n  decode: (str) => fromString(str)\n})\n", "import type { ArrayBufferView, ByteView } from './interface.js'\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const name = 'json'\nexport const code = 0x0200\n\nexport function encode <T> (node: T): ByteView<T> {\n  return textEncoder.encode(JSON.stringify(node))\n}\n\nexport function decode <T> (data: ByteView<T> | ArrayBufferView<T>): T {\n  return JSON.parse(textDecoder.decode(data))\n}\n", "import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\nimport type { DigestOptions } from './hasher.js'\n\nconst code: 0x0 = 0x0\nconst name = 'identity'\n\nconst encode: (input: Uint8Array) => Uint8Array = coerce\n\nfunction digest (input: Uint8Array, options?: DigestOptions): Digest.Digest<typeof code, number> {\n  if (options?.truncate != null && options.truncate !== input.byteLength) {\n    if (options.truncate < 0 || options.truncate > input.byteLength) {\n      throw new Error(`Invalid truncate option, must be less than or equal to ${input.byteLength}`)\n    }\n\n    input = input.subarray(0, options.truncate)\n  }\n\n  return Digest.create(code, encode(input))\n}\n\nexport const identity = { code, name, encode, digest }\n", "/* eslint-disable */\nvar encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  // @ts-ignore\n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      // @ts-ignore\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  // @ts-ignore\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (/** @type {number} */ value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n", "import varint from './vendor/varint.js'\n\nexport function decode (data: Uint8Array, offset = 0): [number, number] {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\nexport function encodeTo (int: number, target: Uint8Array, offset = 0): Uint8Array {\n  varint.encode(int, target, offset)\n  return target\n}\n\nexport function encodingLength (int: number): number {\n  return varint.encodingLength(int)\n}\n", "import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\nimport type { MultihashDigest } from './interface.js'\n\n/**\n * Creates a multihash digest.\n */\nexport function create <Code extends number> (code: Code, digest: Uint8Array): Digest<Code, number> {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nexport function decode (multihash: Uint8Array): MultihashDigest {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\nexport function equals (a: MultihashDigest, b: unknown): b is MultihashDigest {\n  if (a === b) {\n    return true\n  } else {\n    const data = b as { code?: unknown, size?: unknown, bytes?: unknown }\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nexport class Digest<Code extends number, Size extends number> implements MultihashDigest {\n  readonly code: Code\n  readonly size: Size\n  readonly digest: Uint8Array\n  readonly bytes: Uint8Array\n\n  /**\n   * Creates a multihash digest.\n   */\n  constructor (code: Code, size: Size, digest: Uint8Array, bytes: Uint8Array) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n\n/**\n * Used to check that the passed multihash has the passed code\n */\nexport function hasCode <T extends number> (digest: MultihashDigest, code: T): digest is MultihashDigest<T> {\n  return digest.code === code\n}\n", "/* global crypto */\n\nimport { from } from './hasher.js'\n\nfunction sha (name: AlgorithmIdentifier): (data: Uint8Array) => Promise<Uint8Array> {\n  return async data => new Uint8Array(await crypto.subtle.digest(name, data))\n}\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n", "import * as Digest from './digest.js'\nimport type { MultihashHasher } from './interface.js'\n\ntype Await<T> = Promise<T> | T\n\nconst DEFAULT_MIN_DIGEST_LENGTH = 20\n\nexport interface HasherInit <Name extends string, Code extends number> {\n  name: Name\n  code: Code\n  encode(input: Uint8Array): Await<Uint8Array>\n\n  /**\n   * The minimum length a hash is allowed to be truncated to in bytes\n   *\n   * @default 20\n   */\n  minDigestLength?: number\n\n  /**\n   * The maximum length a hash is allowed to be truncated to in bytes. If not\n   * specified it will be inferred from the length of the digest.\n   */\n  maxDigestLength?: number\n}\n\nexport function from <Name extends string, Code extends number> ({ name, code, encode, minDigestLength, maxDigestLength }: HasherInit<Name, Code>): Hasher<Name, Code> {\n  return new Hasher(name, code, encode, minDigestLength, maxDigestLength)\n}\n\nexport interface DigestOptions {\n  /**\n   * Truncate the returned digest to this number of bytes.\n   *\n   * This may cause the digest method to throw/reject if the passed value is\n   * greater than the digest length or below a threshold under which the risk of\n   * hash collisions is significant.\n   *\n   * The actual value of this threshold can depend on the hashing algorithm in\n   * use.\n   */\n  truncate?: number\n}\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nexport class Hasher<Name extends string, Code extends number> implements MultihashHasher<Code> {\n  readonly name: Name\n  readonly code: Code\n  readonly encode: (input: Uint8Array) => Await<Uint8Array>\n  readonly minDigestLength: number\n  readonly maxDigestLength?: number\n\n  constructor (name: Name, code: Code, encode: (input: Uint8Array) => Await<Uint8Array>, minDigestLength?: number, maxDigestLength?: number) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n    this.minDigestLength = minDigestLength ?? DEFAULT_MIN_DIGEST_LENGTH\n    this.maxDigestLength = maxDigestLength\n  }\n\n  digest (input: Uint8Array, options?: DigestOptions): Await<Digest.Digest<Code, number>> {\n    if (options?.truncate != null) {\n      if (options.truncate < this.minDigestLength) {\n        throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`)\n      }\n\n      if (this.maxDigestLength != null && options.truncate > this.maxDigestLength) {\n        throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`)\n      }\n    }\n\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n\n      if (result instanceof Uint8Array) {\n        return createDigest(result, this.code, options?.truncate)\n      }\n\n      return result.then(digest => createDigest(digest, this.code, options?.truncate))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n\n/**\n * Create a Digest from the passed uint8array and code, optionally truncating it\n * first.\n */\nfunction createDigest <Code extends number> (digest: Uint8Array, code: Code, truncate?: number): Digest.Digest<Code, number> {\n  if (truncate != null && truncate !== digest.byteLength) {\n    if (truncate > digest.byteLength) {\n      throw new Error(`Invalid truncate option, must be less than or equal to ${digest.byteLength}`)\n    }\n\n    digest = digest.subarray(0, truncate)\n  }\n\n  return Digest.create(code, digest)\n}\n", "import { base32 } from './bases/base32.js'\nimport { base36 } from './bases/base36.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\nimport * as varint from './varint.js'\nimport type * as API from './link/interface.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nexport function format <T extends API.Link<unknown, number, number, API.Version>, Prefix extends string> (link: T, base?: API.MultibaseEncoder<Prefix>): API.ToString<T, Prefix> {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        base as API.MultibaseEncoder<'z'> ?? base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        (base ?? base32.encoder) as API.MultibaseEncoder<Prefix>\n      )\n  }\n}\n\nexport function toJSON <Link extends API.UnknownLink> (link: Link): API.LinkJSON<Link> {\n  return {\n    '/': format(link)\n  }\n}\n\nexport function fromJSON <Link extends API.UnknownLink> (json: API.LinkJSON<Link>): CID<unknown, number, number, API.Version> {\n  return CID.parse(json['/'])\n}\n\nconst cache = new WeakMap<API.UnknownLink, Map<string, string>>()\n\nfunction baseCache (cid: API.UnknownLink): Map<string, string> {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\nexport class CID<Data = unknown, Format extends number = number, Alg extends number = number, Version extends API.Version = API.Version> implements API.Link<Data, Format, Alg, Version> {\n  readonly code: Format\n  readonly version: Version\n  readonly multihash: API.MultihashDigest<Alg>\n  readonly bytes: Uint8Array\n  readonly '/': Uint8Array\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param multihash - (Multi)hash of the of the content.\n   */\n  constructor (version: Version, code: Format, multihash: API.MultihashDigest<Alg>, bytes: Uint8Array) {\n    this.code = code\n    this.version = version\n    this.multihash = multihash\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID (): this {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset (): number {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength (): number {\n    return this.bytes.byteLength\n  }\n\n  toV0 (): CID<Data, API.DAG_PB, API.SHA_256, 0> {\n    switch (this.version) {\n      case 0: {\n        return this as CID<Data, API.DAG_PB, API.SHA_256, 0>\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return (\n          CID.createV0(\n            multihash as API.MultihashDigest<API.SHA_256>\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  toV1 (): CID<Data, Format, Alg, 1> {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return this as CID<Data, Format, Alg, 1>\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  equals (other: unknown): other is CID<Data, Format, Alg, Version> {\n    return CID.equals(this, other)\n  }\n\n  static equals <Data, Format extends number, Alg extends number, Version extends API.Version>(self: API.Link<Data, Format, Alg, Version>, other: unknown): other is CID {\n    const unknown = other as { code?: unknown, version?: unknown, multihash?: unknown }\n    return (\n      unknown != null &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  toString (base?: API.MultibaseEncoder<string>): string {\n    return format(this, base)\n  }\n\n  toJSON (): API.LinkJSON<this> {\n    return { '/': format(this) }\n  }\n\n  link (): this {\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'CID';\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] (): string {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   */\n  static asCID <Data, Format extends number, Alg extends number, Version extends API.Version, U>(input: API.Link<Data, Format, Alg, Version> | U): CID<Data, Format, Alg, Version> | null {\n    if (input == null) {\n      return null\n    }\n\n    const value = input as any\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        multihash as API.MultihashDigest<Alg>,\n        bytes ?? encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest = Digest.decode(multihash) as API.MultihashDigest<Alg>\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param digest - (Multi)hash of the of the content.\n   */\n  static create <Data, Format extends number, Alg extends number, Version extends API.Version>(version: Version, code: Format, digest: API.MultihashDigest<Alg>): CID<Data, Format, Alg, Version> {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   */\n  static createV0 <T = unknown>(digest: API.MultihashDigest<typeof SHA_256_CODE>): CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0> {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @param code - Content encoding format code.\n   * @param digest - Multihash of the content.\n   */\n  static createV1 <Data, Code extends number, Alg extends number>(code: Code, digest: API.MultihashDigest<Alg>): CID<Data, Code, Alg, 1> {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   */\n  static decode <Data, Code extends number, Alg extends number, Version extends API.Version>(bytes: API.ByteView<API.Link<Data, Code, Alg, Version>>): CID<Data, Code, Alg, Version> {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length !== 0) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   */\n  static decodeFirst <T, C extends number, A extends number, V extends API.Version>(bytes: API.ByteView<API.Link<T, C, A, V>>): [CID<T, C, A, V>, Uint8Array] {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(digest as API.MultihashDigest<API.SHA_256>)\n        : CID.createV1(specs.codec, digest)\n    return [cid as CID<T, C, A, V>, bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   */\n  static inspectBytes <T, C extends number, A extends number, V extends API.Version>(initialBytes: API.ByteView<API.Link<T, C, A, V>>): { version: V, codec: C, multihashCode: A, digestSize: number, multihashSize: number, size: number } {\n    let offset = 0\n    const next = (): number => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = next() as V\n    let codec = DAG_PB_CODE as C\n    if (version as number === 18) {\n      // CIDv0\n      version = 0 as V\n      offset = 0\n    } else {\n      codec = next() as C\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = next() as A // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   */\n  static parse <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version>(source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): CID<Data, Code, Alg, Version> {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\nfunction parseCIDtoBytes <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version> (source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): [Prefix, API.ByteView<API.Link<Data, Code, Alg, Version>>] {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base ?? base58btc\n      return [\n        base58btc.prefix as Prefix,\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base ?? base58btc\n      return [base58btc.prefix as Prefix, decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base ?? base32\n      return [base32.prefix as Prefix, decoder.decode(source)]\n    }\n    case base36.prefix: {\n      const decoder = base ?? base36\n      return [base36.prefix as Prefix, decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [source[0] as Prefix, base.decode(source)]\n    }\n  }\n}\n\nfunction toStringV0 (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<'z'>): string {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nfunction toStringV1 <Prefix extends string> (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<Prefix>): string {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\nfunction encodeCID (version: API.Version, code: number, multihash: Uint8Array): Uint8Array {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n", "import * as base10 from './bases/base10.js'\nimport * as base16 from './bases/base16.js'\nimport * as base2 from './bases/base2.js'\nimport * as base256emoji from './bases/base256emoji.js'\nimport * as base32 from './bases/base32.js'\nimport * as base36 from './bases/base36.js'\nimport * as base58 from './bases/base58.js'\nimport * as base64 from './bases/base64.js'\nimport * as base8 from './bases/base8.js'\nimport * as identityBase from './bases/identity.js'\nimport * as json from './codecs/json.js'\nimport * as raw from './codecs/raw.js'\nimport * as identity from './hashes/identity.js'\nimport * as sha2 from './hashes/sha2.js'\nimport { CID, hasher, digest, varint, bytes } from './index.js'\n\nexport const bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji }\nexport const hashes = { ...sha2, ...identity }\nexport const codecs = { raw, json }\n\nexport { CID, hasher, digest, varint, bytes }\n", "import { bases } from 'multiformats/basics'\nimport type { MultibaseCodec } from 'multiformats'\nimport { allocUnsafe } from '#alloc'\n\nfunction createCodec (name: string, prefix: string, encode: (buf: Uint8Array) => string, decode: (str: string) => Uint8Array): MultibaseCodec<any> {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: {\n      decode\n    }\n  }\n}\n\nconst string = createCodec('utf8', 'u', (buf) => {\n  const decoder = new TextDecoder('utf8')\n  return 'u' + decoder.decode(buf)\n}, (str) => {\n  const encoder = new TextEncoder()\n  return encoder.encode(str.substring(1))\n})\n\nconst ascii = createCodec('ascii', 'a', (buf) => {\n  let string = 'a'\n\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i])\n  }\n  return string\n}, (str) => {\n  str = str.substring(1)\n  const buf = allocUnsafe(str.length)\n\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i)\n  }\n\n  return buf\n})\n\nexport type SupportedEncodings = 'utf8' | 'utf-8' | 'hex' | 'latin1' | 'ascii' | 'binary' | keyof typeof bases\n\nconst BASES: Record<SupportedEncodings, MultibaseCodec<any>> = {\n  utf8: string,\n  'utf-8': string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii,\n  binary: ascii,\n\n  ...bases\n}\n\nexport default BASES\n", "import bases, { type SupportedEncodings } from './util/bases.js'\n\nexport type { SupportedEncodings }\n\n/**\n * Create a `Uint8Array` from the passed string\n *\n * Supports `utf8`, `utf-8`, `hex`, and any encoding supported by the multiformats module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function fromString (string: string, encoding: SupportedEncodings = 'utf8'): Uint8Array {\n  const base = bases[encoding]\n\n  if (base == null) {\n    throw new Error(`Unsupported encoding \"${encoding}\"`)\n  }\n\n  // add multibase prefix\n  return base.decoder.decode(`${base.prefix}${string}`) // eslint-disable-line @typescript-eslint/restrict-template-expressions\n}\n", "import bases, { type SupportedEncodings } from './util/bases.js'\n\nexport type { SupportedEncodings }\n\n/**\n * Turns a `Uint8Array` into a string.\n *\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function toString (array: Uint8Array, encoding: SupportedEncodings = 'utf8'): string {\n  const base = bases[encoding]\n\n  if (base == null) {\n    throw new Error(`Unsupported encoding \"${encoding}\"`)\n  }\n\n  // strip multibase prefix\n  return base.encoder.encode(array).substring(1)\n}\n", "/**\n * Thrown when an invalid multiaddr is encountered\n */\nexport class InvalidMultiaddrError extends Error {\n  static name = 'InvalidMultiaddrError'\n  name = 'InvalidMultiaddrError'\n}\n\nexport class ValidationError extends Error {\n  static name = 'ValidationError'\n  name = 'ValidationError'\n}\n\nexport class InvalidParametersError extends Error {\n  static name = 'InvalidParametersError'\n  name = 'InvalidParametersError'\n}\n\nexport class UnknownProtocolError extends Error {\n  static name = 'UnknownProtocolError'\n  name = 'UnknownProtocolError'\n}\n", "/* eslint-disable @typescript-eslint/no-unsafe-return */\n\n// Heavily inspired by https://doc.rust-lang.org/src/std/net/parser.rs.html\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Fn = (...foo: any) => any;\n\nexport class Parser {\n  private index = 0;\n  private input = \"\";\n\n  new(input: string): this {\n    this.index = 0;\n    this.input = input;\n    return this;\n  }\n\n  /** Run a parser, and restore the pre-parse state if it fails. */\n  readAtomically<T extends Fn>(fn: T): ReturnType<T> {\n    const index = this.index;\n    const result = fn();\n    if (result === undefined) {\n      this.index = index;\n    }\n    return result;\n  }\n\n  /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */\n  parseWith<T extends Fn>(fn: T): ReturnType<T> | undefined {\n    const result = fn();\n    if (this.index !== this.input.length) {\n      return undefined;\n    }\n    return result;\n  }\n\n  /** Peek the next character from the input */\n  peekChar(): string | undefined {\n    if (this.index >= this.input.length) {\n      return undefined;\n    }\n    return this.input[this.index];\n  }\n\n  /** Read the next character from the input */\n  readChar(): string | undefined {\n    if (this.index >= this.input.length) {\n      return undefined;\n    }\n    return this.input[this.index++];\n  }\n\n  /** Read the next character from the input if it matches the target. */\n  readGivenChar(target: string): string | undefined {\n    return this.readAtomically(() => {\n      const char = this.readChar();\n      if (char !== target) {\n        return undefined;\n      }\n      return char;\n    });\n  }\n\n  /**\n   * Helper for reading separators in an indexed loop. Reads the separator\n   * character iff index > 0, then runs the parser. When used in a loop,\n   * the separator character will only be read on index > 0 (see\n   * readIPv4Addr for an example)\n   */\n  readSeparator<T extends Fn>(sep: string, index: number, inner: T): ReturnType<T> {\n    return this.readAtomically(() => {\n      if (index > 0) {\n        if (this.readGivenChar(sep) === undefined) {\n          return undefined;\n        }\n      }\n      return inner();\n    });\n  }\n\n  /**\n   * Read a number off the front of the input in the given radix, stopping\n   * at the first non-digit character or eof. Fails if the number has more\n   * digits than max_digits or if there is no number.\n   */\n  readNumber(\n    radix: number,\n    maxDigits: number | undefined,\n    allowZeroPrefix: boolean,\n    maxBytes: number\n  ): number | undefined {\n    return this.readAtomically(() => {\n      let result = 0;\n      let digitCount = 0;\n\n      const leadingChar = this.peekChar();\n      if (leadingChar === undefined) {\n        return undefined;\n      }\n      const hasLeadingZero = leadingChar === \"0\";\n      const maxValue = 2 ** (8 * maxBytes) - 1;\n\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        const digit = this.readAtomically(() => {\n          const char = this.readChar();\n          if (char === undefined) {\n            return undefined;\n          }\n          const num = Number.parseInt(char, radix);\n          if (Number.isNaN(num)) {\n            return undefined;\n          }\n          return num;\n        });\n        if (digit === undefined) {\n          break;\n        }\n        result *= radix;\n        result += digit;\n        if (result > maxValue) {\n          return undefined;\n        }\n        digitCount += 1;\n        if (maxDigits !== undefined) {\n          if (digitCount > maxDigits) {\n            return undefined;\n          }\n        }\n      }\n\n      if (digitCount === 0) {\n        return undefined;\n      } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {\n        return undefined;\n      } else {\n        return result;\n      }\n    });\n  }\n\n  /** Read an IPv4 address. */\n  readIPv4Addr(): Uint8Array | undefined {\n    return this.readAtomically(() => {\n      const out = new Uint8Array(4);\n\n      for (let i = 0; i < out.length; i++) {\n        const ix = this.readSeparator(\".\", i, () => this.readNumber(10, 3, false, 1));\n        if (ix === undefined) {\n          return undefined;\n        }\n        out[i] = ix;\n      }\n\n      return out;\n    });\n  }\n\n  /** Read an IPv6 Address. */\n  readIPv6Addr(): Uint8Array | undefined {\n    /**\n     * Read a chunk of an IPv6 address into `groups`. Returns the number\n     * of groups read, along with a bool indicating if an embedded\n     * trailing IPv4 address was read. Specifically, read a series of\n     * colon-separated IPv6 groups (0x0000 - 0xFFFF), with an optional\n     * trailing embedded IPv4 address.\n     */\n    const readGroups = (groups: Uint8Array): [number, boolean] => {\n      for (let i = 0; i < groups.length / 2; i++) {\n        const ix = i * 2;\n        // Try to read a trailing embedded IPv4 address. There must be at least 4 groups left.\n        if (i < groups.length - 3) {\n          const ipv4 = this.readSeparator(\":\", i, () => this.readIPv4Addr());\n          if (ipv4 !== undefined) {\n            groups[ix] = ipv4[0];\n            groups[ix + 1] = ipv4[1];\n            groups[ix + 2] = ipv4[2];\n            groups[ix + 3] = ipv4[3];\n\n            return [ix + 4, true];\n          }\n        }\n\n        const group = this.readSeparator(\":\", i, () => this.readNumber(16, 4, true, 2));\n        if (group === undefined) {\n          return [ix, false];\n        }\n        groups[ix] = group >> 8;\n        groups[ix + 1] = group & 255;\n      }\n      return [groups.length, false];\n    };\n\n    return this.readAtomically(() => {\n      // Read the front part of the address; either the whole thing, or up to the first ::\n      const head = new Uint8Array(16);\n      const [headSize, headIp4] = readGroups(head);\n\n      if (headSize === 16) {\n        return head;\n      }\n\n      // IPv4 part is not allowed before `::`\n      if (headIp4) {\n        return undefined;\n      }\n\n      // Read `::` if previous code parsed less than 8 groups.\n      // `::` indicates one or more groups of 16 bits of zeros.\n      if (this.readGivenChar(\":\") === undefined) {\n        return undefined;\n      }\n      if (this.readGivenChar(\":\") === undefined) {\n        return undefined;\n      }\n\n      // Read the back part of the address. The :: must contain at least one\n      // set of zeroes, so our max length is 7.\n      const tail = new Uint8Array(14);\n      const limit = 16 - (headSize + 2);\n      const [tailSize] = readGroups(tail.subarray(0, limit));\n\n      // Concat the head and tail of the IP address\n      head.set(tail.subarray(0, tailSize), 16 - tailSize);\n\n      return head;\n    });\n  }\n\n  /** Read an IP Address, either IPv4 or IPv6. */\n  readIPAddr(): Uint8Array | undefined {\n    return this.readIPv4Addr() ?? this.readIPv6Addr();\n  }\n}\n", "import { Parser } from \"./parser.js\";\n\n// See https://stackoverflow.com/questions/166132/maximum-length-of-the-textual-representation-of-an-ipv6-address\nconst MAX_IPV6_LENGTH = 45;\nconst MAX_IPV4_LENGTH = 15;\n\nconst parser = new Parser();\n\n/** Parse `input` into IPv4 bytes. */\nexport function parseIPv4(input: string): Uint8Array | undefined {\n  if (input.length > MAX_IPV4_LENGTH) {\n    return undefined;\n  }\n  return parser.new(input).parseWith(() => parser.readIPv4Addr());\n}\n\n/** Parse IPv4 `input` into IPv6 with IPv4-mapped bytes, eg ::ffff:1.2.3.4 */\nexport function parseIPv4Mapped(input: string): Uint8Array | undefined {\n  if (input.length > MAX_IPV4_LENGTH) {\n    return undefined;\n  }\n\n  const ipv4 = parser.new(input).parseWith(() => parser.readIPv4Addr());\n  if (ipv4 === undefined) {\n    return undefined;\n  }\n\n  return Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, ipv4[0], ipv4[1], ipv4[2], ipv4[3]]);\n}\n\n/** Parse `input` into IPv6 bytes. */\nexport function parseIPv6(input: string): Uint8Array | undefined {\n  // strip zone index if it is present\n  if (input.includes(\"%\")) {\n    input = input.split(\"%\")[0];\n  }\n  if (input.length > MAX_IPV6_LENGTH) {\n    return undefined;\n  }\n  return parser.new(input).parseWith(() => parser.readIPv6Addr());\n}\n\n/** Parse `input` into IPv4 or IPv6 bytes. */\nexport function parseIP(input: string, mapIPv4ToIPv6 = false): Uint8Array | undefined {\n  // strip zone index if it is present\n  if (input.includes(\"%\")) {\n    input = input.split(\"%\")[0];\n  }\n\n  if (input.length > MAX_IPV6_LENGTH) {\n    return undefined;\n  }\n\n  const addr = parser.new(input).parseWith(() => parser.readIPAddr());\n  if (!addr) {\n    return undefined;\n  }\n\n  if (mapIPv4ToIPv6 && addr.length === 4) {\n    return Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, addr[0], addr[1], addr[2], addr[3]]);\n  }\n\n  return addr;\n}\n", "import { parseIP, parseIPv4, parseIPv6 } from \"./parse.js\";\n\n/** Check if `input` is IPv4. */\nexport function isIPv4(input: string): boolean {\n  return Boolean(parseIPv4(input));\n}\n\n/** Check if `input` is IPv6. */\nexport function isIPv6(input: string): boolean {\n  return Boolean(parseIPv6(input));\n}\n\n/** Check if `input` is IPv4 or IPv6. */\nexport function isIP(input: string): boolean {\n  return Boolean(parseIP(input));\n}\n\n/**\n * @returns `6` if `input` is IPv6, `4` if `input` is IPv4, or `undefined` if `input` is neither.\n */\nexport function ipVersion(input: string): 4 | 6 | undefined {\n  if (isIPv4(input)) {\n    return 4;\n  } else if (isIPv6(input)) {\n    return 6;\n  } else {\n    return undefined;\n  }\n}\n", "import { isIPv4 } from '@chainsafe/is-ip'\nimport { base32 } from 'multiformats/bases/base32'\nimport { bases } from 'multiformats/basics'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { InvalidMultiaddrError } from './errors.ts'\nimport type { MultibaseCodec } from 'multiformats'\nimport type { SupportedEncodings } from 'uint8arrays/to-string'\n\nexport function bytesToString (base: SupportedEncodings): (buf: Uint8Array) => string {\n  return (buf) => {\n    return uint8ArrayToString(buf, base)\n  }\n}\n\nexport function stringToBytes (base: SupportedEncodings): (value: string) => Uint8Array {\n  return (buf) => {\n    return uint8ArrayFromString(buf, base)\n  }\n}\n\nexport function bytes2port (buf: Uint8Array): string {\n  const view = new DataView(buf.buffer)\n  return view.getUint16(buf.byteOffset).toString()\n}\n\nexport function port2bytes (port: string | number): Uint8Array {\n  const buf = new ArrayBuffer(2)\n  const view = new DataView(buf)\n  view.setUint16(0, typeof port === 'string' ? parseInt(port) : port)\n\n  return new Uint8Array(buf)\n}\n\nexport function onion2bytes (str: string): Uint8Array {\n  const addr = str.split(':')\n\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n\n  if (addr[0].length !== 16) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`)\n  }\n\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = uint8ArrayFromString(addr[0], 'base32')\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n\n  const portBuf = port2bytes(port)\n\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nexport function onion32bytes (str: string): Uint8Array {\n  const addr = str.split(':')\n\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n\n  if (addr[0].length !== 56) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`)\n  }\n\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode(`b${addr[0]}`)\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n\n  const portBuf = port2bytes(port)\n\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nexport function bytes2onion (buf: Uint8Array): string {\n  const addrBytes = buf.subarray(0, buf.length - 2)\n  const portBytes = buf.subarray(buf.length - 2)\n  const addr = uint8ArrayToString(addrBytes, 'base32')\n  const port = bytes2port(portBytes)\n  return `${addr}:${port}`\n}\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7\n// but with buf/offset args removed because we don't use them\nexport const ip4ToBytes = function (ip: string): Uint8Array {\n  ip = ip.toString().trim()\n\n  const bytes = new Uint8Array(4)\n\n  ip.split(/\\./g).forEach((byte, index) => {\n    const value = parseInt(byte, 10)\n\n    if (isNaN(value) || value < 0 || value > 0xff) {\n      throw new InvalidMultiaddrError('Invalid byte value in IP address')\n    }\n\n    bytes[index] = value\n  })\n\n  return bytes\n}\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7\n// but with buf/offset args removed because we don't use them\nexport const ip6ToBytes = function (ip: string): Uint8Array {\n  let offset = 0\n  ip = ip.toString().trim()\n\n  const sections = ip.split(':', 8)\n\n  let i\n  for (i = 0; i < sections.length; i++) {\n    const isv4 = isIPv4(sections[i])\n    let v4Buffer: Uint8Array | undefined\n\n    if (isv4) {\n      v4Buffer = ip4ToBytes(sections[i])\n      sections[i] = uint8ArrayToString(v4Buffer.subarray(0, 2), 'base16')\n    }\n\n    if (v4Buffer != null && ++i < 8) {\n      sections.splice(i, 0, uint8ArrayToString(v4Buffer.subarray(2, 4), 'base16'))\n    }\n  }\n\n  if (sections[0] === '') {\n    while (sections.length < 8) { sections.unshift('0') }\n  } else if (sections[sections.length - 1] === '') {\n    while (sections.length < 8) { sections.push('0') }\n  } else if (sections.length < 8) {\n    for (i = 0; i < sections.length && sections[i] !== ''; i++) { }\n    const argv: [number, number, ...string[]] = [i, 1]\n    for (i = 9 - sections.length; i > 0; i--) {\n      argv.push('0')\n    }\n    sections.splice.apply(sections, argv)\n  }\n\n  const bytes = new Uint8Array(offset + 16)\n\n  for (i = 0; i < sections.length; i++) {\n    if (sections[i] === '') {\n      sections[i] = '0'\n    }\n\n    const word = parseInt(sections[i], 16)\n\n    if (isNaN(word) || word < 0 || word > 0xffff) {\n      throw new InvalidMultiaddrError('Invalid byte value in IP address')\n    }\n\n    bytes[offset++] = (word >> 8) & 0xff\n    bytes[offset++] = word & 0xff\n  }\n\n  return bytes\n}\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L63\nexport const ip4ToString = function (buf: Uint8Array): string {\n  if (buf.byteLength !== 4) {\n    throw new InvalidMultiaddrError('IPv4 address was incorrect length')\n  }\n\n  const result = []\n\n  for (let i = 0; i < buf.byteLength; i++) {\n    result.push(buf[i])\n  }\n\n  return result.join('.')\n}\n\nexport const ip6ToString = function (buf: Uint8Array): string {\n  if (buf.byteLength !== 16) {\n    throw new InvalidMultiaddrError('IPv6 address was incorrect length')\n  }\n\n  const result: string[] = []\n\n  for (let i = 0; i < buf.byteLength; i += 2) {\n    const byte1 = buf[i]\n    const byte2 = buf[i + 1]\n\n    const tuple = `${byte1.toString(16).padStart(2, '0')}${byte2.toString(16).padStart(2, '0')}`\n\n    result.push(tuple)\n  }\n\n  const ip = result.join(':')\n\n  try {\n    const url = new URL(`http://[${ip}]`)\n\n    return url.hostname.substring(1, url.hostname.length - 1)\n  } catch {\n    throw new InvalidMultiaddrError(`Invalid IPv6 address \"${ip}\"`)\n  }\n}\n\nexport function ip6StringToValue (str: string): string {\n  try {\n    const url = new URL(`http://[${str}]`)\n\n    return url.hostname.substring(1, url.hostname.length - 1)\n  } catch {\n    throw new InvalidMultiaddrError(`Invalid IPv6 address \"${str}\"`)\n  }\n}\n\nconst decoders = Object.values(bases).map((c) => c.decoder)\nconst anybaseDecoder = (function () {\n  let acc = decoders[0].or(decoders[1])\n  decoders.slice(2).forEach((d) => (acc = acc.or(d)))\n  return acc\n})()\n\nexport function mb2bytes (mbstr: string): Uint8Array {\n  return anybaseDecoder.decode(mbstr)\n}\n\nexport function bytes2mb (base: MultibaseCodec<any>): (buf: Uint8Array) => string {\n  return (buf) => {\n    return base.encoder.encode(buf)\n  }\n}\n", "import { ValidationError } from './errors.ts'\n\nexport function integer (value: string): void {\n  const int = parseInt(value)\n\n  if (int.toString() !== value) {\n    throw new ValidationError('Value must be an integer')\n  }\n}\n\nexport function positive (value: any): void {\n  if (value < 0) {\n    throw new ValidationError('Value must be a positive integer, or zero')\n  }\n}\n\nexport function maxValue (max: number): (value: any) => void {\n  return (value) => {\n    if (value > max) {\n      throw new ValidationError(`Value must be smaller than or equal to ${max}`)\n    }\n  }\n}\n\nexport function validate (...funcs: Array<(value: string) => void>): (value: string) => void {\n  return (value) => {\n    for (const fn of funcs) {\n      fn(value)\n    }\n  }\n}\n\nexport const validatePort = validate(\n  integer,\n  positive,\n  maxValue(65_535)\n)\n", "import { isIPv4, isIPv6 } from '@chainsafe/is-ip'\nimport { CID } from 'multiformats'\nimport { base64url } from 'multiformats/bases/base64'\nimport { CODE_CERTHASH, CODE_DCCP, CODE_DNS, CODE_DNS4, CODE_DNS6, CODE_DNSADDR, CODE_GARLIC32, CODE_GARLIC64, CODE_HTTP, CODE_HTTP_PATH, CODE_HTTPS, CODE_IP4, CODE_IP6, CODE_IP6ZONE, CODE_IPCIDR, CODE_MEMORY, CODE_NOISE, CODE_ONION, CODE_ONION3, CODE_P2P, CODE_P2P_CIRCUIT, CODE_P2P_STARDUST, CODE_P2P_WEBRTC_DIRECT, CODE_P2P_WEBRTC_STAR, CODE_P2P_WEBSOCKET_STAR, CODE_QUIC, CODE_QUIC_V1, CODE_SCTP, CODE_SNI, CODE_TCP, CODE_TLS, CODE_UDP, CODE_UDT, CODE_UNIX, CODE_UTP, CODE_WEBRTC, CODE_WEBRTC_DIRECT, CODE_WEBTRANSPORT, CODE_WS, CODE_WSS } from './constants.ts'\nimport { UnknownProtocolError, ValidationError } from './errors.ts'\nimport { bytes2mb, bytes2onion, bytes2port, bytesToString, ip4ToBytes, ip4ToString, ip6StringToValue, ip6ToBytes, ip6ToString, mb2bytes, onion2bytes, onion32bytes, port2bytes, stringToBytes } from './utils.ts'\nimport { validatePort } from './validation.ts'\nimport type { Registry as RegistryInterface } from './index.ts'\n\nexport const V = -1\n\nexport interface ProtocolCodec {\n  /**\n   * A numeric code that will be used in the binary representation of the tuple.\n   */\n  code: number\n\n  /**\n   * A string name that will be used in the string representation of the addr.\n   */\n  name: string\n\n  /**\n   * Size defines the expected length of the address part of the tuple - valid\n   * values are `-1` (or the `V` constant) for variable length (this will be\n   * varint encoded in the binary representation), `0` for no address part or a\n   * number that represents a fixed-length address.\n   */\n  size?: number\n\n  /**\n   * If specified this protocol codec will also be used to decode tuples with\n   * these names from string multiaddrs.\n   */\n  aliases?: string[]\n\n  /**\n   * Where the multiaddr has been encoded as a string, decode the value if\n   * necessary, unescaping any escaped values\n   */\n  stringToValue?(value: string): string\n\n  /**\n   * To encode the multiaddr as a string, escape any necessary values\n   */\n  valueToString?(value: string): string\n\n  /**\n   * To encode the multiaddr as bytes, convert the value to bytes\n   */\n  valueToBytes?(value: string): Uint8Array\n\n  /**\n   * To decode bytes to a multiaddr, convert the value bytes to a string\n   */\n  bytesToValue?(bytes: Uint8Array): string\n\n  /**\n   * Perform any necessary validation on the string value\n   */\n  validate?(value: string): void\n}\n\nclass Registry implements RegistryInterface {\n  private protocolsByCode = new Map<number, ProtocolCodec>()\n  private protocolsByName = new Map<string, ProtocolCodec>()\n\n  getProtocol (key: string | number): ProtocolCodec {\n    let codec: ProtocolCodec | undefined\n\n    if (typeof key === 'string') {\n      codec = this.protocolsByName.get(key)\n    } else {\n      codec = this.protocolsByCode.get(key)\n    }\n\n    if (codec == null) {\n      throw new UnknownProtocolError(`Protocol ${key} was unknown`)\n    }\n\n    return codec\n  }\n\n  addProtocol (codec: ProtocolCodec): void {\n    this.protocolsByCode.set(codec.code, codec)\n    this.protocolsByName.set(codec.name, codec)\n\n    codec.aliases?.forEach(alias => {\n      this.protocolsByName.set(alias, codec)\n    })\n  }\n\n  removeProtocol (code: number): void {\n    const codec = this.protocolsByCode.get(code)\n\n    if (codec == null) {\n      return\n    }\n\n    this.protocolsByCode.delete(codec.code)\n    this.protocolsByName.delete(codec.name)\n\n    codec.aliases?.forEach(alias => {\n      this.protocolsByName.delete(alias)\n    })\n  }\n}\n\nexport const registry = new Registry()\n\nconst codecs: ProtocolCodec[] = [{\n  code: CODE_IP4,\n  name: 'ip4',\n  size: 32,\n  valueToBytes: ip4ToBytes,\n  bytesToValue: ip4ToString,\n  validate: (value) => {\n    if (!isIPv4(value)) {\n      throw new ValidationError(`Invalid IPv4 address \"${value}\"`)\n    }\n  }\n}, {\n  code: CODE_TCP,\n  name: 'tcp',\n  size: 16,\n  valueToBytes: port2bytes,\n  bytesToValue: bytes2port,\n  validate: validatePort\n}, {\n  code: CODE_UDP,\n  name: 'udp',\n  size: 16,\n  valueToBytes: port2bytes,\n  bytesToValue: bytes2port,\n  validate: validatePort\n}, {\n  code: CODE_DCCP,\n  name: 'dccp',\n  size: 16,\n  valueToBytes: port2bytes,\n  bytesToValue: bytes2port,\n  validate: validatePort\n}, {\n  code: CODE_IP6,\n  name: 'ip6',\n  size: 128,\n  valueToBytes: ip6ToBytes,\n  bytesToValue: ip6ToString,\n  stringToValue: ip6StringToValue,\n  validate: (value) => {\n    if (!isIPv6(value)) {\n      throw new ValidationError(`Invalid IPv6 address \"${value}\"`)\n    }\n  }\n}, {\n  code: CODE_IP6ZONE,\n  name: 'ip6zone',\n  size: V\n}, {\n  code: CODE_IPCIDR,\n  name: 'ipcidr',\n  size: 8,\n  bytesToValue: bytesToString('base10'),\n  valueToBytes: stringToBytes('base10')\n}, {\n  code: CODE_DNS,\n  name: 'dns',\n  size: V\n}, {\n  code: CODE_DNS4,\n  name: 'dns4',\n  size: V\n}, {\n  code: CODE_DNS6,\n  name: 'dns6',\n  size: V\n}, {\n  code: CODE_DNSADDR,\n  name: 'dnsaddr',\n  size: V\n}, {\n  code: CODE_SCTP,\n  name: 'sctp',\n  size: 16,\n  valueToBytes: port2bytes,\n  bytesToValue: bytes2port,\n  validate: validatePort\n}, {\n  code: CODE_UDT,\n  name: 'udt'\n}, {\n  code: CODE_UTP,\n  name: 'utp'\n}, {\n  code: CODE_UNIX,\n  name: 'unix',\n  size: V,\n  stringToValue: (str) => decodeURIComponent(str),\n  valueToString: (val) => encodeURIComponent(val)\n}, {\n  code: CODE_P2P,\n  name: 'p2p',\n  aliases: ['ipfs'],\n  size: V,\n  bytesToValue: bytesToString('base58btc'),\n  valueToBytes: (val) => {\n    if (val.startsWith('Q') || val.startsWith('1')) {\n      return stringToBytes('base58btc')(val)\n    }\n\n    return CID.parse(val).multihash.bytes\n  }\n}, {\n  code: CODE_ONION,\n  name: 'onion',\n  size: 96,\n  bytesToValue: bytes2onion,\n  valueToBytes: onion2bytes\n}, {\n  code: CODE_ONION3,\n  name: 'onion3',\n  size: 296,\n  bytesToValue: bytes2onion,\n  valueToBytes: onion32bytes\n}, {\n  code: CODE_GARLIC64,\n  name: 'garlic64',\n  size: V\n}, {\n  code: CODE_GARLIC32,\n  name: 'garlic32',\n  size: V\n}, {\n  code: CODE_TLS,\n  name: 'tls'\n}, {\n  code: CODE_SNI,\n  name: 'sni',\n  size: V\n}, {\n  code: CODE_NOISE,\n  name: 'noise'\n}, {\n  code: CODE_QUIC,\n  name: 'quic'\n}, {\n  code: CODE_QUIC_V1,\n  name: 'quic-v1'\n}, {\n  code: CODE_WEBTRANSPORT,\n  name: 'webtransport'\n}, {\n  code: CODE_CERTHASH,\n  name: 'certhash',\n  size: V,\n  bytesToValue: bytes2mb(base64url),\n  valueToBytes: mb2bytes\n}, {\n  code: CODE_HTTP,\n  name: 'http'\n}, {\n  code: CODE_HTTP_PATH,\n  name: 'http-path',\n  size: V,\n  stringToValue: (str) => `/${decodeURIComponent(str)}`,\n  valueToString: (val) => encodeURIComponent(val.substring(1))\n}, {\n  code: CODE_HTTPS,\n  name: 'https'\n}, {\n  code: CODE_WS,\n  name: 'ws'\n}, {\n  code: CODE_WSS,\n  name: 'wss'\n}, {\n  code: CODE_P2P_WEBSOCKET_STAR,\n  name: 'p2p-websocket-star'\n}, {\n  code: CODE_P2P_STARDUST,\n  name: 'p2p-stardust'\n}, {\n  code: CODE_P2P_WEBRTC_STAR,\n  name: 'p2p-webrtc-star'\n}, {\n  code: CODE_P2P_WEBRTC_DIRECT,\n  name: 'p2p-webrtc-direct'\n}, {\n  code: CODE_WEBRTC_DIRECT,\n  name: 'webrtc-direct'\n}, {\n  code: CODE_WEBRTC,\n  name: 'webrtc'\n}, {\n  code: CODE_P2P_CIRCUIT,\n  name: 'p2p-circuit'\n}, {\n  code: CODE_MEMORY,\n  name: 'memory',\n  size: V\n}]\n\ncodecs.forEach(codec => {\n  registry.addProtocol(codec)\n})\n", "import * as varint from 'uint8-varint'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { InvalidMultiaddrError } from './errors.ts'\nimport { registry, V } from './registry.ts'\nimport type { Component } from './index.js'\nimport type { ProtocolCodec } from './registry.ts'\n\nexport function bytesToComponents (bytes: Uint8Array): Component[] {\n  const components: Component[] = []\n\n  let i = 0\n  while (i < bytes.length) {\n    const code = varint.decode(bytes, i)\n    const codec = registry.getProtocol(code)\n    const codeLength = varint.encodingLength(code)\n    const size = sizeForAddr(codec, bytes, i + codeLength)\n    let sizeLength = 0\n\n    if (size > 0 && codec.size === V) {\n      sizeLength = varint.encodingLength(size)\n    }\n\n    const componentLength = codeLength + sizeLength + size\n\n    const component: Component = {\n      code,\n      name: codec.name,\n      bytes: bytes.subarray(i, i + componentLength)\n    }\n\n    if (size > 0) {\n      const valueOffset = i + codeLength + sizeLength\n      const valueBytes = bytes.subarray(valueOffset, valueOffset + size)\n\n      component.value = codec.bytesToValue?.(valueBytes) ?? uint8ArrayToString(valueBytes)\n    }\n\n    components.push(component)\n\n    i += componentLength\n  }\n\n  return components\n}\n\nexport function componentsToBytes (components: Component[]): Uint8Array {\n  let length = 0\n  const bytes: Uint8Array[] = []\n\n  for (const component of components) {\n    if (component.bytes == null) {\n      const codec = registry.getProtocol(component.code)\n      const codecLength = varint.encodingLength(component.code)\n      let valueBytes: Uint8Array | undefined\n      let valueLength = 0\n      let valueLengthLength = 0\n\n      if (component.value != null) {\n        valueBytes = codec.valueToBytes?.(component.value) ?? uint8ArrayFromString(component.value)\n        valueLength = valueBytes.byteLength\n\n        if (codec.size === V) {\n          valueLengthLength = varint.encodingLength(valueLength)\n        }\n      }\n\n      const bytes = new Uint8Array(codecLength + valueLengthLength + valueLength)\n\n      // encode the protocol code\n      let offset = 0\n      varint.encodeUint8Array(component.code, bytes, offset)\n      offset += codecLength\n\n      // if there is a value\n      if (valueBytes != null) {\n        // if the value has variable length, encode the length\n        if (codec.size === V) {\n          varint.encodeUint8Array(valueLength, bytes, offset)\n          offset += valueLengthLength\n        }\n\n        // finally encode the value\n        bytes.set(valueBytes, offset)\n      }\n\n      component.bytes = bytes\n    }\n\n    bytes.push(component.bytes)\n    length += component.bytes.byteLength\n  }\n\n  return uint8ArrayConcat(bytes, length)\n}\n\nexport function stringToComponents (string: string): Component[] {\n  if (string.charAt(0) !== '/') {\n    throw new InvalidMultiaddrError('String multiaddr must start with \"/\"')\n  }\n\n  const components: Component[] = []\n  let collecting: 'protocol' | 'value' = 'protocol'\n  let value = ''\n  let protocol = ''\n\n  for (let i = 1; i < string.length; i++) {\n    const char = string.charAt(i)\n\n    if (char !== '/') {\n      if (collecting === 'protocol') {\n        protocol += string.charAt(i)\n      } else {\n        value += string.charAt(i)\n      }\n    }\n\n    const ended = i === string.length - 1\n\n    if (char === '/' || ended) {\n      const codec = registry.getProtocol(protocol)\n\n      if (collecting === 'protocol') {\n        if (codec.size == null || codec.size === 0) {\n          // a protocol without an address, eg. `/tls`\n          components.push({\n            code: codec.code,\n            name: codec.name\n          })\n\n          value = ''\n          protocol = ''\n          collecting = 'protocol'\n\n          continue\n        } else if (ended) {\n          throw new InvalidMultiaddrError(`Component ${protocol} was missing value`)\n        }\n\n        // continue collecting value\n        collecting = 'value'\n      } else if (collecting === 'value') {\n        const component: Component = {\n          code: codec.code,\n          name: codec.name\n        }\n\n        if (codec.size != null && codec.size !== 0) {\n          if (value === '') {\n            throw new InvalidMultiaddrError(`Component ${protocol} was missing value`)\n          }\n\n          component.value = codec.stringToValue?.(value) ?? value\n        }\n\n        components.push(component)\n\n        value = ''\n        protocol = ''\n        collecting = 'protocol'\n      }\n    }\n  }\n\n  if (protocol !== '' && value !== '') {\n    throw new InvalidMultiaddrError('Incomplete multiaddr')\n  }\n\n  return components\n}\n\nexport function componentsToString (components: Component[]): string {\n  return `/${components.flatMap(component => {\n      if (component.value == null) {\n        return component.name\n      }\n\n      const codec = registry.getProtocol(component.code)\n\n      if (codec == null) {\n        throw new InvalidMultiaddrError(`Unknown protocol code ${component.code}`)\n      }\n\n      return [\n        component.name,\n        codec.valueToString?.(component.value) ?? component.value\n      ]\n    }).join('/')}`\n}\n\n/**\n * For the passed address, return the serialized size\n */\nfunction sizeForAddr (codec: ProtocolCodec, bytes: Uint8Array, offset: number): number {\n  if (codec.size == null || codec.size === 0) {\n    return 0\n  }\n\n  if (codec.size > 0) {\n    return codec.size / 8\n  }\n\n  return varint.decode(bytes, offset)\n}\n", "import { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { bytesToComponents, componentsToBytes, componentsToString, stringToComponents } from './components.js'\nimport { InvalidMultiaddrError, InvalidParametersError } from './errors.ts'\nimport { registry } from './registry.ts'\nimport { isMultiaddr } from './index.js'\nimport type { MultiaddrInput, Multiaddr as MultiaddrInterface, Component } from './index.js'\n\nconst inspect = Symbol.for('nodejs.util.inspect.custom')\nexport const symbol = Symbol.for('@multiformats/multiaddr')\n\nfunction toComponents (addr: MultiaddrInput): Component[] {\n  if (addr == null) {\n    addr = '/'\n  }\n\n  if (isMultiaddr(addr)) {\n    return addr.getComponents()\n  }\n\n  if (addr instanceof Uint8Array) {\n    return bytesToComponents(addr)\n  }\n\n  if (typeof addr === 'string') {\n    addr = addr\n      .replace(/\\/(\\/)+/, '/')\n      .replace(/(\\/)+$/, '')\n\n    if (addr === '') {\n      addr = '/'\n    }\n\n    return stringToComponents(addr)\n  }\n\n  if (Array.isArray(addr)) {\n    return addr\n  }\n\n  throw new InvalidMultiaddrError('Must be a string, Uint8Array, Component[], or another Multiaddr')\n}\n\ninterface MultiaddrOptions {\n  validate?: boolean\n}\n\n/**\n * Creates a {@link Multiaddr} from a {@link MultiaddrInput}\n */\nexport class Multiaddr implements MultiaddrInterface {\n  [symbol]: boolean = true\n  readonly #components: Component[]\n\n  // cache string representation\n  #string: string | undefined\n  // cache byte representation\n  #bytes: Uint8Array | undefined\n\n  constructor (addr: MultiaddrInput | Component[] = '/', options: MultiaddrOptions = {}) {\n    this.#components = toComponents(addr)\n\n    if (options.validate !== false) {\n      validate(this)\n    }\n  }\n\n  get bytes (): Uint8Array {\n    if (this.#bytes == null) {\n      this.#bytes = componentsToBytes(this.#components)\n    }\n\n    return this.#bytes\n  }\n\n  toString (): string {\n    if (this.#string == null) {\n      this.#string = componentsToString(this.#components)\n    }\n\n    return this.#string\n  }\n\n  toJSON (): string {\n    return this.toString()\n  }\n\n  getComponents (): Component[] {\n    return [\n      ...this.#components.map(c => ({ ...c }))\n    ]\n  }\n\n  encapsulate (addr: MultiaddrInput): MultiaddrInterface {\n    const ma = new Multiaddr(addr)\n\n    return new Multiaddr([\n      ...this.#components,\n      ...ma.getComponents()\n    ], {\n      validate: false\n    })\n  }\n\n  decapsulate (addr: Multiaddr | string): MultiaddrInterface {\n    const addrString = addr.toString()\n    const s = this.toString()\n    const i = s.lastIndexOf(addrString)\n\n    if (i < 0) {\n      throw new InvalidParametersError(`Address ${this.toString()} does not contain subaddress: ${addrString}`)\n    }\n\n    return new Multiaddr(s.slice(0, i), {\n      validate: false\n    })\n  }\n\n  decapsulateCode (code: number): Multiaddr {\n    let index\n\n    for (let i = this.#components.length - 1; i > -1; i--) {\n      if (this.#components[i].code === code) {\n        index = i\n        break\n      }\n    }\n\n    return new Multiaddr(this.#components.slice(0, index), {\n      validate: false\n    })\n  }\n\n  equals (addr: { bytes: Uint8Array }): boolean {\n    return uint8ArrayEquals(this.bytes, addr.bytes)\n  }\n\n  /**\n   * Returns Multiaddr as a human-readable string\n   * https://nodejs.org/api/util.html#utilinspectcustom\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'\n   * ```\n   */\n  [inspect] (): string {\n    return `Multiaddr(${this.toString()})`\n  }\n}\n\n/**\n * Ensures all multiaddr tuples are correct. Throws if any invalid protocols or\n * values are encountered.\n */\nexport function validate (addr: Multiaddr): void {\n  addr.getComponents()\n    .forEach(component => {\n      const codec = registry.getProtocol(component.code)\n\n      if (component.value == null) {\n        return\n      }\n\n      codec.validate?.(component.value)\n    })\n}\n", "/**\n * @packageDocumentation\n *\n * A standard way to represent addresses that\n *\n * - support any standard network protocol\n * - have a binary packed format\n * - have a nice string representation\n * - encapsulate well\n *\n * @example\n *\n * ```TypeScript\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const addr = multiaddr('/ip4/127.0.0.1/udp/1234')\n * // Multiaddr(/ip4/127.0.0.1/udp/1234)\n *\n * addr.bytes\n * // <Uint8Array 04 7f 00 00 01 11 04 d2>\n *\n * addr.toString()\n * // '/ip4/127.0.0.1/udp/1234'\n *\n * addr.getComponents()\n * // [\n * //   { code: 4, name: 'ip4', value: '127.0.0.1' },\n * //   { code: 273, name: 'udp', value: '1234' }\n * // ]\n *\n * addr.encapsulate('/sctp/5678')\n * // Multiaddr(/ip4/127.0.0.1/udp/1234/sctp/5678)\n * ```\n *\n * @example Adding custom protocols\n *\n * To add application-specific or experimental protocols, add a protocol codec\n * to the protocol registry:\n *\n * ```ts\n * import { registry, V, multiaddr } from '@multiformats/multiaddr'\n * import type { ProtocolCodec } from '@multiformats/multiaddr'\n *\n * const maWithCustomTuple = '/custom-protocol/hello'\n *\n * // throws UnknownProtocolError\n * multiaddr(maWithCustomTuple)\n *\n * const protocol: ProtocolCodec = {\n *   code: 2059,\n *   name: 'custom-protocol',\n *   size: V\n *   // V means variable length, can also be 0, a positive integer (e.g. a fixed\n *   // length or omitted\n * }\n *\n * registry.addProtocol(protocol)\n *\n * // does not throw UnknownProtocolError\n * multiaddr(maWithCustomTuple)\n *\n * // protocols can also be removed\n * registry.removeProtocol(protocol.code)\n * ```\n */\n\nimport { Multiaddr as MultiaddrClass, symbol } from './multiaddr.js'\nimport { registry, V } from './registry.ts'\nimport type { ProtocolCodec } from './registry.ts'\n\n/**\n * The protocol registry stores protocol codecs that allow transformation of\n * multiaddr tuples from bytes to string and back again, and also validation of\n * the address values.\n */\nexport interface Registry {\n  /**\n   * Retrieve a protocol definition by it's code or name\n   */\n  getProtocol (key: string | number): ProtocolCodec\n\n  /**\n   * Add a new protocol definition\n   */\n  addProtocol (codec: ProtocolCodec): void\n\n  /**\n   * Remove a protocol definition by it's code\n   */\n  removeProtocol (code: number): void\n}\n\n/**\n * These types can be parsed into a {@link Multiaddr} object\n */\nexport type MultiaddrInput = string | Multiaddr | Uint8Array | null | Component[]\n\n/**\n * A Component is a section of a multiaddr with a name/code, possibly with a\n * value.\n *\n * Component names/codes are defined in the protocol table.\n *\n * @see https://github.com/multiformats/multiaddr/blob/master/protocols.csv\n */\nexport interface Component {\n  /**\n   * The code of the component as defined in the protocol table\n   */\n  code: number\n\n  /**\n   * The name of the component as defined in the protocol table\n   */\n  name: string\n\n  /**\n   * The component value, if one is present\n   */\n  value?: string\n\n  /**\n   * The bytes that make up the component. This will be set if the multiaddr\n   * was parsed from a `Uint8Array`, or if `.bytes` has been accessed on it.\n   */\n  bytes?: Uint8Array\n}\n\nexport interface Multiaddr {\n  bytes: Uint8Array\n\n  /**\n   * Returns Multiaddr as a String\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').toString()\n   * // '/ip4/127.0.0.1/tcp/4001'\n   * ```\n   */\n  toString(): string\n\n  /**\n   * Returns Multiaddr as a JSON encoded object\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * JSON.stringify(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n   * // '/ip4/127.0.0.1/tcp/4001'\n   * ```\n   */\n  toJSON(): string\n\n  /**\n   * Returns the components that make up this Multiaddr\n   *\n   * @example\n   * ```ts\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').getComponents()\n   * // [{ name: 'ip4', code: 4, value: '127.0.0.1' }, { name: 'tcp', code: 6, value: '4001' }]\n   * ```\n   */\n  getComponents(): Component[]\n\n  /**\n   * Encapsulates a Multiaddr in another Multiaddr\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh3.toString()\n   * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'\n   * ```\n   *\n   * @param {MultiaddrInput} addr - Multiaddr to add into this Multiaddr\n   */\n  encapsulate(addr: MultiaddrInput): Multiaddr\n\n  /**\n   * Decapsulates a Multiaddr from another Multiaddr\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh3.decapsulate(mh2).toString()\n   * // '/ip4/8.8.8.8/tcp/1080'\n   * ```\n   *\n   * @param {Multiaddr | string} addr - Multiaddr to remove from this Multiaddr\n   */\n  decapsulate(addr: Multiaddr | string): Multiaddr\n\n  /**\n   * A more reliable version of `decapsulate` if you are targeting a specific\n   * code, such as 421 (the `p2p` protocol code). The last index of the code\n   * will be removed from the `Multiaddr`, and a new instance will be returned.\n   * If the code is not present, the original `Multiaddr` is returned.\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const addr = multiaddr('/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC')\n   * // Multiaddr(/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC)\n   *\n   * addr.decapsulateCode(421).toString()\n   * // '/ip4/0.0.0.0/tcp/8080'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/8080').decapsulateCode(421).toString()\n   * // '/ip4/127.0.0.1/tcp/8080'\n   * ```\n   */\n  decapsulateCode(code: number): Multiaddr\n\n  /**\n   * Checks if two Multiaddrs are the same\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh1.equals(mh1)\n   * // true\n   *\n   * mh1.equals(mh2)\n   * // false\n   * ```\n   */\n  equals(addr: { bytes: Uint8Array }): boolean\n}\n\n/**\n * Check if object is a {@link Multiaddr} instance\n *\n * @example\n *\n * ```js\n * import { isMultiaddr, multiaddr } from '@multiformats/multiaddr'\n *\n * isMultiaddr(5)\n * // false\n * isMultiaddr(multiaddr('/ip4/127.0.0.1'))\n * // true\n * ```\n */\nexport function isMultiaddr (value: any): value is Multiaddr {\n  return Boolean(value?.[symbol])\n}\n\n/**\n * A function that takes a {@link MultiaddrInput} and returns a {@link Multiaddr}\n *\n * @example\n * ```js\n * import { multiaddr } from '@libp2p/multiaddr'\n *\n * multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n *\n * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n */\nexport function multiaddr (addr?: MultiaddrInput): Multiaddr {\n  return new MultiaddrClass(addr)\n}\n\n/**\n * Export all table.csv codes. These are all named exports so can be tree-shaken\n * out by bundlers.\n */\nexport * from './constants.ts'\nexport { registry, V }\nexport type { ProtocolCodec }\n", "import type { Matcher, MultiaddrMatcher } from './index.js'\nimport type { Multiaddr, Component } from '@multiformats/multiaddr'\n\n/**\n * Matches a multiaddr component with the specified code but no value\n */\nexport const code = (code: number): Matcher => {\n  return {\n    match: (vals) => {\n      const component = vals[0]\n\n      if (component == null) {\n        return false\n      }\n\n      if (component.code !== code) {\n        return false\n      }\n\n      if (component.value != null) {\n        return false\n      }\n\n      return vals.slice(1)\n    }\n  }\n}\n\n/**\n * Matches a multiaddr component with the specified code and value. If the value\n * is omitted any non-undefined value is matched.\n */\nexport const value = (code: number, value?: string): Matcher => {\n  return {\n    match: (vals) => {\n      const component = vals[0]\n\n      if (component?.code !== code) {\n        return false\n      }\n\n      if (component.value == null) {\n        return false\n      }\n\n      if (value != null && component.value !== value) {\n        return false\n      }\n\n      return vals.slice(1)\n    }\n  }\n}\n\n/**\n * Matches a multiaddr component with the specified code and value. If the value\n * is omitted any non-undefined value is matched.\n */\nexport const not = (matcher: Matcher): Matcher => {\n  return {\n    match: (vals) => {\n      const result = matcher.match(vals)\n\n      if (result === false) {\n        return vals\n      }\n\n      return false\n    }\n  }\n}\n\n/**\n * An optional matcher\n */\nexport const optional = (matcher: Matcher): Matcher => {\n  return {\n    match: (vals) => {\n      const result = matcher.match(vals)\n\n      if (result === false) {\n        return vals\n      }\n\n      return result\n    }\n  }\n}\n\n/**\n * Matches any one of the passed matches\n */\nexport const or = (...matchers: Matcher[]): Matcher => {\n  return {\n    match: (vals) => {\n      let matches: Component[] | undefined\n\n      for (const matcher of matchers) {\n        const result = matcher.match(vals)\n\n        // no match\n        if (result === false) {\n          continue\n        }\n\n        // choose greediest matcher\n        if (matches == null || result.length < matches.length) {\n          matches = result\n        }\n      }\n\n      if (matches == null) {\n        return false\n      }\n\n      return matches\n    }\n  }\n}\n\n/**\n * Matches all of the passed matchers\n */\nexport const and = (...matchers: Matcher[]): Matcher => {\n  return {\n    match: (vals) => {\n      for (const matcher of matchers) {\n        // pass what's left of the array\n        const result = matcher.match(vals)\n\n        // no match\n        if (result === false) {\n          return false\n        }\n\n        vals = result\n      }\n\n      return vals\n    }\n  }\n}\n\n/**\n * Create a multiaddr matcher from the passed component matchers\n */\nexport function fmt (...matchers: Matcher[]): MultiaddrMatcher {\n  function match (ma?: Multiaddr): Component[] | false {\n    if (ma == null) {\n      return false\n    }\n\n    let parts = ma.getComponents()\n\n    for (const matcher of matchers) {\n      const result = matcher.match(parts)\n\n      if (result === false) {\n        return false\n      }\n\n      parts = result\n    }\n\n    return parts\n  }\n\n  function matches (ma?: Multiaddr): boolean {\n    const result = match(ma)\n\n    return result !== false\n  }\n\n  function exactMatch (ma?: Multiaddr): boolean {\n    const result = match(ma)\n\n    if (result === false) {\n      return false\n    }\n\n    return result.length === 0\n  }\n\n  return {\n    matchers,\n    matches,\n    exactMatch\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * This module exports various matchers that can be used to infer the type of a\n * passed multiaddr.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS } from '@multiformats/multiaddr-matcher'\n *\n * const ma = multiaddr('/dnsaddr/example.org')\n *\n * DNS.matches(ma) // true - this is a multiaddr with a DNS address at the start\n * ```\n *\n * @example\n *\n * The default matching behaviour ignores any subsequent tuples in the multiaddr.\n * If you want stricter matching you can use `.exactMatch`:\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS, Circuit } from '@multiformats/multiaddr-matcher'\n *\n * const ma = multiaddr('/dnsaddr/example.org/p2p/QmFoo/p2p-circuit/p2p/QmBar')\n *\n * DNS.exactMatch(ma) // false - this address has extra tuples after the DNS component\n * Circuit.matches(ma) // true\n * Circuit.exactMatch(ma) // true - the extra tuples are circuit relay related\n * ```\n */\n\nimport { CODE_P2P, CODE_DNS4, CODE_DNS6, CODE_DNSADDR, CODE_DNS, CODE_IP4, CODE_IP6, CODE_TCP, CODE_UDP, CODE_QUIC, CODE_QUIC_V1, CODE_WS, CODE_WSS, CODE_TLS, CODE_SNI, CODE_WEBRTC_DIRECT, CODE_CERTHASH, CODE_WEBTRANSPORT, CODE_P2P_CIRCUIT, CODE_WEBRTC, CODE_HTTP, CODE_UNIX, CODE_HTTPS, CODE_MEMORY, CODE_IP6ZONE, CODE_IPCIDR } from '@multiformats/multiaddr'\nimport { and, or, optional, fmt, code, value, not } from './utils.js'\nimport type { Multiaddr, Component } from '@multiformats/multiaddr'\n\n/**\n * A matcher accepts multiaddr components and either fails to match and returns\n * false or returns a sublist of unmatched components\n */\nexport interface Matcher {\n  match(parts: Component[]): Component[] | false\n}\n\n/**\n * A MultiaddrMatcher allows interpreting a multiaddr as a certain type of\n * multiaddr\n */\nexport interface MultiaddrMatcher {\n  /**\n   * The matchers that make up this MultiaddrMatcher - useful if you want to\n   * make your own custom matchers\n   */\n  matchers: Matcher[]\n\n  /**\n   * Returns true if the passed multiaddr can be treated as this type of\n   * multiaddr\n   */\n  matches(ma?: Multiaddr): boolean\n\n  /**\n   * Returns true if the passed multiaddr terminates as this type of\n   * multiaddr\n   */\n  exactMatch(ma?: Multiaddr): boolean\n}\n\n/**\n * Matches PeerId addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { PEER_ID } from '@multiformats/multiaddr-matcher'\n *\n * PEER_ID.matches(multiaddr('/p2p/Qmfoo')) // true\n * PEER_ID.matches(multiaddr('/ipfs/Qmfoo')) // true\n * ```\n */\nconst _PEER_ID = value(CODE_P2P)\n\nexport const PEER_ID = fmt(_PEER_ID)\n\n/**\n * DNS matchers\n */\nconst _DNS4 = value(CODE_DNS4)\nconst _DNS6 = value(CODE_DNS6)\nconst _DNSADDR = value(CODE_DNSADDR)\nconst _DNS = value(CODE_DNS)\n\n/**\n * Matches dns4 addresses.\n *\n * Use {@link DNS DNS} instead to match any type of DNS address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS4 } from '@multiformats/multiaddr-matcher'\n *\n * DNS4.matches(multiaddr('/dns4/example.org')) // true\n * ```\n */\nexport const DNS4 = fmt(_DNS4, optional(value(CODE_P2P)))\n\n/**\n * Matches dns6 addresses.\n *\n * Use {@link DNS DNS} instead to match any type of DNS address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS6 } from '@multiformats/multiaddr-matcher'\n *\n * DNS6.matches(multiaddr('/dns6/example.org')) // true\n * ```\n */\nexport const DNS6 = fmt(_DNS6, optional(value(CODE_P2P)))\n\n/**\n * Matches dnsaddr addresses.\n *\n * Use {@link DNS DNS} instead to match any type of DNS address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNSADDR } from '@multiformats/multiaddr-matcher'\n *\n * DNSADDR.matches(multiaddr('/dnsaddr/example.org')) // true\n * DNSADDR.matches(multiaddr('/dnsaddr/example.org/p2p/Qmfoo')) // true\n * ```\n */\nexport const DNSADDR = fmt(_DNSADDR, optional(value(CODE_P2P)))\n\n/**\n * Matches any dns address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS } from '@multiformats/multiaddr-matcher'\n *\n * DNS.matches(multiaddr('/dnsaddr/example.org')) // true\n * DNS.matches(multiaddr('/dns4/example.org')) // true\n * DNS.matches(multiaddr('/dns6/example.org')) // true\n * DNS.matches(multiaddr('/dns6/example.org/p2p/Qmfoo')) // true\n * ```\n */\nexport const DNS = fmt(or(_DNS, _DNSADDR, _DNS4, _DNS6), optional(value(CODE_P2P)))\n\nconst _IP4 = and(\n  value(CODE_IP4),\n  optional(value(CODE_IPCIDR))\n)\nconst _IP6 = and(\n  optional(value(CODE_IP6ZONE)),\n  value(CODE_IP6),\n  optional(value(CODE_IPCIDR))\n)\nconst _IP = or(_IP4, _IP6)\n\nconst _IP_OR_DOMAIN = or(_IP, _DNS, _DNS4, _DNS6, _DNSADDR)\n\n/**\n * A matcher for addresses that start with IP or DNS tuples.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { IP_OR_DOMAIN } from '@multiformats/multiaddr-matcher'\n *\n * IP_OR_DOMAIN.matches(multiaddr('/ip4/123.123.123.123')) // true\n * IP_OR_DOMAIN.matches(multiaddr('/ip4/123.123.123.123/p2p/QmFoo')) // true\n * IP_OR_DOMAIN.matches(multiaddr('/dns/example.com/p2p/QmFoo')) // true\n * IP_OR_DOMAIN.matches(multiaddr('/p2p/QmFoo')) // false\n * ```\n */\nexport const IP_OR_DOMAIN = fmt(or(_IP, and(or(_DNS, _DNSADDR, _DNS4, _DNS6), optional(value(CODE_P2P)))))\n\n/**\n * Matches ip4 addresses.\n *\n * Use {@link IP IP} instead to match any ip4/ip6 address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { IP4 } from '@multiformats/multiaddr-matcher'\n *\n * const ma = multiaddr('/ip4/123.123.123.123')\n *\n * IP4.matches(ma) // true\n * ```\n */\nexport const IP4 = fmt(_IP4)\n\n/**\n * Matches ip6 addresses.\n *\n * Use {@link IP IP} instead to match any ip4/ip6 address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { IP6 } from '@multiformats/multiaddr-matcher'\n *\n * const ma = multiaddr('/ip6/fe80::1cc1:a3b8:322f:cf22')\n *\n * IP6.matches(ma) // true\n * ```\n */\nexport const IP6 = fmt(_IP6)\n\n/**\n * Matches ip4 or ip6 addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { IP } from '@multiformats/multiaddr-matcher'\n *\n * IP.matches(multiaddr('/ip4/123.123.123.123')) // true\n * IP.matches(multiaddr('/ip6/fe80::1cc1:a3b8:322f:cf22')) // true\n * ```\n */\nexport const IP = fmt(_IP)\n\nconst _TCP = and(_IP_OR_DOMAIN, value(CODE_TCP))\nconst _UDP = and(_IP_OR_DOMAIN, value(CODE_UDP))\n\n/**\n * Matches TCP addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { TCP } from '@multiformats/multiaddr-matcher'\n *\n * TCP.matches(multiaddr('/ip4/123.123.123.123/tcp/1234')) // true\n * ```\n */\nexport const TCP = fmt(and(_TCP, optional(value(CODE_P2P))))\n\n/**\n * Matches UDP addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { UDP } from '@multiformats/multiaddr-matcher'\n *\n * UDP.matches(multiaddr('/ip4/123.123.123.123/udp/1234')) // true\n * ```\n */\nexport const UDP = fmt(_UDP)\n\nconst _QUIC = and(_UDP, code(CODE_QUIC), optional(value(CODE_P2P)))\nconst _QUIC_V1 = and(_UDP, code(CODE_QUIC_V1), optional(value(CODE_P2P)))\n\nconst QUIC_V0_OR_V1 = or(_QUIC, _QUIC_V1)\n\n/**\n * Matches QUIC addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { QUIC } from '@multiformats/multiaddr-matcher'\n *\n * QUIC.matches(multiaddr('/ip4/123.123.123.123/udp/1234/quic')) // true\n * ```\n */\nexport const QUIC = fmt(_QUIC)\n\n/**\n * Matches QUICv1 addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { QUIC_V1 } from '@multiformats/multiaddr-matcher'\n *\n * QUIC_V1.matches(multiaddr('/ip4/123.123.123.123/udp/1234/quic-v1')) // true\n * ```\n */\nexport const QUIC_V1 = fmt(_QUIC_V1)\n\nconst _WEB = or(\n  _IP_OR_DOMAIN,\n  _TCP,\n  _UDP,\n  _QUIC,\n  _QUIC_V1\n)\n\nconst _WebSockets = or(\n  and(_WEB, code(CODE_WS), optional(value(CODE_P2P)))\n)\n\n/**\n * Matches WebSocket addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebSockets } from '@multiformats/multiaddr-matcher'\n *\n * WebSockets.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/ws')) // true\n * ```\n */\nexport const WebSockets = fmt(_WebSockets)\n\nconst _WebSocketsSecure = or(\n  and(_WEB, code(CODE_WSS), optional(value(CODE_P2P))),\n  and(_WEB, code(CODE_TLS), optional(value(CODE_SNI)), code(CODE_WS), optional(value(CODE_P2P)))\n)\n\n/**\n * Matches secure WebSocket addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebSocketsSecure } from '@multiformats/multiaddr-matcher'\n *\n * WebSocketsSecure.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/wss')) // true\n * ```\n */\nexport const WebSocketsSecure = fmt(_WebSocketsSecure)\n\nconst _WebRTCDirect = and(_UDP, code(CODE_WEBRTC_DIRECT), optional(value(CODE_CERTHASH)), optional(value(CODE_CERTHASH)), optional(value(CODE_P2P)))\n\n/**\n * Matches WebRTC-direct addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebRTCDirect } from '@multiformats/multiaddr-matcher'\n *\n * WebRTCDirect.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/p2p/QmFoo/webrtc-direct/certhash/u....')) // true\n * ```\n */\nexport const WebRTCDirect = fmt(_WebRTCDirect)\n\nconst _WebTransport = and(_QUIC_V1, code(CODE_WEBTRANSPORT), optional(value(CODE_CERTHASH)), optional(value(CODE_CERTHASH)), optional(value(CODE_P2P)))\n\n/**\n * Matches WebTransport addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebRTCDirect } from '@multiformats/multiaddr-matcher'\n *\n * WebRTCDirect.matches(multiaddr('/ip4/123.123.123.123/udp/1234/quic-v1/webtransport/certhash/u..../certhash/u..../p2p/QmFoo')) // true\n * ```\n */\nexport const WebTransport = fmt(_WebTransport)\n\nconst _P2P = or(\n  _WebSockets,\n  _WebSocketsSecure,\n  and(_TCP, optional(value(CODE_P2P))),\n  and(QUIC_V0_OR_V1, optional(value(CODE_P2P))),\n  and(_IP_OR_DOMAIN, optional(value(CODE_P2P))),\n  _WebRTCDirect,\n  _WebTransport,\n  value(CODE_P2P)\n)\n\n/**\n * Matches peer addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { P2P } from '@multiformats/multiaddr-matcher'\n *\n * P2P.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/p2p/QmFoo')) // true\n * ```\n */\nexport const P2P = fmt(_P2P)\n\nconst _Circuit = and(optional(_P2P), code(CODE_P2P_CIRCUIT), not(code(CODE_WEBRTC)), optional(value(CODE_P2P)))\n\n/**\n * Matches circuit relay addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { Circuit } from '@multiformats/multiaddr-matcher'\n *\n * Circuit.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/p2p/QmRelay/p2p-circuit/p2p/QmTarget')) // true\n * ```\n */\nexport const Circuit = fmt(_Circuit)\n\nconst _WebRTC = or(\n  and(_P2P, code(CODE_P2P_CIRCUIT), code(CODE_WEBRTC), optional(value(CODE_P2P))),\n  and(_P2P, code(CODE_WEBRTC), optional(value(CODE_P2P))),\n  and(code(CODE_WEBRTC), optional(value(CODE_P2P)))\n)\n\n/**\n * Matches WebRTC addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebRTC } from '@multiformats/multiaddr-matcher'\n *\n * WebRTC.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/p2p/QmRelay/p2p-circuit/webrtc/p2p/QmTarget')) // true\n * ```\n */\nexport const WebRTC = fmt(_WebRTC)\n\nconst _HTTP = or(\n  and(_IP_OR_DOMAIN, value(CODE_TCP), code(CODE_HTTP), optional(value(CODE_P2P))),\n  and(_IP_OR_DOMAIN, code(CODE_HTTP), optional(value(CODE_P2P)))\n)\n\n/**\n * Matches HTTP addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { HTTP } from '@multiformats/multiaddr-matcher'\n *\n * HTTP.matches(multiaddr('/dns/example.org/http')) // true\n * ```\n */\nexport const HTTP = fmt(_HTTP)\n\nconst _HTTPS = and(_IP_OR_DOMAIN, or(\n  and(value(CODE_TCP, '443'), code(CODE_HTTP)),\n  and(value(CODE_TCP), code(CODE_HTTPS)),\n  and(value(CODE_TCP), code(CODE_TLS), code(CODE_HTTP)),\n  and(code(CODE_TLS), code(CODE_HTTP)),\n  code(CODE_TLS),\n  code(CODE_HTTPS)\n),\noptional(value(CODE_P2P))\n)\n\n/**\n * Matches HTTPS addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { HTTP } from '@multiformats/multiaddr-matcher'\n *\n * HTTP.matches(multiaddr('/dns/example.org/tls/http')) // true\n * ```\n */\nexport const HTTPS = fmt(_HTTPS)\n\nconst _Memory = or(\n  and(value(CODE_MEMORY), optional(value(CODE_P2P)))\n)\n\n/**\n * Matches Memory addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { Memory } from '@multiformats/multiaddr-matcher'\n *\n * Memory.matches(multiaddr('/memory/0xDEADBEEF')) // true\n * ```\n */\nexport const Memory = fmt(_Memory)\n\nconst _Unix = or(\n  and(value(CODE_UNIX), optional(value(CODE_P2P)))\n)\n\n/**\n * Matches Unix addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { Unix } from '@multiformats/multiaddr-matcher'\n *\n * Unix.matches(multiaddr('/unix/%2Fpath%2Fto%2Funix.socket')) // true\n * ```\n */\nexport const Unix = fmt(_Unix)\n", "/**\n * @packageDocumentation\n *\n * This module allows easy conversion of Multiaddrs to string URIs.\n *\n * @example Converting multiaddrs to string URIs\n *\n * ```js\n * import { multiaddrToUri } from '@multiformats/multiaddr-to-uri'\n *\n * console.log(multiaddrToUri('/dnsaddr/protocol.ai/https'))\n * // -> https://protocol.ai\n *\n * console.log(multiaddrToUri('/ip4/127.0.0.1/tcp/8080'))\n * // -> http://127.0.0.1:8080\n *\n * console.log(multiaddrToUri('/ip4/127.0.0.1/tcp/8080', { assumeHttp: false }))\n * // -> tcp://127.0.0.1:8080\n * ```\n *\n * Note:\n *\n * - When `/tcp` is the last (terminating) protocol HTTP is assumed by default (implicit `assumeHttp: true`)\n *   - this means produced URIs will start with `http://` instead of `tcp://`\n *   - passing `{ assumeHttp: false }` disables this behavior\n * - Might be lossy - e.g. a DNSv6 multiaddr\n * - Can throw if the passed multiaddr:\n *   - is not a valid multiaddr\n *   - is not supported as a URI e.g. circuit\n */\n\nimport { CODE_TCP, CODE_DNS, CODE_DNS4, CODE_DNS6, CODE_DNSADDR, multiaddr, CODE_TLS, CODE_IP6 } from '@multiformats/multiaddr'\nimport type { Component, Multiaddr } from '@multiformats/multiaddr'\n\nexport interface MultiaddrToUriOpts {\n  assumeHttp?: boolean\n}\n\nconst ASSUME_HTTP_CODES = [\n  CODE_TCP,\n  CODE_DNS,\n  CODE_DNSADDR,\n  CODE_DNS4,\n  CODE_DNS6\n]\n\ninterface Interpreter {\n  (head: Component, rest: Component[]): string | undefined\n}\n\nfunction extractSNI (ma: Component[]): string | undefined {\n  return extractTuple('sni', ma)?.value\n}\n\nfunction extractPort (ma: Component[]): string {\n  const port = extractTuple('tcp', ma)?.value\n\n  if (port == null) {\n    return ''\n  }\n\n  return `:${port}`\n}\n\nfunction extractTuple (name: string, ma: Component[]): Component | undefined {\n  return ma.find(component => component.name === name)\n}\n\nfunction hasTLS (ma: Component[]): boolean {\n  return ma.some(({ code }) => code === CODE_TLS)\n}\n\nfunction interpretNext (head: Component, rest: Component[]): string | undefined {\n  const interpreter = interpreters[head.name]\n  if (interpreter == null) {\n    throw new Error(`Can't interpret protocol ${head.name}`)\n  }\n  const restVal = interpreter(head, rest)\n  if (head.code === CODE_IP6) {\n    return `[${restVal}]`\n  }\n  return restVal\n}\n\nconst interpreters: Record<string, Interpreter> = {\n  ip4: (head, rest) => head.value,\n  ip6: (head, rest) => {\n    if (rest.length === 0) {\n      return head.value\n    }\n    return `[${head.value}]`\n  },\n  tcp: (head, rest) => {\n    const tail = rest.pop()\n    if (tail == null) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `tcp://${interpretNext(tail, rest)}:${head.value}`\n  },\n  udp: (head, rest) => {\n    const tail = rest.pop()\n    if (tail == null) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `udp://${interpretNext(tail, rest)}:${head.value}`\n  },\n  dnsaddr: (head, rest) => head.value,\n  dns4: (head, rest) => head.value,\n  dns6: (head, rest) => head.value,\n  dns: (head, rest) => head.value,\n  ipfs: (head, rest) => {\n    const tail = rest.pop()\n    if (tail == null) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tail, rest)}`\n  },\n  p2p: (head, rest) => {\n    const tail = rest.pop()\n    if (tail == null) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tail, rest)}`\n  },\n  http: (head, rest) => {\n    const maHasTLS = hasTLS(rest)\n    const sni = extractSNI(rest)\n    const port = extractPort(rest)\n    if (maHasTLS && sni != null) {\n      return `https://${sni}${port}`\n    }\n    const protocol = maHasTLS ? 'https://' : 'http://'\n    const tail = rest.pop()\n    if (tail == null) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tail, rest)\n    // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n    baseVal = baseVal?.replace('tcp://', '')\n    return `${protocol}${baseVal}`\n  },\n  'http-path': (head, rest) => {\n    const tail = rest.pop()\n    if (tail == null) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    const baseVal = interpretNext(tail, rest)\n    const decodedValue = decodeURIComponent(head.value ?? '')\n    return `${baseVal}${decodedValue}`\n  },\n  tls: (head, rest) => {\n    // Noop, the parent context knows that it's tls. We don't need to do\n    // anything here\n    const tail = rest.pop()\n    if (tail == null) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return interpretNext(tail, rest)\n  },\n  sni: (head, rest) => {\n    // Noop, the parent context uses the sni information, we don't need to do\n    // anything here\n    const tail = rest.pop()\n    if (tail == null) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return interpretNext(tail, rest)\n  },\n  https: (head, rest) => {\n    const tail = rest.pop()\n    if (tail == null) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tail, rest)\n    // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n    baseVal = baseVal?.replace('tcp://', '')\n    return `https://${baseVal}`\n  },\n  ws: (head, rest) => {\n    const maHasTLS = hasTLS(rest)\n    const sni = extractSNI(rest)\n    const port = extractPort(rest)\n    if (maHasTLS && sni != null) {\n      return `wss://${sni}${port}`\n    }\n    const protocol = maHasTLS ? 'wss://' : 'ws://'\n    const tail = rest.pop()\n    if (tail == null) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tail, rest)\n    // We are reinterpreting the base, so we need to remove the tcp:// if it's there\n    baseVal = baseVal?.replace('tcp://', '')\n    return `${protocol}${baseVal}`\n  },\n  wss: (head, rest) => {\n    const tail = rest.pop()\n    if (tail == null) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tail, rest)\n    // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n    baseVal = baseVal?.replace('tcp://', '')\n    return `wss://${baseVal}`\n  }\n}\n\nexport function multiaddrToUri (input: Multiaddr | string | Uint8Array, opts?: MultiaddrToUriOpts): string {\n  const ma = multiaddr(input)\n  const components = ma.getComponents()\n  const head = components.pop()\n  if (head == null) {\n    throw new Error('Unexpected end of multiaddr')\n  }\n\n  const interpreter = interpreters[head.name]\n\n  if (interpreter == null) {\n    throw new Error(`No interpreter found for ${head.name}`)\n  }\n\n  let uri = interpreter(head, components) ?? ''\n\n  if (opts?.assumeHttp !== false && ASSUME_HTTP_CODES.includes(head.code)) {\n    // strip any declared protocol\n    uri = uri.replace(/^.*:\\/\\//, '')\n\n    if (head.value === '443') {\n      uri = `https://${uri}`\n    } else {\n      uri = `http://${uri}`\n    }\n  }\n\n  if (uri.startsWith('http://') || uri.startsWith('https://') || uri.startsWith('ws://') || uri.startsWith('wss://')) {\n    // this will strip default ports while keeping paths intact\n    uri = new URL(uri).toString()\n\n    // strip trailing slash, e.g. http://127.0.0.1/ -> http://127.0.0.1\n    if (uri.endsWith('/')) {\n      uri = uri.substring(0, uri.length - 1)\n    }\n  }\n\n  return uri\n}\n", "export class TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\n/**\nAn error to be thrown when the request is aborted by AbortController.\nDOMException is thrown instead of this Error when DOMException is available.\n*/\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\n/**\nTODO: Remove AbortError and just throw DOMException when targeting Node 18.\n*/\nconst getDOMException = errorMessage => globalThis.DOMException === undefined\n\t? new AbortError(errorMessage)\n\t: new DOMException(errorMessage);\n\n/**\nTODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.\n*/\nconst getAbortedReason = signal => {\n\tconst reason = signal.reason === undefined\n\t\t? getDOMException('This operation was aborted.')\n\t\t: signal.reason;\n\n\treturn reason instanceof Error ? reason : getDOMException(reason);\n};\n\nexport default function pTimeout(promise, options) {\n\tconst {\n\t\tmilliseconds,\n\t\tfallback,\n\t\tmessage,\n\t\tcustomTimers = {setTimeout, clearTimeout},\n\t} = options;\n\n\tlet timer;\n\tlet abortHandler;\n\n\tconst wrappedPromise = new Promise((resolve, reject) => {\n\t\tif (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n\t\t\tthrow new TypeError(`Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``);\n\t\t}\n\n\t\tif (options.signal) {\n\t\t\tconst {signal} = options;\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t}\n\n\t\t\tabortHandler = () => {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t};\n\n\t\t\tsignal.addEventListener('abort', abortHandler, {once: true});\n\t\t}\n\n\t\tif (milliseconds === Number.POSITIVE_INFINITY) {\n\t\t\tpromise.then(resolve, reject);\n\t\t\treturn;\n\t\t}\n\n\t\t// We create the error outside of `setTimeout` to preserve the stack trace.\n\t\tconst timeoutError = new TimeoutError();\n\n\t\ttimer = customTimers.setTimeout.call(undefined, () => {\n\t\t\tif (fallback) {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(fallback());\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\n\t\t\tif (message === false) {\n\t\t\t\tresolve();\n\t\t\t} else if (message instanceof Error) {\n\t\t\t\treject(message);\n\t\t\t} else {\n\t\t\t\ttimeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;\n\t\t\t\treject(timeoutError);\n\t\t\t}\n\t\t}, milliseconds);\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tresolve(await promise);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t})();\n\t});\n\n\tconst cancelablePromise = wrappedPromise.finally(() => {\n\t\tcancelablePromise.clear();\n\t\tif (abortHandler && options.signal) {\n\t\t\toptions.signal.removeEventListener('abort', abortHandler);\n\t\t}\n\t});\n\n\tcancelablePromise.clear = () => {\n\t\tcustomTimers.clearTimeout.call(undefined, timer);\n\t\ttimer = undefined;\n\t};\n\n\treturn cancelablePromise;\n}\n", "import pTimeout from 'p-timeout';\n\nconst normalizeEmitter = emitter => {\n\tconst addListener = emitter.addEventListener || emitter.on || emitter.addListener;\n\tconst removeListener = emitter.removeEventListener || emitter.off || emitter.removeListener;\n\n\tif (!addListener || !removeListener) {\n\t\tthrow new TypeError('Emitter is not compatible');\n\t}\n\n\treturn {\n\t\taddListener: addListener.bind(emitter),\n\t\tremoveListener: removeListener.bind(emitter),\n\t};\n};\n\nexport function pEventMultiple(emitter, event, options) {\n\tlet cancel;\n\tconst returnValue = new Promise((resolve, reject) => {\n\t\toptions = {\n\t\t\trejectionEvents: ['error'],\n\t\t\tmultiArgs: false,\n\t\t\trejectionMultiArgs: false,\n\t\t\tresolveImmediately: false,\n\t\t\t...options,\n\t\t};\n\n\t\tif (!(options.count >= 0 && (options.count === Number.POSITIVE_INFINITY || Number.isInteger(options.count)))) {\n\t\t\tthrow new TypeError('The `count` option should be at least 0 or more');\n\t\t}\n\n\t\toptions.signal?.throwIfAborted();\n\n\t\t// Allow multiple events\n\t\tconst events = [event].flat();\n\n\t\tconst items = [];\n\t\tconst {addListener, removeListener} = normalizeEmitter(emitter);\n\n\t\tconst onItem = async (...arguments_) => {\n\t\t\tconst value = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\t\tif (options.filter) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!(await options.filter(value))) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tcancel();\n\t\t\t\t\treject(error);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\titems.push(value);\n\n\t\t\tif (options.count === items.length) {\n\t\t\t\tcancel();\n\t\t\t\tresolve(items);\n\t\t\t}\n\t\t};\n\n\t\tconst rejectHandler = (...arguments_) => {\n\t\t\tcancel();\n\t\t\treject(options.rejectionMultiArgs ? arguments_ : arguments_[0]);\n\t\t};\n\n\t\tcancel = () => {\n\t\t\tfor (const event of events) {\n\t\t\t\tremoveListener(event, onItem);\n\t\t\t}\n\n\t\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\t\t// Only remove rejection handler if we actually registered it\n\t\t\t\tif (!events.includes(rejectionEvent)) {\n\t\t\t\t\tremoveListener(rejectionEvent, rejectHandler);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfor (const event of events) {\n\t\t\taddListener(event, onItem);\n\t\t}\n\n\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\t// Skip registering rejection handler if we're already listening to this event\n\t\t\t// as the main event takes priority (as documented)\n\t\t\tif (!events.includes(rejectionEvent)) {\n\t\t\t\taddListener(rejectionEvent, rejectHandler);\n\t\t\t}\n\t\t}\n\n\t\tif (options.signal) {\n\t\t\toptions.signal.addEventListener('abort', () => {\n\t\t\t\trejectHandler(options.signal.reason);\n\t\t\t}, {once: true});\n\t\t}\n\n\t\tif (options.resolveImmediately) {\n\t\t\tresolve(items);\n\t\t}\n\t});\n\n\treturnValue.cancel = cancel;\n\n\tif (typeof options.timeout === 'number') {\n\t\tconst timeout = pTimeout(returnValue, {milliseconds: options.timeout});\n\t\t// When cancelling, also clear the timeout timer\n\t\ttimeout.cancel = () => {\n\t\t\tcancel();\n\t\t\ttimeout.clear();\n\t\t};\n\n\t\treturn timeout;\n\t}\n\n\treturn returnValue;\n}\n\nexport function pEvent(emitter, event, options) {\n\tif (typeof options === 'function') {\n\t\toptions = {filter: options};\n\t}\n\n\toptions = {\n\t\t...options,\n\t\tcount: 1,\n\t\tresolveImmediately: false,\n\t};\n\n\tconst arrayPromise = pEventMultiple(emitter, event, options);\n\tconst promise = arrayPromise.then(array => array[0]); // eslint-disable-line promise/prefer-await-to-then\n\tpromise.cancel = arrayPromise.cancel;\n\n\treturn promise;\n}\n\nexport function pEventIterator(emitter, event, options) {\n\tif (typeof options === 'function') {\n\t\toptions = {filter: options};\n\t}\n\n\t// Allow multiple events\n\tconst events = [event].flat();\n\n\toptions = {\n\t\trejectionEvents: ['error'],\n\t\tresolutionEvents: [],\n\t\tlimit: Number.POSITIVE_INFINITY,\n\t\tmultiArgs: false,\n\t\trejectionMultiArgs: false,\n\t\t...options,\n\t};\n\n\tconst {limit} = options;\n\tconst isValidLimit = limit >= 0 && (limit === Number.POSITIVE_INFINITY || Number.isInteger(limit));\n\tif (!isValidLimit) {\n\t\tthrow new TypeError('The `limit` option should be a non-negative integer or Infinity');\n\t}\n\n\toptions.signal?.throwIfAborted();\n\n\tif (limit === 0) {\n\t\t// Return an empty async iterator to avoid any further cost\n\t\treturn {\n\t\t\t[Symbol.asyncIterator]() {\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tasync next() {\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t};\n\t\t\t},\n\t\t};\n\t}\n\n\tconst {addListener, removeListener} = normalizeEmitter(emitter);\n\n\tlet isDone = false;\n\tlet error;\n\tlet hasPendingError = false;\n\tconst nextQueue = [];\n\tconst valueQueue = [];\n\tlet eventCount = 0;\n\tlet isLimitReached = false;\n\n\tconst valueHandler = (...arguments_) => {\n\t\teventCount++;\n\t\tisLimitReached = eventCount === limit;\n\n\t\tconst value = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\n\t\t\tresolve({done: false, value});\n\n\t\t\tif (isLimitReached) {\n\t\t\t\tcancel();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalueQueue.push(value);\n\n\t\tif (isLimitReached) {\n\t\t\tcancel();\n\t\t}\n\t};\n\n\tconst cancel = () => {\n\t\tisDone = true;\n\n\t\tfor (const event of events) {\n\t\t\tremoveListener(event, valueHandler);\n\t\t}\n\n\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\tremoveListener(rejectionEvent, rejectHandler);\n\t\t}\n\n\t\tfor (const resolutionEvent of options.resolutionEvents) {\n\t\t\tremoveListener(resolutionEvent, resolveHandler);\n\t\t}\n\n\t\twhile (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\t\t\tresolve({done: true, value: undefined});\n\t\t}\n\t};\n\n\tconst rejectHandler = (...arguments_) => {\n\t\terror = options.rejectionMultiArgs ? arguments_ : arguments_[0];\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {reject} = nextQueue.shift();\n\t\t\treject(error);\n\t\t} else {\n\t\t\thasPendingError = true;\n\t\t}\n\n\t\tcancel();\n\t};\n\n\tconst resolveHandler = async (...arguments_) => {\n\t\tconst value = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\tif (options.filter) {\n\t\t\ttry {\n\t\t\t\tif (!(await options.filter(value))) {\n\t\t\t\t\tcancel();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} catch (filterError) {\n\t\t\t\tcancel();\n\t\t\t\tif (nextQueue.length > 0) {\n\t\t\t\t\tconst {reject} = nextQueue.shift();\n\t\t\t\t\treject(filterError);\n\t\t\t\t} else {\n\t\t\t\t\t// Store error for next iterator call\n\t\t\t\t\thasPendingError = true;\n\t\t\t\t\terror = filterError;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\t\t\tresolve({done: true, value});\n\t\t} else {\n\t\t\tvalueQueue.push(value);\n\t\t}\n\n\t\tcancel();\n\t};\n\n\tfor (const event of events) {\n\t\taddListener(event, valueHandler);\n\t}\n\n\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\taddListener(rejectionEvent, rejectHandler);\n\t}\n\n\tfor (const resolutionEvent of options.resolutionEvents) {\n\t\taddListener(resolutionEvent, resolveHandler);\n\t}\n\n\tif (options.signal) {\n\t\toptions.signal.addEventListener('abort', () => {\n\t\t\trejectHandler(options.signal.reason);\n\t\t}, {once: true});\n\t}\n\n\treturn {\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn this;\n\t\t},\n\t\tasync next() {\n\t\t\tif (valueQueue.length > 0) {\n\t\t\t\tconst value = valueQueue.shift();\n\t\t\t\treturn {\n\t\t\t\t\tdone: isDone && valueQueue.length === 0 && !isLimitReached,\n\t\t\t\t\tvalue,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (hasPendingError) {\n\t\t\t\thasPendingError = false;\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tif (isDone) {\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tnextQueue.push({resolve, reject});\n\t\t\t});\n\t\t},\n\t\tasync return(value) {\n\t\t\tcancel();\n\t\t\treturn {\n\t\t\t\tdone: isDone,\n\t\t\t\tvalue,\n\t\t\t};\n\t\t},\n\t};\n}\n\nexport {TimeoutError} from 'p-timeout';\n", "/**\n * Progress events are emitted during long running operations\n */\nexport interface ProgressEvent<T extends string = any, D = unknown> {\n  /**\n   * The event type\n   */\n  type: T\n\n  /**\n   * Context-specific event information\n   */\n  detail: D\n}\n\n/**\n * An implementation of the ProgressEvent interface, this is essentially\n * a typed `CustomEvent` with a `type` property that lets us disambiguate\n * events passed to `progress` callbacks.\n */\nexport class CustomProgressEvent<D = unknown, T extends string = any> extends Event implements ProgressEvent<T, D> {\n  public type: T\n  public detail: D\n\n  constructor (type: T, detail?: D) {\n    super(type)\n\n    this.type = type\n    // @ts-expect-error detail may be undefined\n    this.detail = detail\n  }\n}\n\n/**\n * Define an `onProgress` callback that can be invoked with `ProgressEvent`s\n *\n * @example\n *\n * ```typescript\n * type MyOperationProgressEvents =\n *   ProgressEvent<'operation:start'> |\n *   ProgressEvent<'operation:success', Result> |\n *   ProgressEvent<'operation:error', Error>\n *\n * export interface MyOperationOptions extends ProgressOptions<MyOperationProgressEvents> {\n *  // define options here\n * }\n * ```\n */\nexport interface ProgressOptions<Event extends ProgressEvent = any> {\n  onProgress?: (evt: Event) => void\n}\n", "import type { Listener } from '@libp2p/interface'\n\nexport function createListener (): Listener {\n  throw new Error('WebSocket Servers can not be created in the browser!')\n}\n", "/**\n * @packageDocumentation\n *\n * A class that lets you do operations over a list of Uint8Arrays without\n * copying them.\n *\n * ```js\n * import { Uint8ArrayList } from 'uint8arraylist'\n *\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray()\n * // -> Uint8Array([0, 1, 2, 3, 4, 5])\n *\n * list.consume(3)\n * list.subarray()\n * // -> Uint8Array([3, 4, 5])\n *\n * // you can also iterate over the list\n * for (const buf of list) {\n *   // ..do something with `buf`\n * }\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ## Converting Uint8ArrayLists to Uint8Arrays\n *\n * There are two ways to turn a `Uint8ArrayList` into a `Uint8Array` - `.slice` and `.subarray` and one way to turn a `Uint8ArrayList` into a `Uint8ArrayList` with different contents - `.sublist`.\n *\n * ### slice\n *\n * Slice follows the same semantics as [Uint8Array.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice) in that it creates a new `Uint8Array` and copies bytes into it using an optional offset & length.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.slice(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ### subarray\n *\n * Subarray attempts to follow the same semantics as [Uint8Array.subarray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray) with one important different - this is a no-copy operation, unless the requested bytes span two internal buffers in which case it is a copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0]) - no-copy\n *\n * list.subarray(2, 5)\n * // -> Uint8Array([2, 3, 4]) - copy\n * ```\n *\n * ### sublist\n *\n * Sublist creates and returns a new `Uint8ArrayList` that shares the underlying buffers with the original so is always a no-copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.sublist(0, 1)\n * // -> Uint8ArrayList([0]) - no-copy\n *\n * list.sublist(2, 5)\n * // -> Uint8ArrayList([2], [3, 4]) - no-copy\n * ```\n *\n * ## Inspiration\n *\n * Borrows liberally from [bl](https://www.npmjs.com/package/bl) but only uses native JS types.\n */\nimport { allocUnsafe, alloc } from 'uint8arrays/alloc'\nimport { concat } from 'uint8arrays/concat'\nimport { equals } from 'uint8arrays/equals'\n\nconst symbol = Symbol.for('@achingbrain/uint8arraylist')\n\nexport type Appendable = Uint8ArrayList | Uint8Array\n\nfunction findBufAndOffset (bufs: Uint8Array[], index: number): { buf: Uint8Array, index: number } {\n  if (index == null || index < 0) {\n    throw new RangeError('index is out of bounds')\n  }\n\n  let offset = 0\n\n  for (const buf of bufs) {\n    const bufEnd = offset + buf.byteLength\n\n    if (index < bufEnd) {\n      return {\n        buf,\n        index: index - offset\n      }\n    }\n\n    offset = bufEnd\n  }\n\n  throw new RangeError('index is out of bounds')\n}\n\n/**\n * Check if object is a CID instance\n *\n * @example\n *\n * ```js\n * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\n *\n * isUint8ArrayList(true) // false\n * isUint8ArrayList([]) // false\n * isUint8ArrayList(new Uint8ArrayList()) // true\n * ```\n */\nexport function isUint8ArrayList (value: any): value is Uint8ArrayList {\n  return Boolean(value?.[symbol])\n}\n\nexport class Uint8ArrayList implements Iterable<Uint8Array> {\n  private bufs: Uint8Array[]\n  public length: number\n  public readonly [symbol] = true\n\n  constructor (...data: Appendable[]) {\n    this.bufs = []\n    this.length = 0\n\n    if (data.length > 0) {\n      this.appendAll(data)\n    }\n  }\n\n  * [Symbol.iterator] (): Iterator<Uint8Array> {\n    yield * this.bufs\n  }\n\n  get byteLength (): number {\n    return this.length\n  }\n\n  /**\n   * Add one or more `bufs` to the end of this Uint8ArrayList\n   */\n  append (...bufs: Appendable[]): void {\n    this.appendAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the end of this Uint8ArrayList\n   */\n  appendAll (bufs: Appendable[]): void {\n    let length = 0\n\n    for (const buf of bufs) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.push(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.push(...buf.bufs)\n      } else {\n        throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Add one or more `bufs` to the start of this Uint8ArrayList\n   */\n  prepend (...bufs: Appendable[]): void {\n    this.prependAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the start of this Uint8ArrayList\n   */\n  prependAll (bufs: Appendable[]): void {\n    let length = 0\n\n    for (const buf of bufs.reverse()) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.unshift(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.unshift(...buf.bufs)\n      } else {\n        throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Read the value at `index`\n   */\n  get (index: number): number {\n    const res = findBufAndOffset(this.bufs, index)\n\n    return res.buf[res.index]\n  }\n\n  /**\n   * Set the value at `index` to `value`\n   */\n  set (index: number, value: number): void {\n    const res = findBufAndOffset(this.bufs, index)\n\n    res.buf[res.index] = value\n  }\n\n  /**\n   * Copy bytes from `buf` to the index specified by `offset`\n   */\n  write (buf: Appendable, offset: number = 0): void {\n    if (buf instanceof Uint8Array) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf[i])\n      }\n    } else if (isUint8ArrayList(buf)) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf.get(i))\n      }\n    } else {\n      throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList')\n    }\n  }\n\n  /**\n   * Remove bytes from the front of the pool\n   */\n  consume (bytes: number): void {\n    // first, normalize the argument, in accordance with how Buffer does it\n    bytes = Math.trunc(bytes)\n\n    // do nothing if not a positive number\n    if (Number.isNaN(bytes) || bytes <= 0) {\n      return\n    }\n\n    // if consuming all bytes, skip iterating\n    if (bytes === this.byteLength) {\n      this.bufs = []\n      this.length = 0\n      return\n    }\n\n    while (this.bufs.length > 0) {\n      if (bytes >= this.bufs[0].byteLength) {\n        bytes -= this.bufs[0].byteLength\n        this.length -= this.bufs[0].byteLength\n        this.bufs.shift()\n      } else {\n        this.bufs[0] = this.bufs[0].subarray(bytes)\n        this.length -= bytes\n        break\n      }\n    }\n  }\n\n  /**\n   * Extracts a section of an array and returns a new array.\n   *\n   * This is a copy operation as it is with Uint8Arrays and Arrays\n   * - note this is different to the behaviour of Node Buffers.\n   */\n  slice (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a alloc from the given start and end element index.\n   *\n   * In the best case where the data extracted comes from a single Uint8Array\n   * internally this is a no-copy operation otherwise it is a copy operation.\n   */\n  subarray (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    if (bufs.length === 1) {\n      return bufs[0]\n    }\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a allocList from the given start and end element index.\n   *\n   * This is a no-copy operation.\n   */\n  sublist (beginInclusive?: number, endExclusive?: number): Uint8ArrayList {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    const list = new Uint8ArrayList()\n    list.length = length\n    // don't loop, just set the bufs\n    list.bufs = [...bufs]\n\n    return list\n  }\n\n  private _subList (beginInclusive?: number, endExclusive?: number): { bufs: Uint8Array[], length: number } {\n    beginInclusive = beginInclusive ?? 0\n    endExclusive = endExclusive ?? this.length\n\n    if (beginInclusive < 0) {\n      beginInclusive = this.length + beginInclusive\n    }\n\n    if (endExclusive < 0) {\n      endExclusive = this.length + endExclusive\n    }\n\n    if (beginInclusive < 0 || endExclusive > this.length) {\n      throw new RangeError('index is out of bounds')\n    }\n\n    if (beginInclusive === endExclusive) {\n      return { bufs: [], length: 0 }\n    }\n\n    if (beginInclusive === 0 && endExclusive === this.length) {\n      return { bufs: this.bufs, length: this.length }\n    }\n\n    const bufs: Uint8Array[] = []\n    let offset = 0\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      const buf = this.bufs[i]\n      const bufStart = offset\n      const bufEnd = bufStart + buf.byteLength\n\n      // for next loop\n      offset = bufEnd\n\n      if (beginInclusive >= bufEnd) {\n        // start after this buf\n        continue\n      }\n\n      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd\n      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd\n\n      if (sliceStartInBuf && sliceEndsInBuf) {\n        // slice is wholly contained within this buffer\n        if (beginInclusive === bufStart && endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        const start = beginInclusive - bufStart\n        bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)))\n        break\n      }\n\n      if (sliceStartInBuf) {\n        // slice starts in this buffer\n        if (beginInclusive === 0) {\n          // requested whole buffer\n          bufs.push(buf)\n          continue\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(beginInclusive - bufStart))\n        continue\n      }\n\n      if (sliceEndsInBuf) {\n        if (endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(0, endExclusive - bufStart))\n        break\n      }\n\n      // slice started before this buffer and ends after it\n      bufs.push(buf)\n    }\n\n    return { bufs, length: endExclusive - beginInclusive }\n  }\n\n  indexOf (search: Uint8ArrayList | Uint8Array, offset: number = 0): number {\n    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {\n      throw new TypeError('The \"value\" argument must be a Uint8ArrayList or Uint8Array')\n    }\n\n    const needle = search instanceof Uint8Array ? search : search.subarray()\n\n    offset = Number(offset ?? 0)\n\n    if (isNaN(offset)) {\n      offset = 0\n    }\n\n    if (offset < 0) {\n      offset = this.length + offset\n    }\n\n    if (offset < 0) {\n      offset = 0\n    }\n\n    if (search.length === 0) {\n      return offset > this.length ? this.length : offset\n    }\n\n    // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\n    const M: number = needle.byteLength\n\n    if (M === 0) {\n      throw new TypeError('search must be at least 1 byte long')\n    }\n\n    // radix\n    const radix: number = 256\n    const rightmostPositions: Int32Array = new Int32Array(radix)\n\n    // position of the rightmost occurrence of the byte c in the pattern\n    for (let c: number = 0; c < radix; c++) {\n      // -1 for bytes not in pattern\n      rightmostPositions[c] = -1\n    }\n\n    for (let j = 0; j < M; j++) {\n      // rightmost position for bytes in pattern\n      rightmostPositions[needle[j]] = j\n    }\n\n    // Return offset of first match, -1 if no match\n    const right = rightmostPositions\n    const lastIndex = this.byteLength - needle.byteLength\n    const lastPatIndex = needle.byteLength - 1\n    let skip: number\n\n    for (let i = offset; i <= lastIndex; i += skip) {\n      skip = 0\n\n      for (let j = lastPatIndex; j >= 0; j--) {\n        const char: number = this.get(i + j)\n\n        if (needle[j] !== char) {\n          skip = Math.max(1, j - right[char])\n          break\n        }\n      }\n\n      if (skip === 0) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  getInt8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt8(0)\n  }\n\n  setInt8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt16(0, littleEndian)\n  }\n\n  setInt16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt32(0, littleEndian)\n  }\n\n  setInt32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigInt64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigInt64(0, littleEndian)\n  }\n\n  setBigInt64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigInt64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint8(0)\n  }\n\n  setUint8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint16(0, littleEndian)\n  }\n\n  setUint16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint32(0, littleEndian)\n  }\n\n  setUint32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigUint64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigUint64(0, littleEndian)\n  }\n\n  setBigUint64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigUint64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat32(0, littleEndian)\n  }\n\n  setFloat32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat64 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat64(0, littleEndian)\n  }\n\n  setFloat64 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  equals (other: any): other is Uint8ArrayList {\n    if (other == null) {\n      return false\n    }\n\n    if (!(other instanceof Uint8ArrayList)) {\n      return false\n    }\n\n    if (other.bufs.length !== this.bufs.length) {\n      return false\n    }\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      if (!equals(this.bufs[i], other.bufs[i])) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this\n   * method if you know the total size of all the Uint8Arrays ahead of time.\n   */\n  static fromUint8Arrays (bufs: Uint8Array[], length?: number): Uint8ArrayList {\n    const list = new Uint8ArrayList()\n    list.bufs = bufs\n\n    if (length == null) {\n      length = bufs.reduce((acc, curr) => acc + curr.byteLength, 0)\n    }\n\n    list.length = length\n\n    return list\n  }\n}\n\n/*\nfunction indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {\n  for (let i = offset; i < haystack.byteLength; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.byteLength -1) {\n        return i\n      }\n    }\n\n    if (haystack.byteLength - i < needle.byteLength) {\n      break\n    }\n  }\n\n  return -1\n}\n*/\n", "export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n", "// ported from https://www.npmjs.com/package/fast-fifo\n\nexport interface Next<T> {\n  done?: boolean\n  error?: Error\n  value?: T\n}\n\nclass FixedFIFO<T> {\n  public buffer: Array<Next<T> | undefined>\n  private readonly mask: number\n  private top: number\n  private btm: number\n  public next: FixedFIFO<T> | null\n\n  constructor (hwm: number) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) {\n      throw new Error('Max size for a FixedFIFO should be a power of two')\n    }\n\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  push (data: Next<T>): boolean {\n    if (this.buffer[this.top] !== undefined) {\n      return false\n    }\n\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n\n    return true\n  }\n\n  shift (): Next<T> | undefined {\n    const last = this.buffer[this.btm]\n\n    if (last === undefined) {\n      return undefined\n    }\n\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  isEmpty (): boolean {\n    return this.buffer[this.btm] === undefined\n  }\n}\n\nexport interface FIFOOptions {\n  /**\n   * When the queue reaches this size, it will be split into head/tail parts\n   */\n  splitLimit?: number\n}\n\nexport class FIFO<T> {\n  public size: number\n  private readonly hwm: number\n  private head: FixedFIFO<T>\n  private tail: FixedFIFO<T>\n\n  constructor (options: FIFOOptions = {}) {\n    this.hwm = options.splitLimit ?? 16\n    this.head = new FixedFIFO<T>(this.hwm)\n    this.tail = this.head\n    this.size = 0\n  }\n\n  calculateSize (obj: any): number {\n    if (obj?.byteLength != null) {\n      return obj.byteLength\n    }\n\n    return 1\n  }\n\n  push (val: Next<T>): void {\n    if (val?.value != null) {\n      this.size += this.calculateSize(val.value)\n    }\n\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO<T>(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift (): Next<T> | undefined {\n    let val = this.tail.shift()\n\n    if (val === undefined && (this.tail.next != null)) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      val = this.tail.shift()\n    }\n\n    if (val?.value != null) {\n      this.size -= this.calculateSize(val.value)\n    }\n\n    return val\n  }\n\n  isEmpty (): boolean {\n    return this.head.isEmpty()\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\n\nimport deferred from 'p-defer'\nimport { FIFO, type Next } from './fifo.js'\n\nexport class AbortError extends Error {\n  type: string\n  code: string\n\n  constructor (message?: string, code?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\ninterface BasePushable<T> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end(err?: Error): this\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push(value: T): this\n\n  /**\n   * Returns a promise that resolves when the underlying queue becomes empty (e.g.\n   * this.readableLength === 0).\n   *\n   * If an AbortSignal is passed as an option and that signal aborts, it only\n   * causes the returned promise to reject - it does not end the pushable.\n   */\n  onEmpty(options?: AbortOptions): Promise<void>\n\n  /**\n   * This property contains the number of bytes (or objects) in the queue ready to be read.\n   *\n   * If `objectMode` is true, this is the number of objects in the queue, if false it's the\n   * total number of bytes in the queue.\n   */\n  readableLength: number\n}\n\n/**\n * An iterable that you can push values into.\n */\nexport interface Pushable<T, R = void, N = unknown> extends AsyncGenerator<T, R, N>, BasePushable<T> {}\n\n/**\n * Similar to `pushable`, except it yields multiple buffered chunks at a time. All values yielded from the iterable will be arrays.\n */\nexport interface PushableV<T, R = void, N = unknown> extends AsyncGenerator<T[], R, N>, BasePushable<T> {}\n\nexport interface Options {\n  /**\n   * A boolean value that means non-`Uint8Array`s will be passed to `.push`, default: `false`\n   */\n  objectMode?: boolean\n\n  /**\n   * A function called after *all* values have been yielded from the iterator (including\n   * buffered values). In the case when the iterator is ended with an error it will be\n   * passed the error as a parameter.\n   */\n  onEnd?(err?: Error): void\n}\n\nexport interface DoneResult { done: true }\nexport interface ValueResult<T> { done: false, value: T }\nexport type NextResult<T> = ValueResult<T> | DoneResult\n\ninterface getNext<T, V = T> { (buffer: FIFO<T>): NextResult<V> }\n\nexport interface ObjectPushableOptions extends Options {\n  objectMode: true\n}\n\nexport interface BytePushableOptions extends Options {\n  objectMode?: false\n}\n\n/**\n * Create a new async iterable. The values yielded from calls to `.next()`\n * or when used in a `for await of`loop are \"pushed\" into the iterable.\n * Returns an async iterable object with additional methods.\n */\nexport function pushable<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): Pushable<T>\nexport function pushable<T> (options: ObjectPushableOptions): Pushable<T>\nexport function pushable<T> (options: Options = {}): Pushable<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T> => {\n    const next: Next<T> | undefined = buffer.shift()\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    if (next.error != null) {\n      throw next.error\n    }\n\n    return {\n      done: next.done === true,\n      // @ts-expect-error if done is false, value will be present\n      value: next.value\n    }\n  }\n\n  return _pushable<T, T, Pushable<T>>(getNext, options)\n}\n\nexport function pushableV<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): PushableV<T>\nexport function pushableV<T> (options: ObjectPushableOptions): PushableV<T>\nexport function pushableV<T> (options: Options = {}): PushableV<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T[]> => {\n    let next: Next<T> | undefined\n    const values: T[] = []\n\n    while (!buffer.isEmpty()) {\n      next = buffer.shift()\n\n      if (next == null) {\n        break\n      }\n\n      if (next.error != null) {\n        throw next.error\n      }\n\n      if (next.done === false) {\n        // @ts-expect-error if done is false value should be pushed\n        values.push(next.value)\n      }\n    }\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    return {\n      done: next.done === true,\n      value: values\n    }\n  }\n\n  return _pushable<T, T[], PushableV<T>>(getNext, options)\n}\n\nfunction _pushable<PushType, ValueType, ReturnType> (getNext: getNext<PushType, ValueType>, options?: Options): ReturnType {\n  options = options ?? {}\n  let onEnd = options.onEnd\n  let buffer = new FIFO<PushType>()\n  let pushable: any\n  let onNext: ((next: Next<PushType>) => ReturnType) | null\n  let ended: boolean\n  let drain = deferred()\n\n  const waitNext = async (): Promise<NextResult<ValueType>> => {\n    try {\n      if (!buffer.isEmpty()) {\n        return getNext(buffer)\n      }\n\n      if (ended) {\n        return { done: true }\n      }\n\n      return await new Promise<NextResult<ValueType>>((resolve, reject) => {\n        onNext = (next: Next<PushType>) => {\n          onNext = null\n          buffer.push(next)\n\n          try {\n            resolve(getNext(buffer))\n          } catch (err) {\n            reject(err)\n          }\n\n          return pushable\n        }\n      })\n    } finally {\n      if (buffer.isEmpty()) {\n        // settle promise in the microtask queue to give consumers a chance to\n        // await after calling .push\n        queueMicrotask(() => {\n          drain.resolve()\n          drain = deferred()\n        })\n      }\n    }\n  }\n\n  const bufferNext = (next: Next<PushType>): ReturnType => {\n    if (onNext != null) {\n      return onNext(next)\n    }\n\n    buffer.push(next)\n    return pushable\n  }\n\n  const bufferError = (err: Error): ReturnType => {\n    buffer = new FIFO()\n\n    if (onNext != null) {\n      return onNext({ error: err })\n    }\n\n    buffer.push({ error: err })\n    return pushable\n  }\n\n  const push = (value: PushType): ReturnType => {\n    if (ended) {\n      return pushable\n    }\n\n    // @ts-expect-error `byteLength` is not declared on PushType\n    if (options?.objectMode !== true && value?.byteLength == null) {\n      throw new Error('objectMode was not true but tried to push non-Uint8Array value')\n    }\n\n    return bufferNext({ done: false, value })\n  }\n  const end = (err?: Error): ReturnType => {\n    if (ended) return pushable\n    ended = true\n\n    return (err != null) ? bufferError(err) : bufferNext({ done: true })\n  }\n  const _return = (): DoneResult => {\n    buffer = new FIFO()\n    end()\n\n    return { done: true }\n  }\n  const _throw = (err: Error): DoneResult => {\n    end(err)\n\n    return { done: true }\n  }\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next: waitNext,\n    return: _return,\n    throw: _throw,\n    push,\n    end,\n    get readableLength (): number {\n      return buffer.size\n    },\n    onEmpty: async (options?: AbortOptions) => {\n      const signal = options?.signal\n      signal?.throwIfAborted()\n\n      if (buffer.isEmpty()) {\n        return\n      }\n\n      let cancel: Promise<void> | undefined\n      let listener: (() => void) | undefined\n\n      if (signal != null) {\n        cancel = new Promise((resolve, reject) => {\n          listener = () => {\n            reject(new AbortError())\n          }\n\n          signal.addEventListener('abort', listener)\n        })\n      }\n\n      try {\n        await Promise.race([\n          drain.promise,\n          cancel\n        ])\n      } finally {\n        if (listener != null && signal != null) {\n          signal?.removeEventListener('abort', listener)\n        }\n      }\n    }\n  }\n\n  if (onEnd == null) {\n    return pushable\n  }\n\n  const _pushable = pushable\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next () {\n      return _pushable.next()\n    },\n    throw (err: Error) {\n      _pushable.throw(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    return () {\n      _pushable.return()\n\n      if (onEnd != null) {\n        onEnd()\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    push,\n    end (err: Error) {\n      _pushable.end(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return pushable\n    },\n    get readableLength () {\n      return _pushable.readableLength\n    },\n    onEmpty: (opts?: AbortOptions) => {\n      return _pushable.onEmpty(opts)\n    }\n  }\n\n  return pushable\n}\n", "import type { Startable } from '@libp2p/interface'\n\nexport interface DebouncedFunction extends Startable {\n  (): void\n}\n\n/**\n * Returns a function wrapper that will only call the passed function once\n *\n * Important - the passed function should not throw or reject\n */\nexport function debounce (func: () => void | Promise<void>, wait: number): DebouncedFunction {\n  let timeout: ReturnType<typeof setTimeout> | undefined\n\n  const output = function (): void {\n    const later = function (): void {\n      timeout = undefined\n      void func()\n    }\n\n    clearTimeout(timeout)\n    timeout = setTimeout(later, wait)\n  }\n  output.start = (): void => {}\n  output.stop = (): void => {\n    clearTimeout(timeout)\n  }\n\n  return output\n}\n", "import type { RateLimiterResult } from './rate-limiter.js'\n\n/**\n * A rate limit was hit\n */\nexport class RateLimitError extends Error {\n  remainingPoints: number\n  msBeforeNext: number\n  consumedPoints: number\n  isFirstInDuration: boolean\n\n  constructor (message = 'Rate limit exceeded', props: RateLimiterResult) {\n    super(message)\n    this.name = 'RateLimitError'\n    this.remainingPoints = props.remainingPoints\n    this.msBeforeNext = props.msBeforeNext\n    this.consumedPoints = props.consumedPoints\n    this.isFirstInDuration = props.isFirstInDuration\n  }\n}\n\nexport class QueueFullError extends Error {\n  static name = 'QueueFullError'\n\n  constructor (message: string = 'The queue was full') {\n    super(message)\n    this.name = 'QueueFullError'\n  }\n}\n\nexport class UnexpectedEOFError extends Error {\n  static name = 'UnexpectedEOFError'\n  name = 'UnexpectedEOFError'\n}\n\nexport class MaxEarlyStreamsError extends Error {\n  static name = 'MaxEarlyStreamsError'\n  name = 'MaxEarlyStreamsError'\n}\n\nexport class StreamClosedError extends Error {\n  static name = 'StreamClosedError'\n  name = 'StreamClosedError'\n}\n", "/**\n * @packageDocumentation\n *\n * Pass a promise and an abort signal and await the result.\n *\n * @example Basic usage\n *\n * ```ts\n * import { raceSignal } from 'race-signal'\n *\n * const controller = new AbortController()\n *\n * const promise = new Promise((resolve, reject) => {\n *   setTimeout(() => {\n *     resolve('a value')\n *   }, 1000)\n * })\n *\n * setTimeout(() => {\n *   controller.abort()\n * }, 500)\n *\n * // throws an AbortError\n * const resolve = await raceSignal(promise, controller.signal)\n * ```\n *\n * @example Overriding errors\n *\n * By default the thrown error is the `.reason` property of the signal but it's\n * possible to override this behaviour with the `translateError` option:\n *\n * ```ts\n * import { raceSignal } from 'race-signal'\n *\n * const controller = new AbortController()\n *\n * const promise = new Promise((resolve, reject) => {\n *   setTimeout(() => {\n *     resolve('a value')\n *   }, 1000)\n * })\n *\n * setTimeout(() => {\n *   controller.abort()\n * }, 500)\n *\n * // throws `Error('Oh no!')`\n * const resolve = await raceSignal(promise, controller.signal, {\n *   translateError: (signal) => {\n *     // use `signal`, or don't\n *     return new Error('Oh no!')\n *   }\n * })\n * ```\n */\n\nexport interface RaceSignalOptions {\n  /**\n   * By default the rejection reason will be taken from the `.reason` field of\n   * the aborted signal.\n   *\n   * Passing a function here allows overriding the default error.\n   */\n  translateError?(signal: AbortSignal): Error\n}\n\nfunction defaultTranslate (signal: AbortSignal): Error {\n  return signal.reason\n}\n\n/**\n * Race a promise against an abort signal\n */\nexport async function raceSignal <T> (promise: Promise<T>, signal?: AbortSignal, opts?: RaceSignalOptions): Promise<T> {\n  if (signal == null) {\n    return promise\n  }\n\n  const translateError = opts?.translateError ?? defaultTranslate\n\n  if (signal.aborted) {\n    // the passed promise may yet resolve or reject but the use has signalled\n    // they are no longer interested so smother the error\n    promise.catch(() => {})\n    return Promise.reject(translateError(signal))\n  }\n\n  let listener\n\n  try {\n    return await Promise.race([\n      promise,\n      new Promise<T>((resolve, reject) => {\n        listener = () => {\n          reject(translateError(signal))\n        }\n        signal.addEventListener('abort', listener)\n      })\n    ])\n  } finally {\n    if (listener != null) {\n      signal.removeEventListener('abort', listener)\n    }\n  }\n}\n", "import { StreamResetError, TypedEventEmitter, StreamMessageEvent, StreamBufferError, StreamResetEvent, StreamAbortEvent, StreamCloseEvent, StreamStateError } from '@libp2p/interface'\nimport { pushable } from 'it-pushable'\nimport { raceSignal } from 'race-signal'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { StreamClosedError } from './errors.ts'\nimport type { MessageStreamEvents, MessageStreamStatus, MessageStream, AbortOptions, MessageStreamTimeline, MessageStreamDirection, EventHandler, StreamOptions, MessageStreamReadStatus, MessageStreamWriteStatus } from '@libp2p/interface'\nimport type { Logger } from '@libp2p/logger'\n\nconst DEFAULT_MAX_READ_BUFFER_LENGTH = Math.pow(2, 20) * 4 // 4MB\n\nexport interface MessageStreamInit extends StreamOptions {\n  /**\n   * A Logger implementation used to log stream-specific information\n   */\n  log: Logger\n\n  /**\n   * The stream direction\n   */\n  direction?: MessageStreamDirection\n\n  /**\n   * By default all available bytes are passed to the `sendData` method of\n   * extending classes, if smaller chunks are required, pass a value here.\n   */\n  maxMessageSize?: number\n}\n\nexport interface SendResult {\n  /**\n   * The number of bytes from the passed buffer that were sent\n   */\n  sentBytes: number\n\n  /**\n   * If the underlying resource can accept more data immediately. If `true`,\n   * `sent` must equal the `.byteLength` of the buffer passed to `sendData`.\n   */\n  canSendMore: boolean\n}\n\nexport abstract class AbstractMessageStream<Timeline extends MessageStreamTimeline = MessageStreamTimeline> extends TypedEventEmitter<MessageStreamEvents> implements MessageStream {\n  public status: MessageStreamStatus\n  public readonly timeline: Timeline\n  public inactivityTimeout: number\n  public maxReadBufferLength: number\n  public maxWriteBufferLength?: number\n  public readonly log: Logger\n  public direction: MessageStreamDirection\n  public maxMessageSize?: number\n\n  public readStatus: MessageStreamReadStatus\n  public writeStatus: MessageStreamWriteStatus\n  public remoteReadStatus: MessageStreamReadStatus\n  public remoteWriteStatus: MessageStreamWriteStatus\n\n  public writableNeedsDrain: boolean\n\n  /**\n   * Any data stored here is emitted before any new incoming data.\n   *\n   * This is used when the stream is paused or if data is pushed onto the stream\n   */\n  protected readonly readBuffer: Uint8ArrayList\n  protected readonly writeBuffer: Uint8ArrayList\n  protected sendingData: boolean\n\n  private onDrainPromise?: PromiseWithResolvers<void>\n\n  constructor (init: MessageStreamInit) {\n    super()\n\n    this.status = 'open'\n    this.log = init.log\n    this.direction = init.direction ?? 'outbound'\n    this.inactivityTimeout = init.inactivityTimeout ?? 120_000\n    this.maxReadBufferLength = init.maxReadBufferLength ?? DEFAULT_MAX_READ_BUFFER_LENGTH\n    this.maxWriteBufferLength = init.maxWriteBufferLength\n    this.maxMessageSize = init.maxMessageSize\n    this.readBuffer = new Uint8ArrayList()\n    this.writeBuffer = new Uint8ArrayList()\n\n    this.readStatus = 'readable'\n    this.remoteReadStatus = 'readable'\n    this.writeStatus = 'writable'\n    this.remoteWriteStatus = 'writable'\n    this.sendingData = false\n    this.writableNeedsDrain = false\n\n    // @ts-expect-error type could have required fields other than 'open'\n    this.timeline = {\n      open: Date.now()\n    }\n\n    this.processSendQueue = this.processSendQueue.bind(this)\n\n    const continueSendingOnDrain = (): void => {\n      if (this.writableNeedsDrain) {\n        this.log.trace('drain event received, continue sending data')\n        this.writableNeedsDrain = false\n        this.processSendQueue()\n      }\n\n      this.onDrainPromise?.resolve()\n    }\n    this.addEventListener('drain', continueSendingOnDrain)\n\n    const rejectOnDrainOnClose = (evt: StreamCloseEvent): void => {\n      this.onDrainPromise?.reject(evt.error ?? new StreamClosedError())\n    }\n    this.addEventListener('close', rejectOnDrainOnClose)\n  }\n\n  get readBufferLength (): number {\n    return this.readBuffer.byteLength\n  }\n\n  get writeBufferLength (): number {\n    return this.writeBuffer.byteLength\n  }\n\n  async onDrain (options?: AbortOptions): Promise<void> {\n    if (this.writableNeedsDrain !== true) {\n      return Promise.resolve()\n    }\n\n    if (this.onDrainPromise == null) {\n      this.onDrainPromise = Promise.withResolvers()\n    }\n\n    return raceSignal(this.onDrainPromise.promise, options?.signal)\n  }\n\n  async * [Symbol.asyncIterator] (): AsyncGenerator<Uint8Array | Uint8ArrayList> {\n    if (this.readStatus !== 'readable' && this.readStatus !== 'paused') {\n      return\n    }\n\n    const output = pushable<Uint8Array | Uint8ArrayList>()\n\n    const streamAsyncIterableOnMessageListener = (evt: StreamMessageEvent): void => {\n      output.push(evt.data)\n    }\n    this.addEventListener('message', streamAsyncIterableOnMessageListener)\n\n    const streamAsyncIterableOnCloseListener = (evt: StreamCloseEvent): void => {\n      output.end(evt.error)\n    }\n    this.addEventListener('close', streamAsyncIterableOnCloseListener)\n\n    const streamAsyncIterableOnRemoteCloseWriteListener = (): void => {\n      output.end()\n    }\n    this.addEventListener('remoteCloseWrite', streamAsyncIterableOnRemoteCloseWriteListener)\n\n    try {\n      yield * output\n    } finally {\n      this.removeEventListener('message', streamAsyncIterableOnMessageListener)\n      this.removeEventListener('close', streamAsyncIterableOnCloseListener)\n      this.removeEventListener('remoteCloseWrite', streamAsyncIterableOnRemoteCloseWriteListener)\n    }\n  }\n\n  isReadable (): boolean {\n    return this.status === 'open'\n  }\n\n  send (data: Uint8Array | Uint8ArrayList): boolean {\n    if (this.writeStatus === 'closed' || this.writeStatus === 'closing') {\n      throw new StreamStateError(`Cannot write to a stream that is ${this.writeStatus}`)\n    }\n\n    this.log.trace('append %d bytes to write buffer', data.byteLength)\n    this.writeBuffer.append(data)\n\n    return this.processSendQueue()\n  }\n\n  /**\n   * Close immediately for reading and writing and send a reset message (local\n   * error)\n   */\n  abort (err: Error): void {\n    if (this.status === 'aborted' || this.status === 'reset' || this.status === 'closed') {\n      return\n    }\n\n    this.log.error('abort with error - %e', err)\n\n    this.status = 'aborted'\n\n    // throw away unread data\n    if (this.readBuffer.byteLength > 0) {\n      this.readBuffer.consume(this.readBuffer.byteLength)\n    }\n\n    // throw away unsent data\n    if (this.writeBuffer.byteLength > 0) {\n      this.writeBuffer.consume(this.writeBuffer.byteLength)\n      this.safeDispatchEvent('idle')\n    }\n\n    this.writeStatus = 'closed'\n    this.remoteWriteStatus = 'closed'\n\n    this.readStatus = 'closed'\n    this.remoteReadStatus = 'closed'\n    this.timeline.close = Date.now()\n\n    try {\n      this.sendReset(err)\n    } catch (err: any) {\n      this.log('failed to send reset to remote - %e', err)\n    }\n\n    this.dispatchEvent(new StreamAbortEvent(err))\n  }\n\n  pause (): void {\n    if (this.readStatus === 'closed' || this.readStatus === 'closing') {\n      throw new StreamStateError('Cannot pause a stream that is closing/closed')\n    }\n\n    if (this.readStatus === 'paused') {\n      return\n    }\n\n    this.readStatus = 'paused'\n    this.sendPause()\n  }\n\n  resume (): void {\n    if (this.readStatus === 'closed' || this.readStatus === 'closing') {\n      throw new StreamStateError('Cannot resume a stream that is closing/closed')\n    }\n\n    if (this.readStatus === 'readable') {\n      return\n    }\n\n    this.readStatus = 'readable'\n    // emit any data that accumulated while we were paused\n    this.dispatchReadBuffer()\n    this.sendResume()\n  }\n\n  push (data: Uint8Array | Uint8ArrayList): void {\n    if (this.readStatus === 'closed' || this.readStatus === 'closing') {\n      throw new StreamStateError(`Cannot push data onto a stream that is ${this.readStatus}`)\n    }\n\n    if (data.byteLength === 0) {\n      return\n    }\n\n    this.readBuffer.append(data)\n\n    if (this.readStatus === 'paused' || this.listenerCount('message') === 0) {\n      // abort if the read buffer is too large\n      this.checkReadBufferLength()\n\n      return\n    }\n\n    // TODO: use a microtask instead?\n    setTimeout(() => {\n      this.dispatchReadBuffer()\n    }, 0)\n  }\n\n  unshift (data: Uint8Array | Uint8ArrayList): void {\n    if (this.readStatus === 'closed' || this.readStatus === 'closing') {\n      throw new StreamStateError(`Cannot push data onto a stream that is ${this.readStatus}`)\n    }\n\n    if (data.byteLength === 0) {\n      return\n    }\n\n    this.readBuffer.prepend(data)\n\n    if (this.readStatus === 'paused' || this.listenerCount('message') === 0) {\n      // abort if the read buffer is too large\n      this.checkReadBufferLength()\n\n      return\n    }\n\n    // TODO: use a microtask instead?\n    setTimeout(() => {\n      this.dispatchReadBuffer()\n    }, 0)\n  }\n\n  /**\n   * When an extending class reads data from it's implementation-specific source,\n   * call this method to allow the stream consumer to read the data.\n   */\n  onData (data: Uint8Array | Uint8ArrayList): void {\n    if (data.byteLength === 0) {\n      // this.log('ignoring empty data')\n      return\n    }\n\n    // discard the data if our readable end is closed\n    if (this.readStatus === 'closing' || this.readStatus === 'closed') {\n      this.log('ignoring data - read status %s', this.readStatus)\n      return\n    }\n\n    this.readBuffer.append(data)\n    this.dispatchReadBuffer()\n  }\n\n  addEventListener<K extends keyof MessageStreamEvents>(type: K, listener: EventHandler<MessageStreamEvents[K]> | null, options?: boolean | AddEventListenerOptions): void\n  addEventListener (type: string, listener: EventHandler<Event>, options?: boolean | AddEventListenerOptions): void\n  addEventListener (...args: any[]): void {\n    // @ts-expect-error cannot ensure args has enough members\n    super.addEventListener.apply(this, args)\n\n    // if a 'message' listener is being added and we have queued data, dispatch\n    // the data\n    if (args[0] === 'message' && this.readBuffer.byteLength > 0) {\n      // event listeners can be added in constructors and often use object\n      // properties - if this the case we can access a class member before it\n      // has been initialized so dispatch the message in the microtask queue\n      queueMicrotask(() => {\n        this.dispatchReadBuffer()\n      })\n    }\n  }\n\n  /**\n   * Receive a reset message - close immediately for reading and writing (remote\n   * error)\n   */\n  onRemoteReset (): void {\n    this.log('remote reset')\n\n    this.status = 'reset'\n    this.writeStatus = 'closed'\n    this.remoteWriteStatus = 'closed'\n    this.remoteReadStatus = 'closed'\n    this.timeline.close = Date.now()\n\n    if (this.readBuffer.byteLength === 0) {\n      this.readStatus = 'closed'\n    }\n\n    const err = new StreamResetError()\n    this.dispatchEvent(new StreamResetEvent(err))\n  }\n\n  /**\n   * The underlying resource or transport this stream uses has closed - it is\n   * not possible to send any more messages though any data still in the read\n   * buffer may still be read\n   */\n  onTransportClosed (err?: Error): void {\n    this.log('transport closed')\n\n    if (this.readStatus === 'readable' && this.readBuffer.byteLength === 0) {\n      this.log('close readable end after transport closed and read buffer is empty')\n      this.readStatus = 'closed'\n    }\n\n    if (this.remoteReadStatus !== 'closed') {\n      this.remoteReadStatus = 'closed'\n    }\n\n    if (this.remoteWriteStatus !== 'closed') {\n      this.remoteWriteStatus = 'closed'\n    }\n\n    if (this.writeStatus !== 'closed') {\n      this.writeStatus = 'closed'\n    }\n\n    if (err != null) {\n      this.abort(err)\n    } else {\n      if (this.status === 'open' || this.status === 'closing') {\n        this.timeline.close = Date.now()\n        this.status = 'closed'\n        this.writeStatus = 'closed'\n        this.remoteWriteStatus = 'closed'\n        this.remoteReadStatus = 'closed'\n        this.dispatchEvent(new StreamCloseEvent())\n      }\n    }\n  }\n\n  /**\n   * Called by extending classes when the remote closes its writable end\n   */\n  onRemoteCloseWrite (): void {\n    if (this.remoteWriteStatus === 'closed') {\n      return\n    }\n\n    this.log.trace('on remote close write')\n\n    this.remoteWriteStatus = 'closed'\n\n    this.safeDispatchEvent('remoteCloseWrite')\n\n    if (this.writeStatus === 'closed') {\n      this.onTransportClosed()\n    }\n  }\n\n  /**\n   * Called by extending classes when the remote closes its readable end\n   */\n  onRemoteCloseRead (): void {\n    this.log.trace('on remote close read')\n\n    this.remoteReadStatus = 'closed'\n\n    // throw away any unsent bytes if the remote closes it's readable end\n    if (this.writeBuffer.byteLength > 0) {\n      this.writeBuffer.consume(this.writeBuffer.byteLength)\n      this.safeDispatchEvent('idle')\n    }\n  }\n\n  protected processSendQueue (): boolean {\n    // bail if the underlying transport is full\n    if (this.writableNeedsDrain) {\n      this.log.trace('not processing send queue as drain is required')\n      this.checkWriteBufferLength()\n\n      return false\n    }\n\n    // bail if there is no data to send\n    if (this.writeBuffer.byteLength === 0) {\n      this.log.trace('not processing send queue as no bytes to send')\n      return true\n    }\n\n    // bail if we are already sending data\n    if (this.sendingData) {\n      this.log.trace('not processing send queue as already sending data')\n      return true\n    }\n\n    this.sendingData = true\n\n    this.log.trace('processing send queue with %d queued bytes', this.writeBuffer.byteLength)\n\n    try {\n      let canSendMore = true\n      const totalBytes = this.writeBuffer.byteLength\n      let sentBytes = 0\n\n      // send as much data as possible while we have data to send and the\n      // underlying muxer can still accept data\n      while (this.writeBuffer.byteLength > 0) {\n        const end = Math.min(this.maxMessageSize ?? this.writeBuffer.byteLength, this.writeBuffer.byteLength)\n\n        // this can happen if a subclass changes the max message size dynamically\n        if (end === 0) {\n          canSendMore = false\n          break\n        }\n\n        // chunk to send to the remote end\n        const toSend = this.writeBuffer.sublist(0, end)\n\n        // copy toSend in case the extending class modifies the list\n        const willSend = new Uint8ArrayList(toSend)\n\n        this.writeBuffer.consume(toSend.byteLength)\n\n        // sending data can cause buffers to fill up, events to be emitted and\n        // this method to be invoked again\n        const sendResult = this.sendData(toSend)\n        canSendMore = sendResult.canSendMore\n        sentBytes += sendResult.sentBytes\n\n        if (sendResult.sentBytes !== willSend.byteLength) {\n          willSend.consume(sendResult.sentBytes)\n          this.writeBuffer.prepend(willSend)\n        }\n\n        if (!canSendMore) {\n          break\n        }\n      }\n\n      if (!canSendMore) {\n        this.log.trace('sent %d/%d bytes, pausing sending because underlying stream is full, %d bytes left in the write buffer', sentBytes, totalBytes, this.writeBuffer.byteLength)\n        this.writableNeedsDrain = true\n        this.checkWriteBufferLength()\n      }\n\n      // we processed all bytes in the queue, resolve the write queue idle promise\n      if (this.writeBuffer.byteLength === 0) {\n        this.safeDispatchEvent('idle')\n      }\n\n      return canSendMore\n    } finally {\n      this.sendingData = false\n    }\n  }\n\n  protected dispatchReadBuffer (): void {\n    try {\n      if (this.listenerCount('message') === 0) {\n        this.log.trace('not dispatching pause buffer as there are no listeners for the message event')\n        return\n      }\n\n      if (this.readBuffer.byteLength === 0) {\n        this.log.trace('not dispatching pause buffer as there is no data to dispatch')\n        return\n      }\n\n      if (this.readStatus === 'paused') {\n        this.log.trace('not dispatching pause buffer we are paused')\n        return\n      }\n\n      // discard the pause buffer if our readable end is closed\n      if (this.readStatus === 'closing' || this.readStatus === 'closed') {\n        this.log('dropping %d bytes because the readable end is %s', this.readBuffer.byteLength, this.readStatus)\n        this.readBuffer.consume(this.readBuffer.byteLength)\n        return\n      }\n\n      const buf = this.readBuffer.sublist()\n      this.readBuffer.consume(buf.byteLength)\n\n      this.dispatchEvent(new StreamMessageEvent(buf))\n    } finally {\n      if (this.readBuffer.byteLength === 0 && this.remoteWriteStatus === 'closed') {\n        this.log('close readable end after dispatching read buffer and remote writable end is closed')\n        this.readStatus = 'closed'\n      }\n\n      // abort if we failed to consume the read buffer and it is too large\n      this.checkReadBufferLength()\n    }\n  }\n\n  private checkReadBufferLength (): void {\n    if (this.readBuffer.byteLength > this.maxReadBufferLength) {\n      this.abort(new StreamBufferError(`Read buffer length of ${this.readBuffer.byteLength} exceeded limit of ${this.maxReadBufferLength}, read status is ${this.readStatus}`))\n    }\n  }\n\n  private checkWriteBufferLength (): void {\n    if (this.maxWriteBufferLength == null) {\n      return\n    }\n\n    if (this.writeBuffer.byteLength > this.maxWriteBufferLength) {\n      this.abort(new StreamBufferError(`Write buffer length of ${this.writeBuffer.byteLength} exceeded limit of ${this.maxWriteBufferLength}, write status is ${this.writeStatus}`))\n    }\n  }\n\n  public onMuxerNeedsDrain (): void {\n    this.writableNeedsDrain = true\n  }\n\n  public onMuxerDrain (): void {\n    this.safeDispatchEvent('drain')\n  }\n\n  /**\n   * Send a data message to the remote end of the stream. Implementations of\n   * this method should return the number of bytes from the passed buffer that\n   * were sent successfully and if the underlying resource can accept more data.\n   *\n   * The implementation should always attempt to send the maximum amount of data\n   * possible.\n   *\n   * Returning a result that means the data was only partially sent but that the\n   * underlying resource can accept more data is invalid.\n   */\n  abstract sendData (data: Uint8ArrayList): SendResult\n\n  /**\n   * Send a reset message to the remote end of the stream\n   */\n  abstract sendReset (err: Error): void\n\n  /**\n   * If supported, instruct the remote end of the stream to temporarily stop\n   * sending data messages\n   */\n  abstract sendPause (): void\n\n  /**\n   * If supported, inform the remote end of the stream they may resume sending\n   * data messages\n   */\n  abstract sendResume (): void\n\n  /**\n   * Stop accepting new data to send and return a promise that resolves when any\n   * unsent data has been written into the underlying resource.\n   */\n  abstract close (options?: AbortOptions): Promise<void>\n}\n", "import { pEvent } from 'p-event'\nimport { AbstractMessageStream } from './abstract-message-stream.ts'\nimport type { MessageStreamInit } from './abstract-message-stream.ts'\nimport type { CounterGroup, Logger, MultiaddrConnection, MessageStreamDirection, AbortOptions } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface AbstractMultiaddrConnectionInit extends Omit<MessageStreamInit, 'log'> {\n  remoteAddr: Multiaddr\n  direction: MessageStreamDirection\n  log: Logger\n  inactivityTimeout?: number\n  localAddr?: Multiaddr\n  metricPrefix?: string\n  metrics?: CounterGroup\n}\n\nexport abstract class AbstractMultiaddrConnection extends AbstractMessageStream implements MultiaddrConnection {\n  public remoteAddr: Multiaddr\n\n  private metricPrefix: string\n  private metrics?: CounterGroup\n\n  constructor (init: AbstractMultiaddrConnectionInit) {\n    super(init)\n\n    this.metricPrefix = init.metricPrefix ?? ''\n    this.metrics = init.metrics\n    this.remoteAddr = init.remoteAddr\n\n    this.addEventListener('close', (evt) => {\n      this.metrics?.increment({ [`${this.metricPrefix}end`]: true })\n\n      if (evt.error != null) {\n        if (evt.local) {\n          this.metrics?.increment({ [`${this.metricPrefix}abort`]: true })\n        } else {\n          this.metrics?.increment({ [`${this.metricPrefix}reset`]: true })\n        }\n      } else {\n        if (evt.local) {\n          this.metrics?.increment({ [`${this.metricPrefix}_local_close`]: true })\n        } else {\n          this.metrics?.increment({ [`${this.metricPrefix}_remote_close`]: true })\n        }\n      }\n    })\n  }\n\n  async close (options?: AbortOptions): Promise<void> {\n    if (this.status !== 'open') {\n      return\n    }\n\n    this.status = 'closing'\n    this.writeStatus = 'closing'\n    this.remoteWriteStatus = 'closing'\n    this.remoteReadStatus = 'closing'\n\n    // if we are currently sending data, wait for all the data to be written\n    // into the underlying transport\n    if (this.sendingData || this.writeBuffer.byteLength > 0) {\n      this.log('waiting for write queue to become idle before closing writable end of stream, %d unsent bytes', this.writeBuffer.byteLength)\n      await pEvent(this, 'idle', {\n        ...options,\n        rejectionEvents: [\n          'close'\n        ]\n      })\n    }\n\n    // now that the underlying transport has all the data, if the buffer is full\n    // wait for it to be emptied\n    if (this.writableNeedsDrain) {\n      this.log('waiting for write queue to drain before closing writable end of stream, %d unsent bytes', this.writeBuffer.byteLength)\n      await pEvent(this, 'drain', {\n        ...options,\n        rejectionEvents: [\n          'close'\n        ]\n      })\n    }\n\n    await this.sendClose(options)\n\n    this.onTransportClosed()\n  }\n\n  /**\n   * Wait for any unsent data to be written to the underlying resource, then\n   * close the resource and resolve the returned promise\n   */\n  abstract sendClose (options?: AbortOptions): Promise<void>\n}\n", "\nexport interface ClearableSignal extends AbortSignal {\n  clear: () => void\n}\n\n/**\n * Takes an array of AbortSignals and returns a single signal.\n * If any signals are aborted, the returned signal will be aborted.\n */\nexport function anySignal (signals: Array<AbortSignal | undefined | null>): ClearableSignal {\n  const controller = new globalThis.AbortController()\n\n  function onAbort (): void {\n    controller.abort()\n\n    for (const signal of signals) {\n      if (signal?.removeEventListener != null) {\n        signal.removeEventListener('abort', onAbort)\n      }\n    }\n  }\n\n  for (const signal of signals) {\n    if (signal?.aborted === true) {\n      onAbort()\n      break\n    }\n\n    if (signal?.addEventListener != null) {\n      signal.addEventListener('abort', onAbort)\n    }\n  }\n\n  function clear (): void {\n    for (const signal of signals) {\n      if (signal?.removeEventListener != null) {\n        signal.removeEventListener('abort', onAbort)\n      }\n    }\n  }\n\n  const signal = controller.signal as ClearableSignal\n  signal.clear = clear\n\n  return signal\n}\n", "import { anySignal } from 'any-signal'\nimport { setMaxListeners } from 'main-event'\nimport { debounce } from './debounce.ts'\nimport type { AbortOptions } from '@libp2p/interface'\n\nexport interface RepeatingTask {\n  /**\n   * Update the interval after which the next iteration of the task will run.\n   *\n   * This is useful if, for example, you want to retry a task with a short rest\n   * duration until it succeeds, then periodically after that.\n   *\n   * This only affects the next iteration of the task, if it is currently\n   * running, that run will not be interrupted.\n   *\n   * Setting the interval to the current value has no effect.\n   */\n  setInterval(ms: number): void\n\n  /**\n   * Update the amount of time a task will run before the passed abort signal\n   * will fire.\n   *\n   * This only affects the next iteration of the task, if it is currently\n   * running, that run will not be interrupted.\n   */\n  setTimeout(ms: number): void\n\n  /**\n   * Schedule the task to be run immediately - if the task is not running it\n   * will run after a short delay in order to debounce multiple `.run()`\n   * invocations.\n   */\n  run(): void\n\n  /**\n   * Start the task running\n   */\n  start(): void\n\n  /**\n   * Stop the task running\n   */\n  stop(): void\n}\n\nexport interface RepeatingTaskOptions {\n  /**\n   * How long the task is allowed to run before the passed AbortSignal fires an\n   * abort event\n   */\n  timeout?: number\n\n  /**\n   * Whether to schedule the task to run immediately\n   *\n   * @default false\n   */\n  runImmediately?: boolean\n\n  /**\n   * When `.run()` is called to run the task outside of the current interval,\n   * debounce repeated calls to `.run()` by this amount.\n   *\n   * @default 100\n   */\n  debounce?: number\n}\n\nexport function repeatingTask (fn: (options?: AbortOptions) => void | Promise<void>, interval: number, options?: RepeatingTaskOptions): RepeatingTask {\n  let timeout: ReturnType<typeof setTimeout>\n  let shutdownController: AbortController\n  let running = false\n\n  function runTask (): void {\n    const opts: AbortOptions = {\n      signal: shutdownController.signal\n    }\n\n    if (options?.timeout != null) {\n      const signal = anySignal([shutdownController.signal, AbortSignal.timeout(options.timeout)])\n      setMaxListeners(Infinity, signal)\n\n      opts.signal = signal\n    }\n\n    running = true\n\n    Promise.resolve().then(async () => {\n      await fn(opts)\n    })\n      .catch(() => {})\n      .finally(() => {\n        running = false\n\n        if (shutdownController.signal.aborted) {\n          // task has been cancelled, bail\n          return\n        }\n\n        // reschedule\n        timeout = setTimeout(runTask, interval)\n      })\n  }\n\n  const runTaskDebounced = debounce(runTask, options?.debounce ?? 100)\n\n  let started = false\n\n  return {\n    setInterval: (ms): void => {\n      if (interval === ms) {\n        // already running at this interval, nothing to do\n        return\n      }\n\n      interval = ms\n\n      // maybe reschedule\n      if (timeout != null) {\n        clearTimeout(timeout)\n        timeout = setTimeout(runTask, interval)\n      }\n    },\n    setTimeout: (ms): void => {\n      options ??= {}\n      options.timeout = ms\n    },\n    run: (): void => {\n      if (running) {\n        return\n      }\n\n      clearTimeout(timeout)\n      runTaskDebounced()\n    },\n    start: (): void => {\n      if (started) {\n        return\n      }\n\n      started = true\n      shutdownController = new AbortController()\n      setMaxListeners(Infinity, shutdownController.signal)\n\n      // run now\n      if (options?.runImmediately === true) {\n        queueMicrotask(() => {\n          runTask()\n        })\n      } else {\n        // run later\n        timeout = setTimeout(runTask, interval)\n      }\n    },\n    stop: (): void => {\n      clearTimeout(timeout)\n      shutdownController?.abort()\n      started = false\n    }\n  }\n}\n", "import { AbstractMultiaddrConnection, repeatingTask } from '@libp2p/utils'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport type { AbortOptions, MultiaddrConnection } from '@libp2p/interface'\nimport type { AbstractMultiaddrConnectionInit, RepeatingTask, SendResult } from '@libp2p/utils'\n\nconst DEFAULT_MAX_BUFFERED_AMOUNT = 1024 * 1024 * 4\nconst DEFAULT_BUFFERED_AMOUNT_POLL_INTERVAL = 10\n\nexport interface WebSocketMultiaddrConnectionInit extends Omit<AbstractMultiaddrConnectionInit, 'name'> {\n  websocket: WebSocket\n  maxBufferedAmount?: number\n  bufferedAmountPollInterval?: number\n}\n\nclass WebSocketMultiaddrConnection extends AbstractMultiaddrConnection {\n  private websocket: WebSocket\n  private maxBufferedAmount: number\n  private checkBufferedAmountTask: RepeatingTask\n\n  constructor (init: WebSocketMultiaddrConnectionInit) {\n    super(init)\n\n    this.websocket = init.websocket\n    this.maxBufferedAmount = init.maxBufferedAmount ?? DEFAULT_MAX_BUFFERED_AMOUNT\n    this.checkBufferedAmountTask = repeatingTask(this.checkBufferedAmount.bind(this), init.bufferedAmountPollInterval ?? DEFAULT_BUFFERED_AMOUNT_POLL_INTERVAL)\n\n    this.websocket.addEventListener('close', (evt) => {\n      this.log('closed - code %d, reason \"%s\", wasClean %s', evt.code, evt.reason, evt.wasClean)\n      this.checkBufferedAmountTask.stop()\n\n      if (!evt.wasClean) {\n        this.onRemoteReset()\n        return\n      }\n\n      this.onTransportClosed()\n    }, { once: true })\n\n    this.websocket.addEventListener('message', (evt) => {\n      try {\n        let buf: Uint8Array\n\n        if (typeof evt.data === 'string') {\n          buf = uint8ArrayFromString(evt.data)\n        } else if (evt.data instanceof ArrayBuffer) {\n          buf = new Uint8Array(evt.data, 0, evt.data.byteLength)\n        } else {\n          this.abort(new Error('Incorrect binary type'))\n          return\n        }\n\n        this.onData(buf)\n      } catch (err: any) {\n        this.log.error('error receiving data - %e', err)\n      }\n    })\n  }\n\n  sendData (data: Uint8ArrayList): SendResult {\n    for (const buf of data) {\n      this.websocket.send(buf)\n    }\n\n    const canSendMore = this.websocket.bufferedAmount < this.maxBufferedAmount\n\n    if (!canSendMore) {\n      this.checkBufferedAmountTask.start()\n    }\n\n    return {\n      sentBytes: data.byteLength,\n      canSendMore\n    }\n  }\n\n  sendReset (): void {\n    this.websocket.close(1006) // abnormal closure\n  }\n\n  async sendClose (options?: AbortOptions): Promise<void> {\n    this.websocket.close()\n    options?.signal?.throwIfAborted()\n  }\n\n  sendPause (): void {\n    // read backpressure is not supported\n  }\n\n  sendResume (): void {\n    // read backpressure is not supported\n  }\n\n  private checkBufferedAmount (): void {\n    this.log('buffered amount now %d', this.websocket.bufferedAmount)\n\n    if (this.websocket.bufferedAmount === 0) {\n      this.checkBufferedAmountTask.stop()\n      this.safeDispatchEvent('drain')\n    }\n  }\n}\n\n// Convert a stream into a MultiaddrConnection\n// https://github.com/libp2p/interface-transport#multiaddrconnection\nexport function webSocketToMaConn (init: WebSocketMultiaddrConnectionInit): MultiaddrConnection {\n  return new WebSocketMultiaddrConnection(init)\n}\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "webSockets", "ConnectionFailedError", "message", "StreamResetError", "message", "StreamStateError", "message", "StreamBufferError", "StreamMessageEvent", "data", "eventInitDict", "StreamCloseEvent", "local", "error", "StreamAbortEvent", "StreamResetEvent", "transportSymbol", "FaultTolerance", "TypedEventEmitter", "#listeners", "type", "listeners", "listener", "options", "list", "callback", "event", "result", "once", "detail", "serviceCapabilities", "serviceDependencies", "equals", "a", "b", "i", "alloc", "size", "allocUnsafe", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "MSB", "REST", "encodingLength", "value", "encodeUint8Array", "buf", "offset", "decodeUint8Array", "buf", "offset", "b", "res", "REST", "MSB", "N4", "N5", "N6", "N7", "decodeUint8ArrayList", "decode", "buf", "offset", "decodeUint8Array", "decodeUint8ArrayList", "concat", "arrays", "length", "acc", "curr", "output", "allocUnsafe", "offset", "arr", "base10_exports", "__export", "base10", "empty", "equals", "aa", "bb", "ii", "coerce", "o", "fromString", "str", "toString", "b", "base", "ALPHABET", "name", "BASE_MAP", "j", "i", "x", "xc", "BASE", "LEADER", "FACTOR", "iFACTOR", "encode", "source", "zeroes", "length", "pbegin", "pend", "size", "b58", "carry", "it1", "it2", "str", "decodeUnsafe", "psz", "b256", "it3", "it4", "vch", "decode", "string", "buffer", "src", "_brrp__multiformats_scope_baseX", "base_x_default", "Encoder", "name", "prefix", "baseEncode", "bytes", "Decoder", "baseDecode", "prefixCodePoint", "text", "decoder", "or", "ComposedDecoder", "decoders", "input", "left", "right", "Codec", "from", "encode", "decode", "baseX", "alphabet", "base_x_default", "coerce", "string", "alphabetIdx", "bitsPerChar", "end", "out", "bits", "buffer", "written", "i", "value", "data", "pad", "mask", "createAlphabetIdx", "rfc4648", "base10", "baseX", "base16_exports", "__export", "base16", "base16upper", "base16", "rfc4648", "base16upper", "base2_exports", "__export", "base2", "base2", "rfc4648", "base256emoji_exports", "__export", "base256emoji", "alphabet", "alphabetBytesToChars", "p", "c", "i", "alphabetCharsToBytes", "codePoint", "encode", "data", "decode", "str", "byts", "char", "byt", "base256emoji", "from", "base32_exports", "__export", "base32", "base32hex", "base32hexpad", "base32hexpadupper", "base32hexupper", "base32pad", "base32padupper", "base32upper", "base32z", "base32", "rfc4648", "base32upper", "base32pad", "base32padupper", "base32hex", "base32hexupper", "base32hexpad", "base32hexpadupper", "base32z", "base36_exports", "__export", "base36", "base36upper", "base36", "baseX", "base36upper", "base58_exports", "__export", "base58btc", "base58flickr", "base58btc", "baseX", "base58flickr", "base64_exports", "__export", "base64", "base64pad", "base64url", "base64urlpad", "base64", "rfc4648", "base64pad", "base64url", "base64urlpad", "base8_exports", "__export", "base8", "base8", "rfc4648", "identity_exports", "__export", "identity", "identity", "from", "buf", "toString", "str", "fromString", "textEncoder", "textDecoder", "identity_exports", "__export", "identity", "encode_1", "encode", "MSB", "REST", "MSBALL", "INT", "num", "out", "offset", "oldOffset", "decode", "read", "MSB$1", "REST$1", "buf", "res", "shift", "counter", "b", "l", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "N8", "N9", "length", "value", "varint", "_brrp_varint", "varint_default", "decode", "data", "offset", "varint_default", "encodeTo", "int", "target", "encodingLength", "create", "code", "digest", "size", "sizeOffset", "encodingLength", "digestOffset", "bytes", "encodeTo", "Digest", "decode", "multihash", "coerce", "equals", "a", "b", "data", "code", "name", "encode", "coerce", "digest", "input", "options", "create", "identity", "sha2_browser_exports", "__export", "sha256", "sha512", "DEFAULT_MIN_DIGEST_LENGTH", "from", "name", "code", "encode", "minDigestLength", "maxDigestLength", "Hasher", "input", "options", "result", "createDigest", "digest", "truncate", "create", "sha", "name", "data", "sha256", "from", "sha512", "format", "link", "base", "bytes", "version", "toStringV0", "baseCache", "base58btc", "toStringV1", "base32", "cache", "baseCache", "cid", "CID", "_CID", "version", "code", "multihash", "bytes", "DAG_PB_CODE", "SHA_256_CODE", "digest", "create", "other", "self", "unknown", "equals", "base", "format", "input", "value", "encodeCID", "cidSymbol", "decode", "remainder", "specs", "prefixSize", "multihashBytes", "coerce", "digestBytes", "Digest", "initialBytes", "offset", "next", "i", "length", "codec", "multihashCode", "digestSize", "size", "multihashSize", "source", "prefix", "parseCIDtoBytes", "decoder", "base58btc", "base32", "base36", "toStringV0", "toStringV1", "codeOffset", "encodingLength", "hashOffset", "encodeTo", "bases", "identity_exports", "base2_exports", "base8_exports", "base10_exports", "base16_exports", "base32_exports", "base36_exports", "base58_exports", "base64_exports", "base256emoji_exports", "hashes", "sha2_browser_exports", "createCodec", "name", "prefix", "encode", "decode", "string", "buf", "str", "ascii", "i", "allocUnsafe", "BASES", "bases", "bases_default", "fromString", "string", "encoding", "base", "bases_default", "toString", "array", "encoding", "base", "bases_default", "InvalidMultiaddrError", "ValidationError", "InvalidParametersError", "UnknownProtocolError", "Parser", "input", "fn", "index", "result", "target", "char", "sep", "inner", "radix", "maxDigits", "allowZeroPrefix", "maxBytes", "digitCount", "leadingChar", "hasLeadingZero", "maxValue", "digit", "num", "out", "i", "ix", "readGroups", "groups", "ipv4", "group", "head", "headSize", "headIp4", "tail", "limit", "tailSize", "MAX_IPV6_LENGTH", "MAX_IPV4_LENGTH", "parser", "Parser", "parseIPv4", "input", "parseIPv6", "input", "MAX_IPV6_LENGTH", "parser", "isIPv4", "input", "parseIPv4", "isIPv6", "parseIPv6", "bytesToString", "base", "buf", "toString", "stringToBytes", "fromString", "bytes2port", "port2bytes", "port", "onion2bytes", "str", "addr", "portBuf", "concat", "onion32bytes", "base32", "bytes2onion", "addrBytes", "portBytes", "ip4ToBytes", "ip", "bytes", "byte", "index", "value", "InvalidMultiaddrError", "ip6ToBytes", "offset", "sections", "i", "isv4", "isIPv4", "v4Buffer", "argv", "word", "ip4ToString", "result", "ip6ToString", "byte1", "byte2", "tuple", "url", "ip6StringToValue", "decoders", "bases", "c", "anybaseDecoder", "acc", "d", "mb2bytes", "mbstr", "bytes2mb", "integer", "value", "ValidationError", "positive", "maxValue", "max", "validate", "funcs", "fn", "validatePort", "V", "Registry", "key", "codec", "UnknownProtocolError", "alias", "code", "registry", "codecs", "ip4ToBytes", "ip4ToString", "value", "isIPv4", "ValidationError", "port2bytes", "bytes2port", "validatePort", "ip6ToBytes", "ip6ToString", "ip6StringToValue", "isIPv6", "bytesToString", "stringToBytes", "str", "val", "CID", "bytes2onion", "onion2bytes", "onion32bytes", "bytes2mb", "base64url", "mb2bytes", "bytesToComponents", "bytes", "components", "i", "code", "decode", "codec", "registry", "codeLength", "encodingLength", "size", "sizeForAddr", "sizeLength", "V", "componentLength", "component", "valueOffset", "valueBytes", "toString", "componentsToBytes", "length", "codecLength", "valueLength", "valueLengthLength", "fromString", "offset", "encodeUint8Array", "concat", "stringToComponents", "string", "InvalidMultiaddrError", "collecting", "value", "protocol", "char", "ended", "componentsToString", "inspect", "symbol", "toComponents", "addr", "isMultiaddr", "bytesToComponents", "stringToComponents", "InvalidMultiaddrError", "Multiaddr", "_Multiaddr", "#components", "#string", "#bytes", "options", "validate", "componentsToBytes", "componentsToString", "c", "ma", "addrString", "s", "i", "InvalidParametersError", "code", "index", "equals", "component", "codec", "registry", "isMultiaddr", "value", "symbol", "multiaddr", "addr", "Multiaddr", "code", "vals", "component", "value", "not", "matcher", "optional", "result", "or", "matchers", "matches", "and", "fmt", "match", "ma", "parts", "exactMatch", "_PEER_ID", "value", "PEER_ID", "fmt", "_DNS4", "_DNS6", "_DNSADDR", "_DNS", "DNS4", "optional", "DNS6", "DNSADDR", "DNS", "or", "_IP4", "and", "_IP6", "_IP", "_IP_OR_DOMAIN", "IP_OR_DOMAIN", "IP4", "IP6", "IP", "_TCP", "_UDP", "TCP", "UDP", "_QUIC", "code", "_QUIC_V1", "QUIC_V0_OR_V1", "QUIC", "QUIC_V1", "_WEB", "_WebSockets", "WebSockets", "_WebSocketsSecure", "WebSocketsSecure", "_WebRTCDirect", "WebRTCDirect", "_WebTransport", "WebTransport", "_P2P", "P2P", "_Circuit", "not", "Circuit", "_WebRTC", "WebRTC", "_HTTP", "HTTP", "_HTTPS", "HTTPS", "_Memory", "Memory", "_Unix", "Unix", "ASSUME_HTTP_CODES", "extractSNI", "ma", "extractTuple", "extractPort", "port", "name", "component", "hasTLS", "code", "interpretNext", "head", "rest", "interpreter", "interpreters", "restVal", "tail", "maHasTLS", "sni", "protocol", "baseVal", "decodedValue", "multiaddrToUri", "input", "opts", "components", "multiaddr", "uri", "TimeoutError", "message", "AbortError", "getDOMException", "errorMessage", "getAbortedReason", "signal", "reason", "pTimeout", "promise", "options", "milliseconds", "fallback", "customTimers", "timer", "abortHandler", "cancelablePromise", "resolve", "reject", "timeoutError", "error", "normalizeEmitter", "emitter", "addListener", "removeListener", "pEventMultiple", "event", "options", "cancel", "returnValue", "resolve", "reject", "events", "items", "onItem", "arguments_", "value", "error", "rejectHandler", "rejectionEvent", "timeout", "pTimeout", "pEvent", "arrayPromise", "promise", "array", "CustomProgressEvent", "type", "detail", "createListener", "symbol", "findBufAndOffset", "bufs", "index", "offset", "buf", "bufEnd", "isUint8ArrayList", "value", "Uint8ArrayList", "_Uint8ArrayList", "data", "length", "res", "i", "bytes", "beginInclusive", "endExclusive", "concat", "list", "bufStart", "sliceStartInBuf", "sliceEndsInBuf", "start", "search", "needle", "M", "radix", "rightmostPositions", "c", "j", "right", "lastIndex", "lastPatIndex", "skip", "char", "byteOffset", "allocUnsafe", "littleEndian", "alloc", "other", "equals", "acc", "curr", "pDefer", "deferred", "resolve", "reject", "FixedFIFO", "hwm", "data", "last", "FIFO", "options", "obj", "val", "prev", "next", "AbortError", "message", "code", "pushable", "options", "_pushable", "buffer", "next", "_pushable", "getNext", "options", "onEnd", "buffer", "FIFO", "pushable", "onNext", "ended", "drain", "pDefer", "waitNext", "resolve", "reject", "next", "err", "bufferNext", "bufferError", "push", "value", "end", "_return", "_throw", "signal", "cancel", "listener", "AbortError", "opts", "debounce", "func", "wait", "timeout", "output", "later", "StreamClosedError", "defaultTranslate", "signal", "raceSignal", "promise", "opts", "translateError", "listener", "resolve", "reject", "DEFAULT_MAX_READ_BUFFER_LENGTH", "AbstractMessageStream", "TypedEventEmitter", "init", "Uint8ArrayList", "continueSendingOnDrain", "rejectOnDrainOnClose", "evt", "StreamClosedError", "options", "raceSignal", "output", "pushable", "streamAsyncIterableOnMessageListener", "streamAsyncIterableOnCloseListener", "streamAsyncIterableOnRemoteCloseWriteListener", "data", "StreamStateError", "err", "StreamAbortEvent", "args", "StreamResetError", "StreamResetEvent", "StreamCloseEvent", "canSendMore", "totalBytes", "sentBytes", "end", "toSend", "willSend", "sendResult", "buf", "StreamMessageEvent", "StreamBufferError", "AbstractMultiaddrConnection", "AbstractMessageStream", "init", "evt", "options", "pEvent", "anySignal", "signals", "controller", "onAbort", "signal", "clear", "repeatingTask", "fn", "interval", "options", "timeout", "shutdownController", "running", "runTask", "opts", "signal", "anySignal", "runTaskDebounced", "debounce", "started", "ms", "DEFAULT_MAX_BUFFERED_AMOUNT", "DEFAULT_BUFFERED_AMOUNT_POLL_INTERVAL", "WebSocketMultiaddrConnection", "AbstractMultiaddrConnection", "init", "repeatingTask", "evt", "buf", "fromString", "err", "data", "canSendMore", "options", "webSocketToMaConn", "WebSockets", "components", "init", "transportSymbol", "serviceCapabilities", "ma", "options", "maConn", "webSocketToMaConn", "conn", "uri", "multiaddrToUri", "websocket", "CustomProgressEvent", "pEvent", "err", "ConnectionFailedError", "createListener", "multiaddrs", "WebSocketsSecure", "webSockets"]
}
