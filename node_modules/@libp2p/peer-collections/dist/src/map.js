import { mapIterable } from './util.js';
/**
 * We can't use PeerIds as map keys because map keys are
 * compared using same-value-zero equality, so this is just
 * a map that stringifies the PeerIds before storing them.
 *
 * PeerIds cache stringified versions of themselves so this
 * should be a cheap operation.
 *
 * @example
 *
 * ```TypeScript
 * import { peerMap } from '@libp2p/peer-collections'
 *
 * const map = peerMap<string>()
 * map.set(peerId, 'value')
 * ```
 */
export class PeerMap {
    map;
    constructor(map) {
        this.map = new Map();
        if (map != null) {
            for (const [key, value] of map.entries()) {
                this.map.set(key.toString(), { key, value });
            }
        }
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    clear() {
        this.map.clear();
    }
    delete(peer) {
        return this.map.delete(peer.toString());
    }
    entries() {
        return mapIterable(this.map.entries(), (val) => {
            return [val[1].key, val[1].value];
        });
    }
    forEach(fn) {
        this.map.forEach((value, key) => {
            fn(value.value, value.key, this);
        });
    }
    get(peer) {
        return this.map.get(peer.toString())?.value;
    }
    has(peer) {
        return this.map.has(peer.toString());
    }
    set(peer, value) {
        this.map.set(peer.toString(), { key: peer, value });
    }
    keys() {
        return mapIterable(this.map.values(), (val) => {
            return val.key;
        });
    }
    values() {
        return mapIterable(this.map.values(), (val) => val.value);
    }
    get size() {
        return this.map.size;
    }
}
export function peerMap() {
    return new PeerMap();
}
//# sourceMappingURL=map.js.map