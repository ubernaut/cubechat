import { mapIterable } from './util.js';
/**
 * We can't use PeerIds as list entries because list entries are
 * compared using same-value-zero equality, so this is just
 * a map that stringifies the PeerIds before storing them.
 *
 * PeerIds cache stringified versions of themselves so this
 * should be a cheap operation.
 *
 * @example
 *
 * ```TypeScript
 * import { peerList } from '@libp2p/peer-collections'
 *
 * const list = peerList()
 * list.push(peerId)
 * ```
 */
export class PeerList {
    list;
    constructor(list) {
        this.list = [];
        if (list != null) {
            for (const value of list) {
                this.list.push(value);
            }
        }
    }
    [Symbol.iterator]() {
        return mapIterable(this.list.entries(), (val) => {
            return val[1];
        });
    }
    concat(list) {
        const output = new PeerList(this);
        for (const value of list) {
            output.push(value);
        }
        return output;
    }
    entries() {
        return mapIterable(this.list.entries(), (val) => {
            return [val[0], val[1]];
        });
    }
    every(predicate) {
        return this.list.every((peerId, index) => {
            return predicate(peerId, index, this);
        });
    }
    filter(predicate) {
        const output = new PeerList();
        this.list.forEach((peerId, index) => {
            if (predicate(peerId, index, this)) {
                output.push(peerId);
            }
        });
        return output;
    }
    find(predicate) {
        const peerId = this.list.find((peerId, index) => {
            return predicate(peerId, index, this);
        });
        if (peerId == null) {
            return undefined;
        }
        return peerId;
    }
    findIndex(predicate) {
        return this.list.findIndex((peerId, index) => {
            return predicate(peerId, index, this);
        });
    }
    forEach(predicate) {
        this.list.forEach((peerId, index) => {
            predicate(peerId, index, this);
        });
    }
    includes(peerId) {
        return this.includes(peerId);
    }
    indexOf(peerId) {
        return this.list.findIndex(id => id.equals(peerId));
    }
    pop() {
        const peerId = this.list.pop();
        if (peerId == null) {
            return undefined;
        }
        return peerId;
    }
    push(...peerIds) {
        for (const peerId of peerIds) {
            this.list.push(peerId);
        }
    }
    shift() {
        const peerId = this.list.shift();
        if (peerId == null) {
            return undefined;
        }
        return peerId;
    }
    unshift(...peerIds) {
        let len = this.list.length;
        for (let i = peerIds.length - 1; i > -1; i--) {
            len = this.list.unshift(peerIds[i]);
        }
        return len;
    }
    clear() {
        this.list = [];
    }
    get length() {
        return this.list.length;
    }
}
export function peerList() {
    return new PeerList();
}
//# sourceMappingURL=list.js.map