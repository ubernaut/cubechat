import { AbstractStreamMuxer } from '@libp2p/utils';
import { MUXER_PROTOCOL } from './constants.js';
import { createStream, WebRTCStream } from './stream.js';
export class DataChannelMuxerFactory {
    protocol;
    /**
     * WebRTC Peer Connection
     */
    peerConnection;
    metrics;
    dataChannelOptions;
    earlyDataChannels;
    constructor(init) {
        this.onEarlyDataChannel = this.onEarlyDataChannel.bind(this);
        this.peerConnection = init.peerConnection;
        this.metrics = init.metrics;
        this.protocol = init.protocol ?? MUXER_PROTOCOL;
        this.dataChannelOptions = init.dataChannelOptions ?? {};
        this.peerConnection.addEventListener('datachannel', this.onEarlyDataChannel);
        this.earlyDataChannels = [];
    }
    onEarlyDataChannel(evt) {
        this.earlyDataChannels.push(evt.channel);
    }
    createStreamMuxer(maConn) {
        this.peerConnection.removeEventListener('datachannel', this.onEarlyDataChannel);
        return new DataChannelMuxer(maConn, {
            peerConnection: this.peerConnection,
            dataChannelOptions: this.dataChannelOptions,
            metrics: this.metrics,
            protocol: this.protocol,
            earlyDataChannels: this.earlyDataChannels
        });
    }
}
/**
 * A libp2p data channel stream muxer
 */
export class DataChannelMuxer extends AbstractStreamMuxer {
    peerConnection;
    dataChannelOptions;
    constructor(maConn, init) {
        super(maConn, {
            ...init,
            name: 'muxer'
        });
        this.peerConnection = init.peerConnection;
        this.protocol = init.protocol ?? MUXER_PROTOCOL;
        this.dataChannelOptions = init.dataChannelOptions ?? {};
        /**
         * Fired when a data channel has been added to the connection has been
         * added by the remote peer.
         *
         * {@link https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/datachannel_event}
         */
        this.peerConnection.ondatachannel = ({ channel }) => {
            this.onDataChannel(channel);
        };
        queueMicrotask(() => {
            if (this.status !== 'open') {
                init.earlyDataChannels.forEach(channel => {
                    channel.close();
                });
                return;
            }
            init.earlyDataChannels.forEach(channel => {
                this.onDataChannel(channel);
            });
        });
    }
    onDataChannel(channel) {
        this.log('incoming datachannel with channel id %d, protocol %s and status %s', channel.id, channel.protocol, channel.readyState);
        // 'init' channel is only used during connection establishment, it is
        // closed by the initiator
        if (channel.label === 'init') {
            this.log.trace('closing init channel %d', channel.id);
            channel.close();
            return;
        }
        const stream = createStream({
            ...this.streamOptions,
            ...this.dataChannelOptions,
            channel,
            direction: 'inbound',
            log: this.log
        });
        this.onRemoteStream(stream);
    }
    async onCreateStream(options) {
        // The spec says the label MUST be an empty string: https://github.com/libp2p/specs/blob/master/webrtc/README.md#rtcdatachannel-label
        const channel = this.peerConnection.createDataChannel('', {
        // TODO: pre-negotiate stream protocol
        // protocol: options?.protocol
        });
        this.log('open channel %d for protocol %s', channel.id, options?.protocol);
        const stream = createStream({
            ...options,
            ...this.dataChannelOptions,
            channel,
            direction: 'outbound',
            log: this.log
        });
        return stream;
    }
    onData() {
    }
}
//# sourceMappingURL=muxer.js.map