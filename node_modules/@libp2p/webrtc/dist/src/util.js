import { detect } from 'detect-browser';
import pDefer from 'p-defer';
import pTimeout from 'p-timeout';
import { DATA_CHANNEL_DRAIN_TIMEOUT, DEFAULT_ICE_SERVERS, UFRAG_ALPHABET, UFRAG_PREFIX } from './constants.js';
const browser = detect();
export const isFirefox = ((browser != null) && browser.name === 'firefox');
export const nopSource = async function* nop() { };
export const nopSink = async (_) => { };
// Duplex that does nothing. Needed to fulfill the interface
export function inertDuplex() {
    return {
        source: {
            [Symbol.asyncIterator]() {
                return {
                    async next() {
                        // This will never resolve
                        return new Promise(() => { });
                    }
                };
            }
        },
        sink: async (source) => {
            // This will never resolve
            return new Promise(() => { });
        }
    };
}
export function drainAndClose(channel, direction, drainTimeout = DATA_CHANNEL_DRAIN_TIMEOUT, options) {
    if (channel.readyState !== 'open') {
        return;
    }
    void Promise.resolve()
        .then(async () => {
        // wait for bufferedAmount to become zero
        if (channel.bufferedAmount > 0) {
            options.log('%s drain channel with %d buffered bytes', direction, channel.bufferedAmount);
            const deferred = pDefer();
            let drained = false;
            channel.bufferedAmountLowThreshold = 0;
            const closeListener = () => {
                if (!drained) {
                    options.log('%s drain channel closed before drain', direction);
                    deferred.resolve();
                }
            };
            channel.addEventListener('close', closeListener, {
                once: true
            });
            channel.addEventListener('bufferedamountlow', () => {
                drained = true;
                channel.removeEventListener('close', closeListener);
                deferred.resolve();
            });
            await pTimeout(deferred.promise, {
                milliseconds: drainTimeout
            });
        }
    })
        .then(async () => {
        // only close if the channel is still open
        if (channel.readyState === 'open') {
            channel.close();
        }
    })
        .catch(err => {
        options.log.error('error closing outbound stream - %e', err);
    });
}
export function isPeerConnection(obj) {
    return typeof obj.state === 'function';
}
export async function getRtcConfiguration(config) {
    config = config ?? {};
    if (typeof config === 'function') {
        config = await config();
    }
    config.iceServers = config.iceServers ?? DEFAULT_ICE_SERVERS.map(url => ({
        urls: [
            url
        ]
    }));
    return config;
}
export const genUfrag = (len = 32) => {
    return UFRAG_PREFIX + [...Array(len)].map(() => UFRAG_ALPHABET.at(Math.floor(Math.random() * UFRAG_ALPHABET.length))).join('');
};
//# sourceMappingURL=util.js.map