import { serviceCapabilities, transportSymbol } from '@libp2p/interface';
import { X509Certificate } from '@peculiar/x509';
import { Key } from 'interface-datastore';
import type { DataChannelOptions, TransportCertificate } from '../index.js';
import type { WebRTCDialEvents } from '../private-to-private/transport.js';
import type { CreateListenerOptions, Transport, Listener, ComponentLogger, Connection, CounterGroup, Metrics, PeerId, DialTransportOptions, PrivateKey, Upgrader, Startable } from '@libp2p/interface';
import type { TransportManager } from '@libp2p/interface-internal';
import type { Keychain } from '@libp2p/keychain';
import type { Multiaddr } from '@multiformats/multiaddr';
import type { Datastore } from 'interface-datastore';
export interface WebRTCDirectTransportComponents {
    peerId: PeerId;
    privateKey: PrivateKey;
    metrics?: Metrics;
    logger: ComponentLogger;
    transportManager: TransportManager;
    upgrader: Upgrader;
    keychain?: Keychain;
    datastore: Datastore;
}
export interface WebRTCMetrics {
    dialerEvents: CounterGroup;
}
export interface WebRTCTransportDirectInit {
    /**
     * The default configuration used by all created RTCPeerConnections
     */
    rtcConfiguration?: RTCConfiguration | (() => RTCConfiguration | Promise<RTCConfiguration>);
    /**
     * The default configuration used by all created RTCDataChannels
     */
    dataChannel?: DataChannelOptions;
    /**
     * Use an existing TLS certificate to secure incoming connections or supply
     * settings to generate one.
     *
     * This must be an ECDSA certificate using the P-256 curve.
     *
     * From our testing we find that P-256 elliptic curve is supported by Pion,
     * webrtc-rs, as well as Chromium (P-228 and P-384 was not supported in
     * Chromium).
     */
    certificate?: TransportCertificate;
    /**
     * The key the certificate is stored in the datastore under
     *
     * @default '/libp2p/webrtc-direct/certificate'
     */
    certificateDatastoreKey?: string;
    /**
     * The name the certificate private key is stored in the keychain with
     *
     * @default 'webrtc-direct-certificate-private-key'
     */
    certificateKeychainName?: string;
    /**
     * Number of ms a certificate should be valid for (defaults to 14 days)
     *
     * @default 2_592_000_000
     */
    certificateLifespan?: number;
    /**
     * Certificates will be renewed this many ms before expiry (defaults to 1 day)
     *
     * @default 86_400_000
     */
    certificateRenewalThreshold?: number;
}
export interface WebRTCDirectTransportCertificateEvents {
    'certificate:renew': CustomEvent<TransportCertificate>;
}
export declare class WebRTCDirectTransport implements Transport, Startable {
    private readonly log;
    private readonly metrics?;
    private readonly components;
    private readonly init;
    private certificate?;
    private privateKey?;
    private readonly emitter;
    private renewCertificateTask?;
    constructor(components: WebRTCDirectTransportComponents, init?: WebRTCTransportDirectInit);
    readonly [transportSymbol] = true;
    readonly [Symbol.toStringTag] = "@libp2p/webrtc-direct";
    readonly [serviceCapabilities]: string[];
    start(): Promise<void>;
    stop(): Promise<void>;
    /**
     * Dial a given multiaddr
     */
    dial(ma: Multiaddr, options: DialTransportOptions<WebRTCDialEvents>): Promise<Connection>;
    /**
     * Create a transport listener - this will throw in browsers
     */
    createListener(options: CreateListenerOptions): Listener;
    /**
     * Filter check for all Multiaddrs that this transport can listen on
     */
    listenFilter(multiaddrs: Multiaddr[]): Multiaddr[];
    /**
     * Filter check for all Multiaddrs that this transport can dial
     */
    dialFilter(multiaddrs: Multiaddr[]): Multiaddr[];
    private getCertificate;
    private loadOrCreatePrivateKey;
    private loadOrCreateCertificate;
    loadCertificate(dsKey: Key, keyPair: CryptoKeyPair): Promise<X509Certificate>;
    createCertificate(dsKey: Key, keyPair: CryptoKeyPair): Promise<X509Certificate>;
    private getKeychain;
}
//# sourceMappingURL=transport.d.ts.map