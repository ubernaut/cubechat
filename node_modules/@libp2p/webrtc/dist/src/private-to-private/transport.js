import { InvalidParametersError, serviceCapabilities, serviceDependencies, transportSymbol } from '@libp2p/interface';
import { peerIdFromString } from '@libp2p/peer-id';
import { multiaddr } from '@multiformats/multiaddr';
import { WebRTC } from '@multiformats/multiaddr-matcher';
import { setMaxListeners } from 'main-event';
import { SIGNALING_PROTOCOL } from '../constants.js';
import { DataChannelMuxerFactory } from '../muxer.js';
import { toMultiaddrConnection } from "../rtcpeerconnection-to-conn.js";
import { getRtcConfiguration } from '../util.js';
import { RTCPeerConnection } from '../webrtc/index.js';
import { initiateConnection } from './initiate-connection.js';
import { WebRTCPeerListener } from './listener.js';
import { handleIncomingStream } from './signaling-stream-handler.js';
import { getRemotePeer } from "./util.js";
export class WebRTCTransport {
    components;
    init;
    log;
    _started = false;
    metrics;
    shutdownController;
    constructor(components, init = {}) {
        this.components = components;
        this.init = init;
        this.log = components.logger.forComponent('libp2p:webrtc');
        this.shutdownController = new AbortController();
        setMaxListeners(Infinity, this.shutdownController.signal);
        if (components.metrics != null) {
            this.metrics = {
                dialerEvents: components.metrics.registerCounterGroup('libp2p_webrtc_dialer_events_total', {
                    label: 'event',
                    help: 'Total count of WebRTC dialer events by type'
                }),
                listenerEvents: components.metrics.registerCounterGroup('libp2p_webrtc_listener_events_total', {
                    label: 'event',
                    help: 'Total count of WebRTC listener events by type'
                })
            };
        }
    }
    [transportSymbol] = true;
    [Symbol.toStringTag] = '@libp2p/webrtc';
    [serviceCapabilities] = [
        '@libp2p/transport'
    ];
    [serviceDependencies] = [
        '@libp2p/identify',
        '@libp2p/circuit-relay-v2-transport'
    ];
    isStarted() {
        return this._started;
    }
    async start() {
        await this.components.registrar.handle(SIGNALING_PROTOCOL, (stream, connection) => {
            // ensure we don't try to upgrade forever
            const signal = this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);
            this._onProtocol(stream, connection, signal)
                .catch(err => {
                this.log.error('failed to handle incoming connect from %p - %e', connection.remotePeer, err);
            })
                .finally(() => {
                signal.clear();
            });
        }, {
            runOnLimitedConnection: true
        });
        this._started = true;
    }
    async stop() {
        await this.components.registrar.unhandle(SIGNALING_PROTOCOL);
        this._started = false;
    }
    createListener(options) {
        return new WebRTCPeerListener(this.components, {
            shutdownController: this.shutdownController
        });
    }
    /**
     * Filter check for all Multiaddrs that this transport can listen on
     */
    listenFilter(multiaddrs) {
        return multiaddrs.filter(WebRTC.exactMatch);
    }
    /**
     * Filter check for all Multiaddrs that this transport can dial
     */
    dialFilter(multiaddrs) {
        return this.listenFilter(multiaddrs);
    }
    /*
     * dial connects to a remote via the circuit relay or any other protocol
     * and proceeds to upgrade to a webrtc connection.
     * multiaddr of the form: <multiaddr>/webrtc/p2p/<destination-peer>
     * For a circuit relay, this will be of the form
     * <relay address>/p2p/<relay-peer>/p2p-circuit/webrtc/p2p/<destination-peer>
    */
    async dial(ma, options) {
        this.log.trace('dialing address: %a', ma);
        const { remoteAddress, peerConnection, muxerFactory } = await initiateConnection({
            rtcConfiguration: await getRtcConfiguration(this.init.rtcConfiguration),
            dataChannel: this.init.dataChannel,
            multiaddr: ma,
            dataChannelOptions: this.init.dataChannel,
            signal: options.signal,
            connectionManager: this.components.connectionManager,
            transportManager: this.components.transportManager,
            log: this.log,
            logger: this.components.logger,
            onProgress: options.onProgress
        });
        const webRTCConn = toMultiaddrConnection({
            peerConnection,
            remoteAddr: remoteAddress,
            metrics: this.metrics?.dialerEvents,
            direction: 'outbound',
            log: this.components.logger.forComponent('libp2p:webrtc:connection')
        });
        const connection = await options.upgrader.upgradeOutbound(webRTCConn, {
            skipProtection: true,
            skipEncryption: true,
            remotePeer: getRemotePeer(ma),
            muxerFactory,
            onProgress: options.onProgress,
            signal: options.signal
        });
        // close the connection on shut down
        this._closeOnShutdown(peerConnection, webRTCConn);
        return connection;
    }
    async _onProtocol(stream, connection, signal) {
        const peerConnection = new RTCPeerConnection(await getRtcConfiguration(this.init.rtcConfiguration));
        // make sure C++ peer connection is garbage collected
        // https://github.com/murat-dogan/node-datachannel/issues/366#issuecomment-3228453155
        peerConnection.addEventListener('connectionstatechange', () => {
            switch (peerConnection.connectionState) {
                case 'closed':
                    peerConnection.close();
                    break;
                default:
                    break;
            }
        });
        const muxerFactory = new DataChannelMuxerFactory({
            // @ts-expect-error https://github.com/murat-dogan/node-datachannel/pull/370
            peerConnection,
            dataChannelOptions: this.init.dataChannel
        });
        try {
            const { remoteAddress, remotePeer } = await handleIncomingStream(stream, connection, {
                peerConnection,
                signal,
                log: this.log
            });
            // close the stream if SDP messages have been exchanged successfully
            await stream.close({
                signal
            });
            const webRTCConn = toMultiaddrConnection({
                // @ts-expect-error https://github.com/murat-dogan/node-datachannel/pull/370
                peerConnection,
                remoteAddr: remoteAddress,
                metrics: this.metrics?.listenerEvents,
                direction: 'inbound',
                log: this.components.logger.forComponent('libp2p:webrtc:connection')
            });
            await this.components.upgrader.upgradeInbound(webRTCConn, {
                skipEncryption: true,
                skipProtection: true,
                remotePeer,
                muxerFactory,
                signal
            });
            // close the connection on shut down
            // @ts-expect-error https://github.com/murat-dogan/node-datachannel/pull/370
            this._closeOnShutdown(peerConnection, webRTCConn);
        }
        catch (err) {
            this.log.error('incoming signaling error - %e', err);
            peerConnection.close();
            stream.abort(err);
            throw err;
        }
    }
    _closeOnShutdown(pc, webRTCConn) {
        // close the connection on shut down
        const shutDownListener = () => {
            webRTCConn.close()
                .catch(err => {
                this.log.error('could not close WebRTCMultiaddrConnection - %e', err);
            });
        };
        this.shutdownController.signal.addEventListener('abort', shutDownListener);
        pc.addEventListener('close', () => {
            this.shutdownController.signal.removeEventListener('abort', shutDownListener);
        });
    }
}
export function splitAddr(ma) {
    const target = ma.getComponents()
        .filter(({ name }) => name === 'p2p')
        .map(({ value }) => value)
        .pop();
    if (target == null) {
        throw new InvalidParametersError('Destination peer id was missing');
    }
    const circuitAddress = multiaddr(ma.getComponents()
        .filter(({ name }) => name !== 'webrtc'));
    return { circuitAddress, targetPeer: peerIdFromString(target) };
}
//# sourceMappingURL=transport.js.map