import { serviceCapabilities, serviceDependencies, transportSymbol } from '@libp2p/interface';
import type { DataChannelOptions } from '../index.js';
import type { OutboundConnectionUpgradeEvents, CreateListenerOptions, DialTransportOptions, Transport, Listener, Upgrader, ComponentLogger, Connection, PeerId, CounterGroup, Metrics, Startable, OpenConnectionProgressEvents, Libp2pEvents, Stream } from '@libp2p/interface';
import type { Registrar, ConnectionManager, TransportManager } from '@libp2p/interface-internal';
import type { Multiaddr } from '@multiformats/multiaddr';
import type { TypedEventTarget } from 'main-event';
import type { ProgressEvent } from 'progress-events';
export interface WebRTCTransportInit {
    /**
     * Add additional configuration to any RTCPeerConnections that are created.
     *
     * This could be extra STUN/TURN servers, certificate, etc.
     */
    rtcConfiguration?: RTCConfiguration | (() => RTCConfiguration | Promise<RTCConfiguration>);
    /**
     * Any options here will be applied to any RTCDataChannels that are opened.
     */
    dataChannel?: DataChannelOptions;
}
export interface WebRTCTransportComponents {
    peerId: PeerId;
    registrar: Registrar;
    upgrader: Upgrader;
    transportManager: TransportManager;
    connectionManager: ConnectionManager;
    metrics?: Metrics;
    logger: ComponentLogger;
    events: TypedEventTarget<Libp2pEvents>;
}
export interface WebRTCTransportMetrics {
    dialerEvents: CounterGroup;
    listenerEvents: CounterGroup;
}
export type WebRTCDialEvents = OutboundConnectionUpgradeEvents | OpenConnectionProgressEvents | ProgressEvent<'webrtc:dial-relay'> | ProgressEvent<'webrtc:reuse-relay-connection'> | ProgressEvent<'webrtc:open-signaling-stream'> | ProgressEvent<'webrtc:send-sdp-offer'> | ProgressEvent<'webrtc:read-sdp-answer'> | ProgressEvent<'webrtc:read-ice-candidates'> | ProgressEvent<'webrtc:add-ice-candidate', string> | ProgressEvent<'webrtc:end-of-ice-candidates'> | ProgressEvent<'webrtc:close-signaling-stream'>;
export declare class WebRTCTransport implements Transport<WebRTCDialEvents>, Startable {
    private readonly components;
    private readonly init;
    private readonly log;
    private _started;
    private readonly metrics?;
    private readonly shutdownController;
    constructor(components: WebRTCTransportComponents, init?: WebRTCTransportInit);
    readonly [transportSymbol] = true;
    readonly [Symbol.toStringTag] = "@libp2p/webrtc";
    readonly [serviceCapabilities]: string[];
    readonly [serviceDependencies]: string[];
    isStarted(): boolean;
    start(): Promise<void>;
    stop(): Promise<void>;
    createListener(options: CreateListenerOptions): Listener;
    /**
     * Filter check for all Multiaddrs that this transport can listen on
     */
    listenFilter(multiaddrs: Multiaddr[]): Multiaddr[];
    /**
     * Filter check for all Multiaddrs that this transport can dial
     */
    dialFilter(multiaddrs: Multiaddr[]): Multiaddr[];
    dial(ma: Multiaddr, options: DialTransportOptions<WebRTCDialEvents>): Promise<Connection>;
    _onProtocol(stream: Stream, connection: Connection, signal: AbortSignal): Promise<void>;
    private _closeOnShutdown;
}
export declare function splitAddr(ma: Multiaddr): {
    circuitAddress: Multiaddr;
    targetPeer: PeerId;
};
//# sourceMappingURL=transport.d.ts.map