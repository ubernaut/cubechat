{
  "version": 3,
  "sources": ["../src/index.ts", "../../../node_modules/p-defer/index.js", "../../../node_modules/race-signal/src/index.ts", "../../it-queueless-pushable/src/index.ts"],
  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * Merge several (async)iterables into one, yield values as they arrive.\n *\n * Nb. sources are iterated over in parallel so the order of emitted items is not guaranteed.\n *\n * @example\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values1 = [0, 1, 2, 3, 4]\n * const values2 = [5, 6, 7, 8, 9]\n *\n * const arr = all(merge(values1, values2))\n *\n * console.info(arr) // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const values1 = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n * const values2 = async function * () {\n *   yield * [5, 6, 7, 8, 9]\n * }\n *\n * const arr = await all(merge(values1(), values2()))\n *\n * console.info(arr) // 0, 1, 5, 6, 2, 3, 4, 7, 8, 9  <- nb. order is not guaranteed\n * ```\n */\n\nimport { queuelessPushable } from 'it-queueless-pushable'\nimport type { Pushable } from 'it-queueless-pushable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\nasync function addAllToPushable <T> (sources: Array<AsyncIterable<T> | Iterable<T>>, output: Pushable<T>, signal: AbortSignal): Promise<void> {\n  try {\n    await Promise.all(\n      sources.map(async (source) => {\n        for await (const item of source) {\n          await output.push(item, {\n            signal\n          })\n          signal.throwIfAborted()\n        }\n      })\n    )\n\n    await output.end(undefined, {\n      signal\n    })\n  } catch (err: any) {\n    await output.end(err, {\n      signal\n    })\n      .catch(() => {})\n  }\n}\n\nasync function * mergeSources <T> (sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined> {\n  const controller = new AbortController()\n  const output = queuelessPushable<T>()\n\n  addAllToPushable(sources, output, controller.signal)\n    .catch(() => {})\n\n  try {\n    yield * output\n  } finally {\n    controller.abort()\n  }\n}\n\nfunction * mergeSyncSources <T> (syncSources: Array<Iterable<T>>): Generator<T, void, undefined> {\n  for (const source of syncSources) {\n    yield * source\n  }\n}\n\n/**\n * Treat one or more iterables as a single iterable.\n *\n * Nb. sources are iterated over in parallel so the\n * order of emitted items is not guaranteed.\n */\nfunction merge <T> (...sources: Array<Iterable<T>>): Generator<T, void, undefined>\nfunction merge <T> (...sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined>\nfunction merge <T> (...sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  const syncSources: Array<Iterable<T>> = []\n\n  for (const source of sources) {\n    if (!isAsyncIterable(source)) {\n      syncSources.push(source)\n    }\n  }\n\n  if (syncSources.length === sources.length) {\n    // all sources are synchronous\n    return mergeSyncSources(syncSources)\n  }\n\n  return mergeSources(sources)\n}\n\nexport default merge\n", "export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n", "/**\n * An abort error class that extends error\n */\nexport class AbortError extends Error {\n  public type: string\n  public code: string | string\n\n  constructor (message?: string, code?: string, name?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.name = name ?? 'AbortError'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface RaceSignalOptions {\n  /**\n   * The message for the error thrown if the signal aborts\n   */\n  errorMessage?: string\n\n  /**\n   * The code for the error thrown if the signal aborts\n   */\n  errorCode?: string\n\n  /**\n   * The name for the error thrown if the signal aborts\n   */\n  errorName?: string\n}\n\n/**\n * Race a promise against an abort signal\n */\nexport async function raceSignal <T> (promise: Promise<T>, signal?: AbortSignal, opts?: RaceSignalOptions): Promise<T> {\n  if (signal == null) {\n    return promise\n  }\n\n  if (signal.aborted) {\n    // the passed promise may yet resolve or reject but the use has signalled\n    // they are no longer interested so smother the error\n    promise.catch(() => {})\n    return Promise.reject(new AbortError(opts?.errorMessage, opts?.errorCode, opts?.errorName))\n  }\n\n  let listener\n\n  // create the error here so we have more context in the stack trace\n  const error = new AbortError(opts?.errorMessage, opts?.errorCode, opts?.errorName)\n\n  try {\n    return await Promise.race([\n      promise,\n      new Promise<T>((resolve, reject) => {\n        listener = () => {\n          reject(error)\n        }\n        signal.addEventListener('abort', listener)\n      })\n    ])\n  } finally {\n    if (listener != null) {\n      signal.removeEventListener('abort', listener)\n    }\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * A pushable async generator that waits until the current value is consumed\n * before allowing a new value to be pushed.\n *\n * Useful for when you don't want to keep memory usage under control and/or\n * allow a downstream consumer to dictate how fast data flows through a pipe,\n * but you want to be able to apply a transform to that data.\n *\n * @example\n *\n * ```typescript\n * import { queuelessPushable } from 'it-queueless-pushable'\n *\n * const pushable = queuelessPushable<string>()\n *\n * // run asynchronously\n * Promise.resolve().then(async () => {\n *   // push a value - the returned promise will not resolve until the value is\n *   // read from the pushable\n *   await pushable.push('hello')\n * })\n *\n * // read a value\n * const result = await pushable.next()\n * console.info(result) // { done: false, value: 'hello' }\n * ```\n */\n\nimport deferred from 'p-defer'\nimport { raceSignal } from 'race-signal'\nimport type { AbortOptions } from 'abort-error'\nimport type { RaceSignalOptions } from 'race-signal'\n\nexport interface Pushable<T> extends AsyncGenerator<T, void, unknown> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end(err?: Error, options?: AbortOptions & RaceSignalOptions): Promise<void>\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push(value: T, options?: AbortOptions & RaceSignalOptions): Promise<void>\n}\n\nclass QueuelessPushable <T> implements Pushable<T> {\n  private readNext: PromiseWithResolvers<void>\n  private haveNext: PromiseWithResolvers<void>\n  private ended: boolean\n  private nextResult: IteratorResult<T> | undefined\n  private error?: Error\n\n  constructor () {\n    this.ended = false\n\n    this.readNext = deferred()\n    this.haveNext = deferred()\n  }\n\n  [Symbol.asyncIterator] (): AsyncGenerator<T, void, unknown> {\n    return this\n  }\n\n  async next (): Promise<IteratorResult<T, void>> {\n    if (this.nextResult == null) {\n      // wait for the supplier to push a value\n      await this.haveNext.promise\n    }\n\n    if (this.nextResult == null) {\n      throw new Error('HaveNext promise resolved but nextResult was undefined')\n    }\n\n    const nextResult = this.nextResult\n    this.nextResult = undefined\n\n    // signal to the supplier that we read the value\n    this.readNext.resolve()\n    this.readNext = deferred()\n\n    return nextResult\n  }\n\n  async throw (err?: Error): Promise<IteratorReturnResult<undefined>> {\n    this.ended = true\n    this.error = err\n\n    if (err != null) {\n      // this can cause unhandled promise rejections if nothing is awaiting the\n      // next value so attach a dummy catch listener to the promise\n      this.haveNext.promise.catch(() => {})\n      this.haveNext.reject(err)\n    }\n\n    const result: IteratorReturnResult<undefined> = {\n      done: true,\n      value: undefined\n    }\n\n    return result\n  }\n\n  async return (): Promise<IteratorResult<T>> {\n    const result: IteratorReturnResult<undefined> = {\n      done: true,\n      value: undefined\n    }\n\n    this.ended = true\n    this.nextResult = result\n\n    // let the consumer know we have a new value\n    this.haveNext.resolve()\n\n    return result\n  }\n\n  async push (value: T, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    await this._push(value, options)\n  }\n\n  async end (err?: Error, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    if (err != null) {\n      await this.throw(err)\n    } else {\n      // abortable return\n      await this._push(undefined, options)\n    }\n  }\n\n  private async _push (value?: T, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    if (value != null && this.ended) {\n      throw this.error ?? new Error('Cannot push value onto an ended pushable')\n    }\n\n    // wait for all values to be read\n    while (this.nextResult != null) {\n      await this.readNext.promise\n    }\n\n    if (value != null) {\n      this.nextResult = { done: false, value }\n    } else {\n      this.ended = true\n      this.nextResult = { done: true, value: undefined }\n    }\n\n    // let the consumer know we have a new value\n    this.haveNext.resolve()\n    this.haveNext = deferred()\n\n    // wait for the consumer to have finished processing the value and requested\n    // the next one or for the passed signal to abort the waiting\n    await raceSignal(\n      this.readNext.promise,\n      options?.signal,\n      options\n    )\n  }\n}\n\nexport function queuelessPushable <T> (): Pushable<T> {\n  return new QueuelessPushable<T>()\n}\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "index_default", "pDefer", "deferred", "resolve", "reject", "AbortError", "message", "code", "name", "raceSignal", "promise", "signal", "opts", "listener", "error", "resolve", "reject", "QueuelessPushable", "pDefer", "nextResult", "err", "result", "value", "options", "raceSignal", "queuelessPushable", "isAsyncIterable", "thing", "addAllToPushable", "sources", "output", "signal", "source", "item", "err", "mergeSources", "controller", "queuelessPushable", "mergeSyncSources", "syncSources", "merge", "index_default"]
}
