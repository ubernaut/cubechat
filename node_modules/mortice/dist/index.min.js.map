{
  "version": 3,
  "sources": ["../src/index.ts", "../node_modules/abort-error/src/index.ts", "../node_modules/p-defer/index.js", "../node_modules/it-pushable/src/fifo.ts", "../node_modules/it-pushable/src/index.ts", "../node_modules/main-event/src/index.ts", "../node_modules/race-event/src/index.ts", "../node_modules/it-queue/src/errors.ts", "../node_modules/race-signal/src/index.ts", "../node_modules/it-queue/src/recipient.ts", "../node_modules/it-queue/src/job.ts", "../node_modules/it-queue/src/utils.ts", "../node_modules/it-queue/src/index.ts", "../src/constants.ts", "../src/main/channel.ts", "../src/utils.ts", "../src/workers/channel.ts", "../src/browser.ts", "../src/mortice.ts"],
  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * - Reads occur concurrently\n * - Writes occur one at a time\n * - No reads occur while a write operation is in progress\n * - Locks can be created with different names\n * - Reads/writes can time out\n *\n * @example\n *\n * ```ts\n * import mortice from 'mortice'\n * import delay from 'delay'\n *\n * // the lock name & options objects are both optional\n * const mutex = mortice()\n *\n * Promise.all([\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 1')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 2')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.writeLock()\n *\n *     try {\n *       await delay(1000)\n *\n *       console.info('write 1')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 3')\n *     } finally {\n *       release()\n *     }\n *   })()\n * ])\n * ```\n *\n *     read 1\n *     read 2\n *     <small pause>\n *     write 1\n *     read 3\n *\n * ## Clean up\n *\n * Mutexes are stored globally reference by name, this is so you can obtain the\n * same lock from different contexts, including workers.\n *\n * When a mutex is no longer required, the `.finalize` function should be called\n * to remove any internal references to it.\n *\n * ```ts\n * import mortice from 'mortice'\n *\n * const mutex = mortice()\n *\n * // ...some time later\n *\n * mutex.finalize()\n * ```\n *\n * ## Auto clean up\n *\n * If your app generates a lot of short-lived mutexes and you want to clean them\n * up after the last lock has been released, pass the `autoFinalize` option to\n * mortice in the owning context:\n *\n ```ts\n * import mortice from 'mortice'\n *\n * const mutex = mortice({\n *   autoFinalize: true\n * })\n *\n * const release = await mutex.readLock()\n * // ...some time later\n *\n * release()\n *\n * // mutex will be freed soon after\n * ```\n *\n * ## React native support\n *\n * This module should run on react native but it only supports single-process\n * concurrency as it's not clear to the author (disclaimer - not a react native\n * dev) what the officially supported process concurrency model is.\n *\n * Please open an issue if this is a feature you would like to see added.\n */\n\nimport { Queue } from 'it-queue'\nimport { createMutex } from './mortice.ts'\nimport type { AbortOptions } from 'abort-error'\n\nexport interface MorticeOptions {\n  /**\n   * An optional name for the lock\n   */\n  name?: string\n\n  /**\n   * How many read operations are executed concurrently\n   *\n   * @default Infinity\n   */\n  concurrency?: number\n\n  /**\n   * By default the the lock will be held on the main thread and child/worker\n   * processes will coordinate to share the lock.\n   *\n   * Set this to true if each main/child/worker thread should maintain it's own\n   * lock with no coordination between them.\n   *\n   * @default false\n   */\n  singleProcess?: boolean\n\n  /**\n   * If true, the lock will be finalized after the last reader/writer releases\n   * it.\n   *\n   * @default false\n   */\n  autoFinalize?: boolean\n}\n\nexport interface Mortice {\n  /**\n   * Acquire a read lock. Multiple reads will occur simultaneously up to the\n   * concurrency limit passed to the constructor.\n   */\n  readLock(options?: AbortOptions): Promise<Release>\n\n  /**\n   * Acquire a write lock. The write lock will wait for any in-flight reads to\n   * complete, then prevent any further reads or writes until the lock is\n   * released.\n   */\n  writeLock(options?: AbortOptions): Promise<Release>\n\n  /**\n   * Removes this mutex from the global state, after invoking this method it\n   * cannot be used any more.\n   */\n  finalize(): void\n\n  /**\n   * If this is the main thread, the state of the read/write queue may be\n   * inspected here\n   */\n  queue?: Queue\n}\n\nexport interface Release {\n  (): void\n}\n\nconst defaultOptions = {\n  name: 'lock',\n  concurrency: Infinity,\n  singleProcess: false,\n  autoFinalize: false\n}\n\nexport default function createMortice (options?: MorticeOptions): Mortice {\n  const opts: Required<MorticeOptions> = Object.assign({}, defaultOptions, options)\n\n  return createMutex(opts.name, opts)\n}\n", "/**\n * @packageDocumentation\n *\n * A simple error class and options interface that seems to get copied from\n * project to project.\n *\n * @example Using `AbortError`\n *\n * ```JavaScript\n * import { AbortError } from 'abort-error'\n *\n * // a promise that will be settled later\n * const deferred = Promise.withResolvers()\n *\n * const signal = AbortSignal.timeout(1000)\n * signal.addEventListener('abort', () => {\n *   deferred.reject(new AbortError())\n * })\n * ```\n *\n * @example Using `AbortOptions`\n *\n * ```TypeScript\n * import type { AbortOptions } from 'abort-error'\n *\n * async function myFunction (options?: AbortOptions) {\n *   return fetch('https://example.com', {\n *     signal: options?.signal\n *   })\n * }\n * ```\n */\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\nexport class AbortError extends Error {\n  static name = 'AbortError'\n  name = 'AbortError'\n\n  constructor (message: string = 'The operation was aborted', ...rest: any[]) {\n    super(message, ...rest)\n  }\n}\n", "export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n", "// ported from https://www.npmjs.com/package/fast-fifo\n\nexport interface Next<T> {\n  done?: boolean\n  error?: Error\n  value?: T\n}\n\nclass FixedFIFO<T> {\n  public buffer: Array<Next<T> | undefined>\n  private readonly mask: number\n  private top: number\n  private btm: number\n  public next: FixedFIFO<T> | null\n\n  constructor (hwm: number) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) {\n      throw new Error('Max size for a FixedFIFO should be a power of two')\n    }\n\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  push (data: Next<T>): boolean {\n    if (this.buffer[this.top] !== undefined) {\n      return false\n    }\n\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n\n    return true\n  }\n\n  shift (): Next<T> | undefined {\n    const last = this.buffer[this.btm]\n\n    if (last === undefined) {\n      return undefined\n    }\n\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  isEmpty (): boolean {\n    return this.buffer[this.btm] === undefined\n  }\n}\n\nexport interface FIFOOptions {\n  /**\n   * When the queue reaches this size, it will be split into head/tail parts\n   */\n  splitLimit?: number\n}\n\nexport class FIFO<T> {\n  public size: number\n  private readonly hwm: number\n  private head: FixedFIFO<T>\n  private tail: FixedFIFO<T>\n\n  constructor (options: FIFOOptions = {}) {\n    this.hwm = options.splitLimit ?? 16\n    this.head = new FixedFIFO<T>(this.hwm)\n    this.tail = this.head\n    this.size = 0\n  }\n\n  calculateSize (obj: any): number {\n    if (obj?.byteLength != null) {\n      return obj.byteLength\n    }\n\n    return 1\n  }\n\n  push (val: Next<T>): void {\n    if (val?.value != null) {\n      this.size += this.calculateSize(val.value)\n    }\n\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO<T>(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift (): Next<T> | undefined {\n    let val = this.tail.shift()\n\n    if (val === undefined && (this.tail.next != null)) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      val = this.tail.shift()\n    }\n\n    if (val?.value != null) {\n      this.size -= this.calculateSize(val.value)\n    }\n\n    return val\n  }\n\n  isEmpty (): boolean {\n    return this.head.isEmpty()\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\n\nimport deferred from 'p-defer'\nimport { FIFO, type Next } from './fifo.js'\n\nexport class AbortError extends Error {\n  type: string\n  code: string\n\n  constructor (message?: string, code?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\ninterface BasePushable<T> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end(err?: Error): this\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push(value: T): this\n\n  /**\n   * Returns a promise that resolves when the underlying queue becomes empty (e.g.\n   * this.readableLength === 0).\n   *\n   * If an AbortSignal is passed as an option and that signal aborts, it only\n   * causes the returned promise to reject - it does not end the pushable.\n   */\n  onEmpty(options?: AbortOptions): Promise<void>\n\n  /**\n   * This property contains the number of bytes (or objects) in the queue ready to be read.\n   *\n   * If `objectMode` is true, this is the number of objects in the queue, if false it's the\n   * total number of bytes in the queue.\n   */\n  readableLength: number\n}\n\n/**\n * An iterable that you can push values into.\n */\nexport interface Pushable<T, R = void, N = unknown> extends AsyncGenerator<T, R, N>, BasePushable<T> {}\n\n/**\n * Similar to `pushable`, except it yields multiple buffered chunks at a time. All values yielded from the iterable will be arrays.\n */\nexport interface PushableV<T, R = void, N = unknown> extends AsyncGenerator<T[], R, N>, BasePushable<T> {}\n\nexport interface Options {\n  /**\n   * A boolean value that means non-`Uint8Array`s will be passed to `.push`, default: `false`\n   */\n  objectMode?: boolean\n\n  /**\n   * A function called after *all* values have been yielded from the iterator (including\n   * buffered values). In the case when the iterator is ended with an error it will be\n   * passed the error as a parameter.\n   */\n  onEnd?(err?: Error): void\n}\n\nexport interface DoneResult { done: true }\nexport interface ValueResult<T> { done: false, value: T }\nexport type NextResult<T> = ValueResult<T> | DoneResult\n\ninterface getNext<T, V = T> { (buffer: FIFO<T>): NextResult<V> }\n\nexport interface ObjectPushableOptions extends Options {\n  objectMode: true\n}\n\nexport interface BytePushableOptions extends Options {\n  objectMode?: false\n}\n\n/**\n * Create a new async iterable. The values yielded from calls to `.next()`\n * or when used in a `for await of`loop are \"pushed\" into the iterable.\n * Returns an async iterable object with additional methods.\n */\nexport function pushable<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): Pushable<T>\nexport function pushable<T> (options: ObjectPushableOptions): Pushable<T>\nexport function pushable<T> (options: Options = {}): Pushable<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T> => {\n    const next: Next<T> | undefined = buffer.shift()\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    if (next.error != null) {\n      throw next.error\n    }\n\n    return {\n      done: next.done === true,\n      // @ts-expect-error if done is false, value will be present\n      value: next.value\n    }\n  }\n\n  return _pushable<T, T, Pushable<T>>(getNext, options)\n}\n\nexport function pushableV<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): PushableV<T>\nexport function pushableV<T> (options: ObjectPushableOptions): PushableV<T>\nexport function pushableV<T> (options: Options = {}): PushableV<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T[]> => {\n    let next: Next<T> | undefined\n    const values: T[] = []\n\n    while (!buffer.isEmpty()) {\n      next = buffer.shift()\n\n      if (next == null) {\n        break\n      }\n\n      if (next.error != null) {\n        throw next.error\n      }\n\n      if (next.done === false) {\n        // @ts-expect-error if done is false value should be pushed\n        values.push(next.value)\n      }\n    }\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    return {\n      done: next.done === true,\n      value: values\n    }\n  }\n\n  return _pushable<T, T[], PushableV<T>>(getNext, options)\n}\n\nfunction _pushable<PushType, ValueType, ReturnType> (getNext: getNext<PushType, ValueType>, options?: Options): ReturnType {\n  options = options ?? {}\n  let onEnd = options.onEnd\n  let buffer = new FIFO<PushType>()\n  let pushable: any\n  let onNext: ((next: Next<PushType>) => ReturnType) | null\n  let ended: boolean\n  let drain = deferred()\n\n  const waitNext = async (): Promise<NextResult<ValueType>> => {\n    try {\n      if (!buffer.isEmpty()) {\n        return getNext(buffer)\n      }\n\n      if (ended) {\n        return { done: true }\n      }\n\n      return await new Promise<NextResult<ValueType>>((resolve, reject) => {\n        onNext = (next: Next<PushType>) => {\n          onNext = null\n          buffer.push(next)\n\n          try {\n            resolve(getNext(buffer))\n          } catch (err) {\n            reject(err)\n          }\n\n          return pushable\n        }\n      })\n    } finally {\n      if (buffer.isEmpty()) {\n        // settle promise in the microtask queue to give consumers a chance to\n        // await after calling .push\n        queueMicrotask(() => {\n          drain.resolve()\n          drain = deferred()\n        })\n      }\n    }\n  }\n\n  const bufferNext = (next: Next<PushType>): ReturnType => {\n    if (onNext != null) {\n      return onNext(next)\n    }\n\n    buffer.push(next)\n    return pushable\n  }\n\n  const bufferError = (err: Error): ReturnType => {\n    buffer = new FIFO()\n\n    if (onNext != null) {\n      return onNext({ error: err })\n    }\n\n    buffer.push({ error: err })\n    return pushable\n  }\n\n  const push = (value: PushType): ReturnType => {\n    if (ended) {\n      return pushable\n    }\n\n    // @ts-expect-error `byteLength` is not declared on PushType\n    if (options?.objectMode !== true && value?.byteLength == null) {\n      throw new Error('objectMode was not true but tried to push non-Uint8Array value')\n    }\n\n    return bufferNext({ done: false, value })\n  }\n  const end = (err?: Error): ReturnType => {\n    if (ended) return pushable\n    ended = true\n\n    return (err != null) ? bufferError(err) : bufferNext({ done: true })\n  }\n  const _return = (): DoneResult => {\n    buffer = new FIFO()\n    end()\n\n    return { done: true }\n  }\n  const _throw = (err: Error): DoneResult => {\n    end(err)\n\n    return { done: true }\n  }\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next: waitNext,\n    return: _return,\n    throw: _throw,\n    push,\n    end,\n    get readableLength (): number {\n      return buffer.size\n    },\n    onEmpty: async (options?: AbortOptions) => {\n      const signal = options?.signal\n      signal?.throwIfAborted()\n\n      if (buffer.isEmpty()) {\n        return\n      }\n\n      let cancel: Promise<void> | undefined\n      let listener: (() => void) | undefined\n\n      if (signal != null) {\n        cancel = new Promise((resolve, reject) => {\n          listener = () => {\n            reject(new AbortError())\n          }\n\n          signal.addEventListener('abort', listener)\n        })\n      }\n\n      try {\n        await Promise.race([\n          drain.promise,\n          cancel\n        ])\n      } finally {\n        if (listener != null && signal != null) {\n          signal?.removeEventListener('abort', listener)\n        }\n      }\n    }\n  }\n\n  if (onEnd == null) {\n    return pushable\n  }\n\n  const _pushable = pushable\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next () {\n      return _pushable.next()\n    },\n    throw (err: Error) {\n      _pushable.throw(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    return () {\n      _pushable.return()\n\n      if (onEnd != null) {\n        onEnd()\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    push,\n    end (err: Error) {\n      _pushable.end(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return pushable\n    },\n    get readableLength () {\n      return _pushable.readableLength\n    },\n    onEmpty: (opts?: AbortOptions) => {\n      return _pushable.onEmpty(opts)\n    }\n  }\n\n  return pushable\n}\n", "/**\n * @packageDocumentation\n *\n * Adds types to the EventTarget class.\n *\n * Hopefully this won't be necessary\n * forever:\n *\n * - https://github.com/microsoft/TypeScript/issues/28357\n * - https://github.com/microsoft/TypeScript/issues/43477\n * - https://github.com/microsoft/TypeScript/issues/299\n * - https://www.npmjs.com/package/typed-events\n * - https://www.npmjs.com/package/typed-event-emitter\n * - https://www.npmjs.com/package/typed-event-target\n * - etc\n *\n * In addition to types, a `safeDispatchEvent` method is available which\n * prevents dispatching events that aren't in the event map, and a\n * `listenerCount` method which reports the number of listeners that are\n * currently registered for a given event.\n *\n * @example\n *\n * ```ts\n * import { TypedEventEmitter } from 'main-event'\n * import type { TypedEventTarget } from 'main-event'\n *\n * interface EventTypes {\n *   'test': CustomEvent<string>\n * }\n *\n * const target = new TypedEventEmitter<EventTypes>()\n *\n * // it's a regular EventTarget\n * console.info(target instanceof EventTarget) // true\n *\n * // register listeners normally\n * target.addEventListener('test', (evt) => {\n *   // evt is CustomEvent<string>\n * })\n *\n * // @ts-expect-error 'derp' is not in the event map\n * target.addEventListener('derp', () => {})\n *\n * // use normal dispatchEvent method\n * target.dispatchEvent(new CustomEvent('test', {\n *   detail: 'hello'\n * }))\n *\n * // use type safe dispatch method\n * target.safeDispatchEvent('test', {\n *   detail: 'world'\n * })\n *\n * // report listener count\n * console.info(target.listenerCount('test')) // 0\n *\n * // event emitters can be used purely as interfaces too\n * function acceptTarget (target: TypedEventTarget<EventTypes>) {\n *   // ...\n * }\n * ```\n */\n\nimport { setMaxListeners } from './events.js'\n\nexport interface EventCallback<EventType> { (evt: EventType): void }\nexport interface EventObject<EventType> { handleEvent: EventCallback<EventType> }\nexport type EventHandler<EventType> = EventCallback<EventType> | EventObject<EventType>\n\ninterface Listener {\n  once: boolean\n  callback: any\n}\n\n/**\n *\n */\nexport interface TypedEventTarget <EventMap extends Record<string, any>> extends EventTarget {\n  addEventListener<K extends keyof EventMap>(type: K, listener: EventHandler<EventMap[K]> | null, options?: boolean | AddEventListenerOptions): void\n\n  listenerCount (type: string): number\n\n  removeEventListener<K extends keyof EventMap>(type: K, listener?: EventHandler<EventMap[K]> | null, options?: boolean | EventListenerOptions): void\n\n  removeEventListener (type: string, listener?: EventHandler<Event>, options?: boolean | EventListenerOptions): void\n\n  safeDispatchEvent<Detail>(type: keyof EventMap, detail?: CustomEventInit<Detail>): boolean\n}\n\n/**\n * An implementation of a typed event target\n */\nexport class TypedEventEmitter<EventMap extends Record<string, any>> extends EventTarget implements TypedEventTarget<EventMap> {\n  readonly #listeners = new Map<any, Listener[]>()\n\n  constructor () {\n    super()\n\n    // silence MaxListenersExceededWarning warning on Node.js, this is a red\n    // herring almost all of the time\n    setMaxListeners(Infinity, this)\n  }\n\n  listenerCount (type: string): number {\n    const listeners = this.#listeners.get(type)\n\n    if (listeners == null) {\n      return 0\n    }\n\n    return listeners.length\n  }\n\n  addEventListener<K extends keyof EventMap>(type: K, listener: EventHandler<EventMap[K]> | null, options?: boolean | AddEventListenerOptions): void\n  addEventListener (type: string, listener: EventHandler<Event>, options?: boolean | AddEventListenerOptions): void {\n    super.addEventListener(type, listener, options)\n\n    let list = this.#listeners.get(type)\n\n    if (list == null) {\n      list = []\n      this.#listeners.set(type, list)\n    }\n\n    list.push({\n      callback: listener,\n      once: (options !== true && options !== false && options?.once) ?? false\n    })\n  }\n\n  removeEventListener<K extends keyof EventMap>(type: K, listener?: EventHandler<EventMap[K]> | null, options?: boolean | EventListenerOptions): void\n  removeEventListener (type: string, listener?: EventHandler<Event>, options?: boolean | EventListenerOptions): void {\n    super.removeEventListener(type.toString(), listener ?? null, options)\n\n    let list = this.#listeners.get(type)\n\n    if (list == null) {\n      return\n    }\n\n    list = list.filter(({ callback }) => callback !== listener)\n    this.#listeners.set(type, list)\n  }\n\n  dispatchEvent (event: Event): boolean {\n    const result = super.dispatchEvent(event)\n\n    let list = this.#listeners.get(event.type)\n\n    if (list == null) {\n      return result\n    }\n\n    list = list.filter(({ once }) => !once)\n    this.#listeners.set(event.type, list)\n\n    return result\n  }\n\n  safeDispatchEvent<Detail>(type: keyof EventMap, detail: CustomEventInit<Detail> = {}): boolean {\n    return this.dispatchEvent(new CustomEvent<Detail>(type as string, detail))\n  }\n}\n\nexport { setMaxListeners }\n", "/**\n * @packageDocumentation\n *\n * Race an event against an AbortSignal, taking care to remove any event\n * listeners that were added.\n *\n * @example Getting started\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   controller.abort()\n * }, 500)\n *\n * setTimeout(() => {\n *   // too late\n *   emitter.dispatchEvent(new CustomEvent('event'))\n * }, 1000)\n *\n * // throws an AbortError\n * const resolve = await raceEvent(emitter, 'event', controller.signal)\n * ```\n *\n * @example Aborting the promise with an error event\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   emitter.dispatchEvent(new CustomEvent('failure', {\n *     detail: new Error('Oh no!')\n *   }))\n * }, 1000)\n *\n * // throws 'Oh no!' error\n * const resolve = await raceEvent(emitter, 'success', AbortSignal.timeout(5000), {\n *   errorEvent: 'failure'\n * })\n * ```\n *\n * @example Customising the thrown AbortError\n *\n * The error message and `.code` property of the thrown `AbortError` can be\n * specified by passing options:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   controller.abort()\n * }, 500)\n *\n * // throws a Error: Oh no!\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   errorMessage: 'Oh no!',\n *   errorCode: 'ERR_OH_NO'\n * })\n * ```\n *\n * @example Only resolving on specific events\n *\n * Where multiple events with the same type are emitted, a `filter` function can\n * be passed to only resolve on one of them:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * // throws a Error: Oh no!\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   filter: (evt: Event) => {\n *     return evt.detail.foo === 'bar'\n *   }\n * })\n * ```\n *\n * @example Terminating early by throwing from the filter\n *\n * You can cause listening for the event to cease and all event listeners to be\n * removed by throwing from the filter:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * // throws Error: Cannot continue\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   filter: (evt) => {\n *     if (...reasons) {\n *       throw new Error('Cannot continue')\n *     }\n *\n *     return true\n *   }\n * })\n * ```\n */\n\n/**\n * An abort error class that extends error\n */\nexport class AbortError extends Error {\n  public type: string\n  public code: string | string\n\n  constructor (message?: string, code?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.name = 'AbortError'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface RaceEventOptions<T> {\n  /**\n   * The message for the error thrown if the signal aborts\n   */\n  errorMessage?: string\n\n  /**\n   * The code for the error thrown if the signal aborts\n   */\n  errorCode?: string\n\n  /**\n   * The name of an event emitted on the emitter that should cause the returned\n   * promise to reject. The rejection reason will be the `.detail` field of the\n   * event.\n   */\n  errorEvent?: string\n\n  /**\n   * When multiple events with the same name may be emitted, pass a filter\n   * function here to allow ignoring ones that should not cause the returned\n   * promise to resolve.\n   */\n  filter?(evt: T): boolean\n}\n\n/**\n * Race a promise against an abort signal\n */\nexport async function raceEvent <T> (emitter: EventTarget, eventName: string, signal?: AbortSignal, opts?: RaceEventOptions<T>): Promise<T> {\n  // create the error here so we have more context in the stack trace\n  const error = new AbortError(opts?.errorMessage, opts?.errorCode)\n\n  if (signal?.aborted === true) {\n    return Promise.reject(error)\n  }\n\n  return new Promise((resolve, reject) => {\n    function removeListeners (): void {\n      signal?.removeEventListener('abort', abortListener)\n      emitter.removeEventListener(eventName, eventListener)\n\n      if (opts?.errorEvent != null) {\n        emitter.removeEventListener(opts.errorEvent, errorEventListener)\n      }\n    }\n\n    const eventListener = (evt: any): void => {\n      try {\n        if (opts?.filter?.(evt) === false) {\n          return\n        }\n      } catch (err: any) {\n        removeListeners()\n        reject(err)\n        return\n      }\n\n      removeListeners()\n      resolve(evt)\n    }\n\n    const errorEventListener = (evt: any): void => {\n      removeListeners()\n      reject(evt.detail)\n    }\n\n    const abortListener = (): void => {\n      removeListeners()\n      reject(error)\n    }\n\n    signal?.addEventListener('abort', abortListener)\n    emitter.addEventListener(eventName, eventListener)\n\n    if (opts?.errorEvent != null) {\n      emitter.addEventListener(opts.errorEvent, errorEventListener)\n    }\n  })\n}\n", "export class QueueFullError extends Error {\n  static name = 'QueueFullError'\n\n  constructor (message: string = 'The queue was full') {\n    super(message)\n    this.name = 'QueueFullError'\n  }\n}\n", "/**\n * An abort error class that extends error\n */\nexport class AbortError extends Error {\n  public type: string\n  public code: string | string\n\n  constructor (message?: string, code?: string, name?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.name = name ?? 'AbortError'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface RaceSignalOptions {\n  /**\n   * The message for the error thrown if the signal aborts\n   */\n  errorMessage?: string\n\n  /**\n   * The code for the error thrown if the signal aborts\n   */\n  errorCode?: string\n\n  /**\n   * The name for the error thrown if the signal aborts\n   */\n  errorName?: string\n}\n\n/**\n * Race a promise against an abort signal\n */\nexport async function raceSignal <T> (promise: Promise<T>, signal?: AbortSignal, opts?: RaceSignalOptions): Promise<T> {\n  if (signal == null) {\n    return promise\n  }\n\n  if (signal.aborted) {\n    // the passed promise may yet resolve or reject but the use has signalled\n    // they are no longer interested so smother the error\n    promise.catch(() => {})\n    return Promise.reject(new AbortError(opts?.errorMessage, opts?.errorCode, opts?.errorName))\n  }\n\n  let listener\n\n  // create the error here so we have more context in the stack trace\n  const error = new AbortError(opts?.errorMessage, opts?.errorCode, opts?.errorName)\n\n  try {\n    return await Promise.race([\n      promise,\n      new Promise<T>((resolve, reject) => {\n        listener = () => {\n          reject(error)\n        }\n        signal.addEventListener('abort', listener)\n      })\n    ])\n  } finally {\n    if (listener != null) {\n      signal.removeEventListener('abort', listener)\n    }\n  }\n}\n", "import { AbortError } from 'abort-error'\n\nexport class JobRecipient<JobReturnType> {\n  public deferred: PromiseWithResolvers<JobReturnType>\n  public signal?: AbortSignal\n\n  constructor (signal?: AbortSignal) {\n    this.signal = signal\n    this.deferred = Promise.withResolvers()\n\n    this.onAbort = this.onAbort.bind(this)\n    this.signal?.addEventListener('abort', this.onAbort)\n  }\n\n  onAbort (): void {\n    this.deferred.reject(this.signal?.reason ?? new AbortError())\n  }\n\n  cleanup (): void {\n    this.signal?.removeEventListener('abort', this.onAbort)\n  }\n}\n", "import { AbortError } from 'abort-error'\nimport { setMaxListeners } from 'main-event'\nimport { raceSignal } from 'race-signal'\nimport { JobRecipient } from './recipient.js'\nimport type { JobStatus } from './index.js'\nimport type { AbortOptions } from 'abort-error'\n\n/**\n * Returns a random string\n */\nfunction randomId (): string {\n  return `${(parseInt(String(Math.random() * 1e9), 10)).toString()}${Date.now()}`\n}\n\nexport interface JobTimeline {\n  created: number\n  started?: number\n  finished?: number\n}\n\nexport class Job <JobOptions extends AbortOptions = AbortOptions, JobReturnType = unknown> {\n  public id: string\n  public fn: (options: JobOptions) => Promise<JobReturnType>\n  public options: JobOptions\n  public recipients: Array<JobRecipient<JobReturnType>>\n  public status: JobStatus\n  public readonly timeline: JobTimeline\n  private readonly controller: AbortController\n\n  constructor (fn: (options: JobOptions) => Promise<JobReturnType>, options: any) {\n    this.id = randomId()\n    this.status = 'queued'\n    this.fn = fn\n    this.options = options\n    this.recipients = []\n    this.timeline = {\n      created: Date.now()\n    }\n\n    this.controller = new AbortController()\n    setMaxListeners(Infinity, this.controller.signal)\n\n    this.onAbort = this.onAbort.bind(this)\n  }\n\n  abort (err: Error): void {\n    this.controller.abort(err)\n  }\n\n  onAbort (): void {\n    const allAborted = this.recipients.reduce((acc, curr) => {\n      return acc && (curr.signal?.aborted === true)\n    }, true)\n\n    // if all recipients have aborted the job, actually abort the job\n    if (allAborted) {\n      this.controller.abort(new AbortError())\n      this.cleanup()\n    }\n  }\n\n  async join (options: AbortOptions = {}): Promise<JobReturnType> {\n    const recipient = new JobRecipient<JobReturnType>(options.signal)\n    this.recipients.push(recipient)\n\n    options.signal?.addEventListener('abort', this.onAbort)\n\n    return recipient.deferred.promise\n  }\n\n  async run (): Promise<void> {\n    this.status = 'running'\n    this.timeline.started = Date.now()\n\n    try {\n      this.controller.signal.throwIfAborted()\n\n      const result = await raceSignal(this.fn({\n        ...(this.options ?? {}),\n        signal: this.controller.signal\n      }), this.controller.signal)\n\n      this.recipients.forEach(recipient => {\n        recipient.deferred.resolve(result)\n      })\n\n      this.status = 'complete'\n    } catch (err) {\n      this.recipients.forEach(recipient => {\n        recipient.deferred.reject(err)\n      })\n\n      this.status = 'errored'\n    } finally {\n      this.timeline.finished = Date.now()\n      this.cleanup()\n    }\n  }\n\n  cleanup (): void {\n    this.recipients.forEach(recipient => {\n      recipient.cleanup()\n      recipient.signal?.removeEventListener('abort', this.onAbort)\n    })\n  }\n}\n", "/**\n * A function with additional start/stop methods\n */\nexport interface DebouncedFunction {\n  (): void\n\n  start(): void\n  stop(): void\n}\n\n/**\n * Returns a function wrapper that will only call the passed function once\n *\n * Important - the passed function should not throw or reject\n */\nexport function debounce (func: () => void | Promise<void>, wait: number): DebouncedFunction {\n  let timeout: ReturnType<typeof setTimeout> | undefined\n\n  const output = function (): void {\n    const later = function (): void {\n      timeout = undefined\n      void func()\n    }\n\n    clearTimeout(timeout)\n    timeout = setTimeout(later, wait)\n  }\n  output.start = (): void => {}\n  output.stop = (): void => {\n    clearTimeout(timeout)\n  }\n\n  return output\n}\n", "/**\n * @packageDocumentation\n *\n * Based on `p-queue` but with access to the underlying queue, aborting a task\n * removes it from the queue and you can iterate over the queue results.\n *\n * @example\n *\n * ```ts\n * import all from 'it-all'\n * import { Queue } from 'it-queue'\n *\n * const queue = new Queue({\n *   concurrency: Infinity\n * })\n * void queue.add(async () => {\n *   return 'hello'\n * })\n * void queue.add(async () => {\n *   return 'world'\n * })\n *\n * const results = await all(queue)\n * // ['hello', 'world']\n *\n * // how many items are in the queue (includes running items)\n * console.info(queue.size)\n *\n * // how many items are running\n * console.info(queue.running)\n *\n * // how many items have not started running yet\n * console.info(queue.queued)\n * ```\n */\n\nimport { AbortError } from 'abort-error'\nimport { pushable } from 'it-pushable'\nimport { TypedEventEmitter } from 'main-event'\nimport { raceEvent } from 'race-event'\nimport { QueueFullError } from './errors.js'\nimport { Job } from './job.js'\nimport { debounce } from './utils.js'\nimport type { AbortOptions } from 'abort-error'\nexport type { Job, JobTimeline } from './job.js'\nexport type { JobRecipient } from './recipient.js'\n\nexport interface Comparator<T> {\n  (a: T, b: T): -1 | 0 | 1\n}\n\nexport interface QueueInit<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  /**\n   * Concurrency limit.\n   *\n   * Minimum: `1`.\n   *\n   * @default Infinity\n   */\n  concurrency?: number\n\n  /**\n   * If the queue size grows to larger than this number the promise returned\n   * from the add function will reject\n   *\n   * @default Infinity\n   */\n  maxSize?: number\n\n  /**\n   * An optional function that will sort the queue after a job has been added\n   */\n  sort?: Comparator<Job<JobOptions, JobReturnType>>\n\n  /**\n   * If false, `.start` will need to be called to start processing jobs\n   *\n   * @default true\n   */\n  autoStart?: boolean\n}\n\nexport type JobStatus = 'queued' | 'running' | 'errored' | 'complete'\n\nexport interface RunFunction<Options extends AbortOptions = AbortOptions, ReturnType = void> {\n  (options: Options): Promise<ReturnType>\n}\n\nexport interface JobMatcher<JobOptions extends AbortOptions = AbortOptions> {\n  (options?: Partial<JobOptions>): boolean\n}\n\nexport interface QueueJobSuccess<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  job: Job<JobOptions, JobReturnType>\n  result: JobReturnType\n}\n\nexport interface QueueJobFailure<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  job: Job<JobOptions, JobReturnType>\n  error: Error\n}\n\nexport interface QueueEvents<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  /**\n   * A job is about to start running\n   */\n  active: CustomEvent\n\n  /**\n   * All jobs have finished and the queue is empty\n   */\n  idle: CustomEvent\n\n  /**\n   * The queue is empty, jobs may be running\n   */\n  empty: CustomEvent\n\n  /**\n   * A job was added to the queue\n   */\n  add: CustomEvent\n\n  /**\n   * A job has finished or failed\n   */\n  next: CustomEvent\n\n  /**\n   * Emitted just after `\"completed\", a job has finished successfully - this\n   * event gives access to the job and it's result\n   */\n  success: CustomEvent<QueueJobSuccess<JobReturnType, JobOptions>>\n\n  /**\n   * A job has failed - this event gives access to the job and the thrown error\n   */\n  failure: CustomEvent<QueueJobFailure<JobReturnType, JobOptions>>\n}\n\n/**\n * Heavily influence by `p-queue` with the following differences:\n *\n * 1. Items remain at the head of the queue while they are running so `queue.size` includes `queue.pending` items - this is so interested parties can join the results of a queue item while it is running\n * 2. The options for a job are stored separately to the job in order for them to be modified while they are still in the queue\n * 3. If a job's abort signal fires before execution begins, it is removed from the queue immediately\n * 4. 'success'/'failure' events are emitted instead of 'error'/'complete'\n */\nexport class Queue<JobReturnType = unknown, JobOptions extends AbortOptions = AbortOptions> extends TypedEventEmitter<QueueEvents<JobReturnType, JobOptions>> {\n  public concurrency: number\n  public maxSize: number\n  public queue: Array<Job<JobOptions, JobReturnType>>\n  private pending: number\n  private readonly sort?: Comparator<Job<JobOptions, JobReturnType>>\n  private autoStart: boolean\n\n  constructor (init: QueueInit<JobReturnType, JobOptions> = {}) {\n    super()\n\n    this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY\n    this.maxSize = init.maxSize ?? Number.POSITIVE_INFINITY\n    this.pending = 0\n    this.autoStart = init.autoStart ?? true\n\n    this.sort = init.sort\n    this.queue = []\n\n    this.emitEmpty = debounce(this.emitEmpty.bind(this), 1)\n    this.emitIdle = debounce(this.emitIdle.bind(this), 1)\n  }\n\n  [Symbol.asyncIterator] (): AsyncGenerator<JobReturnType, void, unknown> {\n    return this.toGenerator()\n  }\n\n  emitEmpty (): void {\n    if (this.size !== 0) {\n      return\n    }\n\n    this.safeDispatchEvent('empty')\n  }\n\n  emitIdle (): void {\n    if (this.running !== 0) {\n      return\n    }\n\n    this.safeDispatchEvent('idle')\n  }\n\n  private tryToStartAnother (): boolean {\n    if (this.size === 0) {\n      this.emitEmpty()\n\n      if (this.running === 0) {\n        this.emitIdle()\n      }\n\n      return false\n    }\n\n    if (this.pending < this.concurrency) {\n      let job: Job<JobOptions, JobReturnType> | undefined\n\n      for (const j of this.queue) {\n        if (j.status === 'queued') {\n          job = j\n          break\n        }\n      }\n\n      if (job == null) {\n        return false\n      }\n\n      this.safeDispatchEvent('active')\n\n      this.pending++\n\n      void job.run()\n        .finally(() => {\n          // remove the job from the queue\n          for (let i = 0; i < this.queue.length; i++) {\n            if (this.queue[i] === job) {\n              this.queue.splice(i, 1)\n              break\n            }\n          }\n\n          this.pending--\n          this.safeDispatchEvent('next')\n          if (this.autoStart) {\n            this.tryToStartAnother()\n          }\n        })\n\n      return true\n    }\n\n    return false\n  }\n\n  private enqueue (job: Job<JobOptions, JobReturnType>): void {\n    this.queue.push(job)\n\n    if (this.sort != null) {\n      this.queue.sort(this.sort)\n    }\n  }\n\n  /**\n   * Start the queue. If the `autoStart` parameter passed to the constructor was\n   * not `false` this is a no-op\n   */\n  start (): void {\n    if (this.autoStart !== false) {\n      return\n    }\n\n    this.autoStart = true\n    this.tryToStartAnother()\n  }\n\n  /**\n   * Prevent further jobs from running - call `.start` to start the queue again\n   */\n  pause (): void {\n    this.autoStart = false\n  }\n\n  /**\n   * Adds a sync or async task to the queue. Always returns a promise.\n   */\n  async add (fn: RunFunction<JobOptions, JobReturnType>, options?: JobOptions): Promise<JobReturnType> {\n    options?.signal?.throwIfAborted()\n\n    if (this.size === this.maxSize) {\n      throw new QueueFullError()\n    }\n\n    const job = new Job<JobOptions, JobReturnType>(fn, options)\n    this.enqueue(job)\n    this.safeDispatchEvent('add')\n\n    if (this.autoStart) {\n      this.tryToStartAnother()\n    }\n\n    return job.join(options)\n      .then(result => {\n        this.safeDispatchEvent('success', { detail: { job, result } })\n\n        return result\n      })\n      .catch(err => {\n        if (job.status === 'queued') {\n          // job was aborted before it started - remove the job from the queue\n          for (let i = 0; i < this.queue.length; i++) {\n            if (this.queue[i] === job) {\n              this.queue.splice(i, 1)\n              break\n            }\n          }\n        }\n\n        this.safeDispatchEvent('failure', { detail: { job, error: err } })\n\n        throw err\n      })\n  }\n\n  /**\n   * Clear the queue\n   */\n  clear (): void {\n    this.queue.splice(0, this.queue.length)\n  }\n\n  /**\n   * Abort all jobs in the queue and clear it\n   */\n  abort (): void {\n    this.queue.forEach(job => {\n      job.abort(new AbortError())\n    })\n\n    this.clear()\n  }\n\n  /**\n   * Can be called multiple times. Useful if you for example add additional items at a later time.\n   *\n   * @returns A promise that settles when the queue becomes empty.\n   */\n  async onEmpty (options?: AbortOptions): Promise<void> {\n    // Instantly resolve if the queue is empty\n    if (this.size === 0) {\n      return\n    }\n\n    await raceEvent(this, 'empty', options?.signal)\n  }\n\n  /**\n   * @returns A promise that settles when the queue size is less than the given\n   * limit: `queue.size < limit`.\n   *\n   * If you want to avoid having the queue grow beyond a certain size you can\n   * `await queue.onSizeLessThan()` before adding a new item.\n   *\n   * Note that this only limits the number of items waiting to start. There\n   * could still be up to `concurrency` jobs already running that this call does\n   * not include in its calculation.\n   */\n  async onSizeLessThan (limit: number, options?: AbortOptions): Promise<void> {\n    // Instantly resolve if the queue is empty.\n    if (this.size < limit) {\n      return\n    }\n\n    await raceEvent(this, 'next', options?.signal, {\n      filter: () => this.size < limit\n    })\n  }\n\n  /**\n   * The difference with `.onEmpty` is that `.onIdle` guarantees that all work\n   * from the queue has finished. `.onEmpty` merely signals that the queue is\n   * empty, but it could mean that some promises haven't completed yet.\n   *\n   * @returns A promise that settles when the queue becomes empty, and all\n   * promises have completed; `queue.size === 0 && queue.pending === 0`.\n   */\n  async onIdle (options?: AbortOptions): Promise<void> {\n    // Instantly resolve if none pending and if nothing else is queued\n    if (this.pending === 0 && this.size === 0) {\n      return\n    }\n\n    await raceEvent(this, 'idle', options?.signal)\n  }\n\n  /**\n   * Size of the queue including running items\n   */\n  get size (): number {\n    return this.queue.length\n  }\n\n  /**\n   * The number of queued items waiting to run.\n   */\n  get queued (): number {\n    return this.queue.length - this.pending\n  }\n\n  /**\n   * The number of items currently running.\n   */\n  get running (): number {\n    return this.pending\n  }\n\n  /**\n   * Returns an async generator that makes it easy to iterate over the results\n   * of jobs added to the queue.\n   *\n   * The generator will end when the queue becomes idle, that is there are no\n   * jobs running and no jobs that have yet to run.\n   *\n   * If you need to keep the queue open indefinitely, consider using it-pushable\n   * instead.\n   */\n  async * toGenerator (options?: AbortOptions): AsyncGenerator<JobReturnType, void, unknown> {\n    options?.signal?.throwIfAborted()\n\n    const stream = pushable<JobReturnType>({\n      objectMode: true\n    })\n\n    const cleanup = (err?: Error): void => {\n      if (err != null) {\n        this.abort()\n      } else {\n        this.clear()\n      }\n\n      stream.end(err)\n    }\n\n    const onQueueJobComplete = (evt: CustomEvent<QueueJobSuccess<JobReturnType, JobOptions>>): void => {\n      if (evt.detail != null) {\n        stream.push(evt.detail.result)\n      }\n    }\n\n    const onQueueError = (evt: CustomEvent<QueueJobFailure<JobReturnType, JobOptions>>): void => {\n      cleanup(evt.detail.error)\n    }\n\n    const onQueueIdle = (): void => {\n      cleanup()\n    }\n\n    // clear the queue and throw if the query is aborted\n    const onSignalAbort = (): void => {\n      cleanup(new AbortError('Queue aborted'))\n    }\n\n    // add listeners\n    this.addEventListener('success', onQueueJobComplete)\n    this.addEventListener('failure', onQueueError)\n    this.addEventListener('idle', onQueueIdle)\n    options?.signal?.addEventListener('abort', onSignalAbort)\n\n    try {\n      yield * stream\n    } finally {\n      // remove listeners\n      this.removeEventListener('success', onQueueJobComplete)\n      this.removeEventListener('failure', onQueueError)\n      this.removeEventListener('idle', onQueueIdle)\n      options?.signal?.removeEventListener('abort', onSignalAbort)\n\n      // empty the queue for when the user has broken out of a loop early\n      cleanup()\n    }\n  }\n}\n", "export const WORKER_REQUEST_READ_LOCK = 'lock:worker:request-read'\nexport const WORKER_ABORT_READ_LOCK_REQUEST = 'lock:worker:abort-read-request'\nexport const WORKER_RELEASE_READ_LOCK = 'lock:worker:release-read'\nexport const MASTER_GRANT_READ_LOCK = 'lock:master:grant-read'\nexport const MASTER_READ_LOCK_ERROR = 'lock:master:error-read'\n\nexport const WORKER_REQUEST_WRITE_LOCK = 'lock:worker:request-write'\nexport const WORKER_ABORT_WRITE_LOCK_REQUEST = 'lock:worker:abort-write-request'\nexport const WORKER_RELEASE_WRITE_LOCK = 'lock:worker:release-write'\nexport const MASTER_GRANT_WRITE_LOCK = 'lock:master:grant-write'\nexport const MASTER_WRITE_LOCK_ERROR = 'lock:master:error-write'\n\nexport const WORKER_FINALIZE = 'lock:worker:finalize'\n\nexport const BROADCAST_CHANNEL_NAME = 'mortice'\n\nexport const defaultOptions = {\n  singleProcess: false\n}\n", "import {\n  WORKER_FINALIZE\n} from '../constants.js'\nimport type { AbortEventData, AbortRequestType, FinalizeEventData, MorticeEvents, RequestType } from '../mortice.js'\nimport type { TypedEventTarget } from 'main-event'\n\nexport const handleChannelWorkerLockRequest = (emitter: TypedEventTarget<MorticeEvents>, channel: BroadcastChannel, masterEvent: RequestType, abortMasterEvent: AbortRequestType, requestType: string, abortType: string, errorType: string, releaseType: string, grantType: string) => {\n  return (event: MessageEvent) => {\n    if (event.data == null) {\n      return\n    }\n\n    const requestEvent = {\n      type: event.data.type,\n      name: event.data.name,\n      identifier: event.data.identifier\n    }\n\n    // worker is requesting lock\n    if (requestEvent.type === requestType) {\n      emitter.safeDispatchEvent(masterEvent, {\n        detail: {\n          name: requestEvent.name,\n          identifier: requestEvent.identifier,\n          handler: async (): Promise<void> => {\n            // grant lock to worker\n            channel.postMessage({\n              type: grantType,\n              name: requestEvent.name,\n              identifier: requestEvent.identifier\n            })\n\n            // wait for worker to finish\n            await new Promise<void>((resolve) => {\n              const releaseEventListener = (event: MessageEvent): void => {\n                if (event?.data == null) {\n                  return\n                }\n\n                const releaseEvent = {\n                  type: event.data.type,\n                  name: event.data.name,\n                  identifier: event.data.identifier\n                }\n\n                if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {\n                  channel.removeEventListener('message', releaseEventListener)\n                  resolve()\n                }\n              }\n\n              channel.addEventListener('message', releaseEventListener)\n            })\n          },\n          onError: (err: Error) => {\n            // send error to worker\n            channel.postMessage({\n              type: errorType,\n              name: requestEvent.name,\n              identifier: requestEvent.identifier,\n              error: {\n                message: err.message,\n                name: err.name,\n                stack: err.stack\n              }\n            })\n          }\n        }\n      })\n    }\n\n    // worker is no longer interested in requesting the lock\n    if (requestEvent.type === abortType) {\n      emitter.safeDispatchEvent<AbortEventData>(abortMasterEvent, {\n        detail: {\n          name: requestEvent.name,\n          identifier: requestEvent.identifier\n        }\n      })\n    }\n\n    // worker is done with lock\n    if (requestEvent.type === WORKER_FINALIZE) {\n      emitter.safeDispatchEvent<FinalizeEventData>('finalizeRequest', {\n        detail: {\n          name: requestEvent.name\n        }\n      })\n    }\n  }\n}\n", "export const nanoid = (size: number = 10): string => {\n  return Math.random().toString().substring(2, size + 2)\n}\n", "import {\n  WORKER_REQUEST_READ_LOCK,\n  WORKER_RELEASE_READ_LOCK,\n  MASTER_GRANT_READ_LOCK,\n  WORKER_REQUEST_WRITE_LOCK,\n  WORKER_RELEASE_WRITE_LOCK,\n  MASTER_GRANT_WRITE_LOCK,\n  WORKER_ABORT_READ_LOCK_REQUEST,\n  WORKER_ABORT_WRITE_LOCK_REQUEST,\n  MASTER_READ_LOCK_ERROR,\n  MASTER_WRITE_LOCK_ERROR,\n  WORKER_FINALIZE,\n  BROADCAST_CHANNEL_NAME\n} from '../constants.js'\nimport { nanoid } from '../utils.js'\nimport type { Mortice, Release } from '../index.js'\nimport type { AbortOptions } from 'abort-error'\n\nexport class MorticeChannelWorker implements Mortice {\n  private name: string\n  private channel: BroadcastChannel\n\n  constructor (name: string) {\n    this.name = name\n    this.channel = new BroadcastChannel(BROADCAST_CHANNEL_NAME)\n  }\n\n  readLock (options?: AbortOptions): Promise<Release> {\n    return this.sendRequest(\n      WORKER_REQUEST_READ_LOCK,\n      WORKER_ABORT_READ_LOCK_REQUEST,\n      MASTER_GRANT_READ_LOCK,\n      MASTER_READ_LOCK_ERROR,\n      WORKER_RELEASE_READ_LOCK,\n      options\n    )\n  }\n\n  writeLock (options?: AbortOptions): Promise<Release> {\n    return this.sendRequest(\n      WORKER_REQUEST_WRITE_LOCK,\n      WORKER_ABORT_WRITE_LOCK_REQUEST,\n      MASTER_GRANT_WRITE_LOCK,\n      MASTER_WRITE_LOCK_ERROR,\n      WORKER_RELEASE_WRITE_LOCK,\n      options\n    )\n  }\n\n  finalize (): void {\n    this.channel.postMessage({\n      type: WORKER_FINALIZE,\n      name: this.name\n    })\n\n    this.channel.close()\n  }\n\n  private async sendRequest (requestType: string, abortType: string, grantType: string, errorType: string, releaseType: string, options?: AbortOptions): Promise<Release> {\n    options?.signal?.throwIfAborted()\n    const id = nanoid()\n\n    this.channel.postMessage({\n      type: requestType,\n      identifier: id,\n      name: this.name\n    })\n\n    return new Promise<Release>((resolve, reject) => {\n      const abortListener = (): void => {\n        this.channel.postMessage({\n          type: abortType,\n          identifier: id,\n          name: this.name\n        })\n      }\n\n      options?.signal?.addEventListener('abort', abortListener, {\n        once: true\n      })\n\n      const listener = (event: MessageEvent): void => {\n        if (event.data?.identifier !== id) {\n          return\n        }\n\n        if (event.data?.type === grantType) {\n          this.channel.removeEventListener('message', listener)\n          options?.signal?.removeEventListener('abort', abortListener)\n\n          // lock granted\n          resolve(() => {\n            // release lock\n            this.channel.postMessage({\n              type: releaseType,\n              identifier: id,\n              name: this.name\n            })\n          })\n        }\n\n        if (event.data.type === errorType) {\n          this.channel.removeEventListener('message', listener)\n          options?.signal?.removeEventListener('abort', abortListener)\n\n          // error while waiting for grant of lock\n          const err = new Error()\n\n          if (event.data.error != null) {\n            err.message = event.data.error.message\n            err.name = event.data.error.name\n            err.stack = event.data.error.stack\n          }\n\n          reject(err)\n        }\n      }\n\n      this.channel.addEventListener('message', listener)\n    })\n  }\n}\n", "import { TypedEventEmitter } from 'main-event'\nimport {\n  WORKER_REQUEST_READ_LOCK,\n  WORKER_RELEASE_READ_LOCK,\n  MASTER_GRANT_READ_LOCK,\n  WORKER_REQUEST_WRITE_LOCK,\n  WORKER_RELEASE_WRITE_LOCK,\n  MASTER_GRANT_WRITE_LOCK,\n  WORKER_ABORT_READ_LOCK_REQUEST,\n  WORKER_ABORT_WRITE_LOCK_REQUEST,\n  MASTER_READ_LOCK_ERROR,\n  MASTER_WRITE_LOCK_ERROR,\n  BROADCAST_CHANNEL_NAME,\n  defaultOptions\n} from './constants.js'\nimport { handleChannelWorkerLockRequest } from './main/channel.ts'\nimport { MorticeChannelWorker } from './workers/channel.ts'\nimport type { Mortice, MorticeOptions } from './index.js'\nimport type { MorticeEvents } from './mortice.js'\nimport type { TypedEventTarget } from 'main-event'\n\nexport default (options: Required<MorticeOptions>): Mortice | TypedEventTarget<MorticeEvents> => {\n  options = Object.assign({}, defaultOptions, options)\n  const isPrimary = Boolean(globalThis.document) || options.singleProcess\n\n  if (isPrimary) {\n    const channel = new BroadcastChannel(BROADCAST_CHANNEL_NAME)\n    const emitter = new TypedEventEmitter<MorticeEvents>()\n\n    channel.addEventListener('message', handleChannelWorkerLockRequest(\n      emitter,\n      channel,\n      'requestReadLock',\n      'abortReadLockRequest',\n      WORKER_REQUEST_READ_LOCK,\n      WORKER_ABORT_READ_LOCK_REQUEST,\n      MASTER_READ_LOCK_ERROR,\n      WORKER_RELEASE_READ_LOCK,\n      MASTER_GRANT_READ_LOCK\n    ))\n    channel.addEventListener('message', handleChannelWorkerLockRequest(\n      emitter,\n      channel,\n      'requestWriteLock',\n      'abortWriteLockRequest',\n      WORKER_REQUEST_WRITE_LOCK,\n      WORKER_ABORT_WRITE_LOCK_REQUEST,\n      MASTER_WRITE_LOCK_ERROR,\n      WORKER_RELEASE_WRITE_LOCK,\n      MASTER_GRANT_WRITE_LOCK\n    ))\n\n    return emitter\n  }\n\n  return new MorticeChannelWorker(options.name)\n}\n", "import { AbortError } from 'abort-error'\nimport { Queue } from 'it-queue'\nimport impl from './node.js'\nimport type { Mortice, MorticeOptions, Release } from './index.js'\nimport type { AbortOptions } from 'abort-error'\nimport type { TypedEventTarget } from 'main-event'\n\nexport type RequestType = 'requestReadLock' | 'requestWriteLock'\nexport type AbortRequestType = 'abortReadLockRequest' | 'abortWriteLockRequest'\nexport type FinalizeRequestType = 'finalizeRequest'\n\nexport interface RequestEventData {\n  name: string\n  identifier: string\n  handler(): Promise<void>\n  onError(err: Error): void\n}\n\nexport interface RequestEvent {\n  type: string\n  identifier: string\n  name: string,\n  error?: {\n    name: string\n    message: string\n    stack: string\n  }\n}\n\nexport interface AbortEventData {\n  name: string\n  identifier: string\n}\n\nexport interface FinalizeEventData {\n  name: string\n}\n\nexport interface MorticeEvents {\n  requestReadLock: CustomEvent<RequestEventData>\n  abortReadLockRequest: CustomEvent<AbortEventData>\n  requestWriteLock: CustomEvent<RequestEventData>\n  abortWriteLockRequest: CustomEvent<AbortEventData>\n  finalizeRequest: CustomEvent<FinalizeEventData>\n}\n\nconst mutexes: Map<string, Mortice> = new Map()\nlet implementation: Mortice | TypedEventTarget<MorticeEvents>\n\nexport function isMortice (obj?: any): obj is Mortice {\n  return typeof obj?.readLock === 'function' && typeof obj?.writeLock === 'function'\n}\n\nexport function getImplementation (opts: Required<MorticeOptions>): Mortice | TypedEventTarget<MorticeEvents> {\n  if (implementation == null) {\n    implementation = impl(opts)\n\n    if (!isMortice(implementation)) {\n      const emitter = implementation\n\n      // we are master, set up worker requests\n      emitter.addEventListener('requestReadLock', (event: CustomEvent<RequestEventData>) => {\n        const mutexName = event.detail.name\n        const identifier = event.detail.identifier\n        const mutex = mutexes.get(mutexName)\n\n        if (mutex == null) {\n          return\n        }\n\n        const abortController = new AbortController()\n\n        const abortListener = (event: CustomEvent<AbortEventData>): void => {\n          if (event.detail.name !== mutexName || event.detail.identifier !== identifier) {\n            return\n          }\n\n          abortController.abort()\n        }\n\n        emitter.addEventListener('abortReadLockRequest', abortListener)\n\n        void mutex.readLock({\n          signal: abortController.signal\n        })\n          .then(async release => {\n            await event.detail.handler()\n              .finally(() => {\n                release()\n              })\n          })\n          .catch(err => {\n            event.detail.onError(err)\n          })\n          .finally(() => {\n            emitter.removeEventListener('abortReadLockRequest', abortListener)\n          })\n      })\n\n      emitter.addEventListener('requestWriteLock', (event: CustomEvent<RequestEventData>) => {\n        const mutexName = event.detail.name\n        const identifier = event.detail.identifier\n        const mutex = mutexes.get(mutexName)\n\n        if (mutex == null) {\n          return\n        }\n\n        const abortController = new AbortController()\n\n        const abortListener = (event: CustomEvent<AbortEventData>): void => {\n          if (event.detail.name !== mutexName || event.detail.identifier !== identifier) {\n            return\n          }\n\n          abortController.abort()\n        }\n\n        emitter.addEventListener('abortWriteLockRequest', abortListener)\n\n        void mutex.writeLock({\n          signal: abortController.signal\n        })\n          .then(async release => {\n            await event.detail.handler()\n              .finally(() => {\n                release()\n              })\n          })\n          .catch(err => {\n            event.detail.onError(err)\n          })\n          .finally(() => {\n            emitter.removeEventListener('abortWriteLockRequest', abortListener)\n          })\n      })\n\n      emitter.addEventListener('finalizeRequest', (event: CustomEvent<FinalizeEventData>): void => {\n        const mutexName = event.detail.name\n        const mutex = mutexes.get(mutexName)\n\n        if (mutex == null) {\n          return\n        }\n\n        mutex.finalize()\n      })\n    }\n  }\n\n  return implementation\n}\n\nasync function createReleasable (queue: Queue, options?: AbortOptions): Promise<Release> {\n  let res: (release: Release) => void\n  let rej: (err: Error) => void\n\n  const p = new Promise<Release>((resolve, reject) => {\n    res = resolve\n    rej = reject\n  })\n\n  const listener = (): void => {\n    rej(new AbortError())\n  }\n\n  options?.signal?.addEventListener('abort', listener, {\n    once: true\n  })\n\n  queue.add(async () => {\n    await new Promise<void>((resolve) => {\n      res(() => {\n        options?.signal?.removeEventListener('abort', listener)\n        resolve()\n      })\n    })\n  }, {\n    signal: options?.signal\n  })\n    .catch((err) => {\n      rej(err)\n    })\n\n  return p\n}\n\nexport const createMutex = (name: string, options: Required<MorticeOptions>): Mortice => {\n  let mutex = mutexes.get(name)\n\n  if (mutex != null) {\n    return mutex\n  }\n\n  const implementation = getImplementation(options)\n\n  // a Mortice instance will be returned if we are a worker, otherwise if we are\n  // primary an event target will be returned that fires events when workers\n  // request a lock\n  if (isMortice(implementation)) {\n    mutex = implementation\n\n    mutexes.set(name, mutex)\n\n    return mutex\n  }\n\n  const masterQueue = new Queue({\n    concurrency: 1\n  })\n  let readQueue: Queue | null\n\n  mutex = {\n    async readLock (opts?: AbortOptions) {\n      // If there's already a read queue, just add the task to it\n      if (readQueue != null) {\n        return createReleasable(readQueue, opts)\n      }\n\n      // Create a new read queue\n      readQueue = new Queue({\n        concurrency: options.concurrency,\n        autoStart: false\n      })\n      const localReadQueue = readQueue\n\n      // Add the task to the read queue\n      const readPromise = createReleasable(readQueue, opts)\n\n      void masterQueue.add(async () => {\n        // Start the task only once the master queue has completed processing\n        // any previous tasks\n        localReadQueue.start()\n\n        // Once all the tasks in the read queue have completed, remove it so\n        // that the next read lock will occur after any write locks that were\n        // started in the interim\n        await localReadQueue.onIdle()\n          .then(() => {\n            if (readQueue === localReadQueue) {\n              readQueue = null\n            }\n          })\n      })\n\n      return readPromise\n    },\n    async writeLock (opts?: AbortOptions) {\n      // Remove the read queue reference, so that any later read locks will be\n      // added to a new queue that starts after this write lock has been\n      // released\n      readQueue = null\n\n      return createReleasable(masterQueue, opts)\n    },\n    finalize: () => {\n      mutexes.delete(name)\n    },\n    queue: masterQueue\n  }\n\n  mutexes.set(name, mutex)\n\n  // if requested, finalize the lock once the last lock holder has released it\n  if (options.autoFinalize === true) {\n    masterQueue.addEventListener('idle', () => {\n      mutex.finalize()\n    }, {\n      once: true\n    })\n  }\n\n  return mutex\n}\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "createMortice", "AbortError", "message", "rest", "pDefer", "deferred", "resolve", "reject", "FixedFIFO", "hwm", "data", "last", "FIFO", "options", "obj", "val", "prev", "next", "AbortError", "message", "code", "pushable", "options", "_pushable", "buffer", "next", "_pushable", "getNext", "options", "onEnd", "buffer", "FIFO", "pushable", "onNext", "ended", "drain", "pDefer", "waitNext", "resolve", "reject", "next", "err", "bufferNext", "bufferError", "push", "value", "end", "_return", "_throw", "signal", "cancel", "listener", "AbortError", "opts", "TypedEventEmitter", "#listeners", "type", "listeners", "listener", "options", "list", "callback", "event", "result", "once", "detail", "AbortError", "message", "code", "raceEvent", "emitter", "eventName", "signal", "opts", "error", "resolve", "reject", "removeListeners", "abortListener", "eventListener", "errorEventListener", "evt", "err", "QueueFullError", "message", "AbortError", "message", "code", "name", "raceSignal", "promise", "signal", "opts", "listener", "error", "resolve", "reject", "JobRecipient", "signal", "AbortError", "randomId", "Job", "fn", "options", "err", "acc", "curr", "AbortError", "recipient", "JobRecipient", "result", "raceSignal", "debounce", "func", "wait", "timeout", "output", "later", "Queue", "TypedEventEmitter", "init", "debounce", "job", "j", "i", "fn", "options", "QueueFullError", "Job", "result", "err", "AbortError", "raceEvent", "limit", "stream", "pushable", "cleanup", "onQueueJobComplete", "evt", "onQueueError", "onQueueIdle", "onSignalAbort", "WORKER_REQUEST_READ_LOCK", "WORKER_ABORT_READ_LOCK_REQUEST", "WORKER_RELEASE_READ_LOCK", "MASTER_GRANT_READ_LOCK", "MASTER_READ_LOCK_ERROR", "WORKER_REQUEST_WRITE_LOCK", "WORKER_ABORT_WRITE_LOCK_REQUEST", "WORKER_RELEASE_WRITE_LOCK", "MASTER_GRANT_WRITE_LOCK", "MASTER_WRITE_LOCK_ERROR", "WORKER_FINALIZE", "BROADCAST_CHANNEL_NAME", "defaultOptions", "handleChannelWorkerLockRequest", "emitter", "channel", "masterEvent", "abortMasterEvent", "requestType", "abortType", "errorType", "releaseType", "grantType", "event", "requestEvent", "resolve", "releaseEventListener", "releaseEvent", "err", "WORKER_FINALIZE", "nanoid", "size", "MorticeChannelWorker", "name", "BROADCAST_CHANNEL_NAME", "options", "WORKER_REQUEST_READ_LOCK", "WORKER_ABORT_READ_LOCK_REQUEST", "MASTER_GRANT_READ_LOCK", "MASTER_READ_LOCK_ERROR", "WORKER_RELEASE_READ_LOCK", "WORKER_REQUEST_WRITE_LOCK", "WORKER_ABORT_WRITE_LOCK_REQUEST", "MASTER_GRANT_WRITE_LOCK", "MASTER_WRITE_LOCK_ERROR", "WORKER_RELEASE_WRITE_LOCK", "WORKER_FINALIZE", "requestType", "abortType", "grantType", "errorType", "releaseType", "id", "nanoid", "resolve", "reject", "abortListener", "listener", "event", "err", "browser_default", "options", "defaultOptions", "channel", "BROADCAST_CHANNEL_NAME", "emitter", "TypedEventEmitter", "handleChannelWorkerLockRequest", "WORKER_REQUEST_READ_LOCK", "WORKER_ABORT_READ_LOCK_REQUEST", "MASTER_READ_LOCK_ERROR", "WORKER_RELEASE_READ_LOCK", "MASTER_GRANT_READ_LOCK", "WORKER_REQUEST_WRITE_LOCK", "WORKER_ABORT_WRITE_LOCK_REQUEST", "MASTER_WRITE_LOCK_ERROR", "WORKER_RELEASE_WRITE_LOCK", "MASTER_GRANT_WRITE_LOCK", "MorticeChannelWorker", "mutexes", "implementation", "isMortice", "obj", "getImplementation", "opts", "browser_default", "emitter", "event", "mutexName", "identifier", "mutex", "abortController", "abortListener", "release", "err", "createReleasable", "queue", "options", "res", "rej", "p", "resolve", "reject", "listener", "AbortError", "createMutex", "name", "masterQueue", "Queue", "readQueue", "localReadQueue", "readPromise", "defaultOptions", "createMortice", "options", "opts", "createMutex"]
}
